<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="开放最短路径优先Open Shortest Path First 开放最短路径优先，是一个开放标准的链路状态路由协议（an open-standard Link State routing protocol）。所有链路状态路由协议都是对链路状态进行通告。当链路状态路由器开始在某条网络链路上运作时，逻辑网络的相关信息就被添加到路由器的本地链路状态数据库(Link State Database, LS">
<meta property="og:type" content="article">
<meta property="og:title" content="ospf">
<meta property="og:url" content="http://example.com/2022/11/16/ospf%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="frozenfish&#39;blog">
<meta property="og:description" content="开放最短路径优先Open Shortest Path First 开放最短路径优先，是一个开放标准的链路状态路由协议（an open-standard Link State routing protocol）。所有链路状态路由协议都是对链路状态进行通告。当链路状态路由器开始在某条网络链路上运作时，逻辑网络的相关信息就被添加到路由器的本地链路状态数据库(Link State Database, LS">
<meta property="og:locale">
<meta property="article:published_time" content="2022-11-15T16:01:03.000Z">
<meta property="article:modified_time" content="2023-12-02T12:27:48.406Z">
<meta property="article:author" content="frozenfish">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/11/16/ospf详解/"/>





  <title>ospf | frozenfish'blog</title>
  














<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">frozenfish'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/16/ospf%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.webp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="frozenfish'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ospf</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-16T00:01:03+08:00">
                2022-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>开放最短路径优先<br>Open Shortest Path First</p>
<p>开放最短路径优先，是一个开放标准的链路状态路由协议（an open-standard Link State routing protocol）。所有链路状态路由协议都是对链路状态进行通告。当链路状态路由器开始在某条网络链路上运作时，逻辑网络的相关信息就被添加到路由器的本地链路状态数据库(Link State Database, LSDB)中。该本地路由器此时在其运作链路上，发出Hello数据包，以确定出是否有其它链路状态路由器也在其各自接口上运行着链路状态路由协议。OSPF直接运行在 IP 协议上，使用 IP 下编号为89号的协议。</p>
<p>OSPF概述及基础知识<br>OSPF Overview and Fundamentals</p>
<span id="more"></span>
<p>人们为 OSPF 撰写了多个请求评议（Requests for Comments, RFCs)。在本小节，将通过一些 OSPF 有关的最常见的几个 RFCs ，来了解一下 OSPF 的历史。 OSPF 工作组成立于1987年，自成立以后，该工作组发布了为数众多的 RFCs 。下面列出了 OSPF 有关的一些最常见的 RFCs 。</p>
<p>RFC 1131 – OSPF规格，OSPF Specification<br>RFC 1584 – OSPF的多播扩展, Multicast Extensions to OSPF<br>RFC 1587 – OSPF的 NSSA 选项，the OSPF NSSA Option<br>RFC 1850 – OSPF版本2的管理信息库，OSPF Version 2 Management Informaiton Base<br>RFC 2328 – OSPF版本2<br>RFC 2740 – OSPF版本3<br>RFC 1131对 OSPF 的第一次迭代（the first iteration of OSPF）进行了说明, 而应用在明确该协议是否工作的早期测试中。</p>
<p>RFC 1584为 OSPF 提供了对 IP 多播流量的支持扩展。这通常被称为多播 OSPF （Multicast OSPF, MOSPF）。但该标准不常用到，而最重要的是思科不支持该标准。</p>
<p>RFC 1587 对一种 OSPF 的次末梢区域（Not-So-Stubby Area, NSSA）的运作方式进行了说明。 NSSA 允许通过一台自治系统边界路由器（an Autonomous System Boundary Router, ASBR）, 采用一条 NSSA 的外部LSA, 实现外部路由知识的注入（the injection of external routing knowledge）。在本模块的稍后会对不同的 NSSAs 进行说明。</p>
<p>RFC 1850实现了使用简单网络管理协议（Simple Network Management Protocol, SNMP）对 OSPF 的网络管理。在网络管理系统中， SNMP 用于监测接入网络设备中需要留心的一些情况。本标准的应用超出了 CCNA 考试要求范围，不会在本书中进行说明。</p>
<p>RFC 2328详细陈述了 OSPF 版本2的最新更新，而 OSPF 版本2正是现今在用的默认版本。 OSPF 版本2最初是在RFC 1247中进行说明的，该 RFC 解决了 OSPF 版本1初次发布中发现的一系列问题，并对该协议进行了修正，实现了未来修改不致产生出向后兼容问题。正因为如此， OSPF 版本2与版本1是不兼容的。</p>
<p>最后，RFC 2740说明了为支持 IPv6 而对 OSPF 做出的修改（也就是版本3）。应假定本模块中所有对 OSPF 一词的使用，都是指的 OSPF 版本2。</p>
<p>链路状态基础<br>Link State Fundamentals</p>
<p>当对某条特定链路(也就是接口）开启链路状态路由协议时，与那个网络有关的信息就被加入到本地 LSDB 中。该本地路由器此时就往其运作的各链路上发送Hello数据包，以确定有否其它链路状态路由器也在接口上运行着。Hello数据包用于邻居发现，并在邻居路由器之间维护邻接关系。本模块稍后部分会详细说明这些消息。</p>
<p>在找到一台邻居路由器后， 假定两台路由器在同一子网且位于同一区域，同时诸如认证方法及计时器等其它参数都是一致的（ identical ），那么本地路由器就尝试建立一个邻接关系（ adjacency ）。此邻接关系令到两台路由器将摘要的 LSDB 信息通告给对方。这种信息交换，交换的并非真实的详细数据库信息，而是数据的摘要。</p>
<p>各台路由器参照其本地 LSDB ，对收到的摘要信息做出评估，以确保其有着最新信息。如邻接关系的一侧认识到它需要一个更新，路由器就从邻接路由器请求新信息。而来自邻居路由器的更新就包含了 LSDB 中的具体数据。此交换过程持续到两台路由器都拥有同样的 LSDB 。 OSPF 用到不同类型的报文，以交换数据库信息，从而确保所有路由器都有着网络的统一视图。这些不同的数据包类型将在本模块稍后进行详细说明。</p>
<p>紧接着数据库的交换， SPF 算法就运行起来，创建出到某个区域或网络主干中所有主机的最短路径树, SPF算法将执行运算的路由器，作为该树的根（Following the database exchange, the SPF algorithm runs and creates a shortest path tree to all hosts in an area or in the network backbone, with the router that is performing the calculation at the root of that tree）。在第 10 天中，对 SPF 算法进行了简要介绍。</p>
<p>OSPF基础<br>OSPF Fundamentals</p>
<p>与 EIGRP 能够支持多个网络层协议不同， OSPF 只能支持 IP ，也就是 IPv4 和 IPv6 。和 EIGRP 相同的是， OSPF 支持 VLSM 、认证及在诸如以太网这样的多路访问（Multi-Access networks）网络上，于发送和接收更新时，利用 IP 多播技术（IP Multicast）。</p>
<p>OSPF是一种层次化的路由协议，将网络以逻辑方式，分为称作区域的众多子域。这种逻辑分段方法，用于限制链路状态通告在 OSPF 域中扩散的范围（OSPF is a hierarchical routing protocol that logically divides the network into subdomains referred to as areas. This logical segmentation is used to limit the scope of Link State Advertisements(LSAs) flooding throughout the OSPF domain）。 LSAs 是由运行 OSPF 的路由器发出的特殊类型数据包。在区域内和区域间用到不同类型的 LSAs 。通过限制一些类型的 LSAs 在区域间传播， OSPF 的层次化实现有效地减少了 OSPF 网络中路由协议流量的数量。</p>
<p>注意： OSPF的这些 LSAs 会在第 39 天详细说明。</p>
<p>在多区域 OSPF 网络中，必须指定一个区域作为骨干区域, 或者叫Area 0。OSPF骨干就是此 OSPF 网络的逻辑中心。其它非骨干区域都必须物理连接到骨干。但因为在非骨干区域和骨干区域之间有着一条物理连接，并非总是可能或可行的，所以 OSPF 标准允许使用到骨干的虚拟连接。这些虚拟连接也就是常说的虚拟链路，但此概念是不包括在当前的 CCNA 大纲中的（In a multi-area OSPF network, one area must be designated as the backbone area, or Area 0. The OSPF backbone is the logical centre of the OSPF network. All other non-backbone areas must be connected physically to the backbone. However, because it is not always possible or feasible to have a physical connection between a non-backbone area and the backbone, the OSPF standart allows the use of virtual connections to the backbone. These virtual connections are known as virtual links, but this concept is not included in the current CCNA syllabus）。</p>
<p>位处各区域中的路由器，都存储着其所在区域的详细拓扑信息。而在各区域中，一台或多台的路由器，又被作为区域边界路由器（Area Border Routers, ABRs），区域边界路由器通过在不同区域之间通告汇总路由信息，而促进区域间的路由（facilitate inter-area routing by advertising summarised routing informaiton between the differenct areas）。本功能实现 OSPF 网络中的以下几个目标。</p>
<p>在 OSPF 域层面减小 LSAs 的扩散范围, Reduces the scope of LSAs flooding throughout the OSPF domain<br>在区域之间隐藏详细拓扑信息, Hides detailed topology informaiton between areas<br>OSPF域中端到端连通性的实现, Allows for end-to-end connectivity within the OSPF domain<br>在 OSPF 域内部创建逻辑边界, Creates logical boundaries within the OSPF domain<br>注意： 尽管 ICND1 大纲仅涉及到单区域 OSPF （single-area OSPF）, 但为把大部分理论纳入讨论背景，有必要说一下多区域 OSPF （multi-area OSPF）。</p>
<p>OSPF骨干区域从 ABRs 接收到汇总路由信息。该路由信息被散布到 OSPF 网络中的所有其它非骨干区域。在网络拓扑发生变化时，变化信息就被散布到整个的 OSPF 域，令到所有区域中的所有路由器都有着网络的统一视图（The OSPF backbone area receives summarised routing informaiton from the ABRs. The routing informaiton is disseminated to all other non-backbone areas within the OSPF network. When a change to the network topology occurs, this informaiton is disseminated throughout the entire OSPF domain, allowing all routers in all areas to have a consistent view of the network）。下图12.1演示的网络拓扑，就是一个多区域 OSPF 部署的示例。</p>
<p>一个多区域 OSPF 网络</p>
<p>图12.1 – 一个多区域 OSPF 网络</p>
<p>图12.1演示了一个基本的多区域 OSPF 网络。1、2号区域连接到0号区域，也就是 OSPF 骨干上。1号区域中，路由器R1、R2和R3交换着区域内（intra-area）路由信息，并维护着那个区域的详细拓扑。R3作为 ABR ，生成一条区域间汇总路由（an inter-area summary route）, 并将该路由通告给 OSPF 骨干。</p>
<p>R4，也就是2号区域的 ABR ，从0号区域接收到R3通告出的汇总信息，并将其扩散到其邻接区域。这样做就令到R5和R6知悉位处其本地区域外、但仍在 OSPF 域内的那些路由了。同样概念也适用于2号区域内的路由信息（R4, the ABR for Area 2, receives the summary informaiton from Area 0 and floods it into its adjacent area. This allows routers R5 and R6 to know of the routes that reside outside of their local area but within the OSPF domain. The same concept would also be applicable to the routing informaiton within Area 2）。</p>
<p>总的来讲， ABRs 都维护着所有其各自连接区域的 LSDB 信息。而各个区域中的所有路由器，都有着属于其特定区域的详细拓扑信息。这些路由器交换着区域内的路由信息。 ABRs 则将所连接区域的汇总信息通告给其它 OSPF 区域，以实现域内各子域（区域）间的路由（In summation, the ABRs maintain LSDB informaiton for all the areas in which they are connected. All routers within each area have detailed topology informaiton pertaining to that specific area. These routers exchange intra-area routing informaiton. The ABRs advertise summary informaiton from each of their connected areas to other OSPF areas, allowing inter-area routing within the domain）。</p>
<p>注意： 本书后面会详细说明OSPF ABRs及其它 OSPF 路由器类型。</p>
<p>组网类型<br>Network Types</p>
<p>对不同传输介质， OSPF 采用不同默认组网类型，有下面这些:</p>
<p>非广播组网（在多点非广播多路复用传输介质上，也就是 FR 和ATM, 默认采用此种组网类型， Non-Broadcast，default on Multipoint Non-Broadcast Multi-Access(FR and ATM)）<br>点对点组网（在 HDLC 、 PPP 、 FR 及 ATM 的 P2P 子接口，以及 ISDN 介质上，默认采用此种组网类型， Point-to-Point，default on HDLC, PPP, P2P subinterface on FR and ATM, and ISDN）<br>广播组网（在以太网和令牌环介质上，默认采用此种组网类型， Broadcast，default on Ethernet and Token Ring）<br>点对多点组网（Point-to-Multipoint）<br>环回组网（默认在环回接口上采用此种组网类型， Loopback，default on Loopback interfaces）<br>非广播网络是指那些没有原生的广播或多播流量支持的网络类型。非广播类型网络的最常见实例就是帧中继网络。非广播类型网络需要额外配置，以实现广播和多播支持。在这种网络上， OSPF 选举出一台指定路由器(a Designate Router, DR), 及&#x2F;或一台备用指定路由器（a Backup Designated Router, BDR）。在本书后面会对这两台路由器进行说明。</p>
<p>思科 IOS 软件中，非广播类型网络上开启了 OSPF 的路由器，默认每30秒发出Hello数据包。若4个Hello间隔，也就是120秒中都没有收到Hello数据包，那么该邻居路由器就被认为是“死了”。下面的输出演示了在一个帧中继串行接口上show ip ospf interface命令的输出。</p>
<p>R2#show ip ospf interface Serial0&#x2F;0<br>Serial0&#x2F;0 is up, line protocol is up<br>    Internet Address 150.1.1.2&#x2F;24, Area 0<br>    Process ID 2, Router ID 2.2.2.2, Network Type NON_BROADCAST, Cost: 64<br>    Transmit Delay is 1 sec, State DR, Priority 1<br>    Designated Router (ID) 2.2.2.2, Interface address 150.1.1.2<br>    Backup Designated Router (ID) 1.1.1.1, Interface address 150.1.1.1<br>    Timer intervals configured, Hello 30, Dead 120, Wait 120, Retransmit 5<br>        oob-resync timeout 120<br>        Hello due in 00:00:00<br>    Supports Link-local Signaling (LLS)<br>    Index 2&#x2F;2, flood queue length 0<br>    Next 0x0(0)&#x2F;0x0(0)<br>    Last flood scan length is 2, maximum is 2<br>    Last flood scan time is 0 msec, maximum is 0 msec<br>    Neighbor Count is 1, Adjacent neighbor count is 1<br>        Adjacent with neighbor 1.1.1.1 (Backup Designated Router)<br>    Suppress Hello for 0 neighbor(s)<br>一条点对点连接, 简单来说就是一条两个端点之间的连接。 P2P 连接的实例，包括采用 HDLC 及 PPP 封装的物理 WAN 接口，以及 FR 和 ATM 的点对点子接口。OSPF点对点组网类型中，不会选举出 DR 和BDR。在 P2P 类型网络上， OSPF 每10秒发出Hello数据包。在这些网络上，”死亡“间隔是Hello间隔的4倍，也就是40秒（A Point-to-Point(P2P) connection is simply a connection between two endpoints only. Examples of P2P connections include physical WAN interfaces using HDLC and PPP encapsulation, and Frame Relay(FR) and Asynchronous Transfer Mode(ATM) Point-to-Point subinterfaces. No DR or BDR is elected on OSPF Point-to-Point network types. By default, OSPF sends Hello packets out every 10 seconds on P2P network types. The “dead” interval on these network types is four times the Hello interval, which is 40 seconds）。下面的输出演示了在一条 P2P 链路上的show ip ospf interface命令的输出。</p>
<p>R2#show ip ospf interface Serial0&#x2F;0<br>Serial0&#x2F;0 is up, line protocol is up<br>    Internet Address 150.1.1.2&#x2F;24, Area 0<br>    Process ID 2, Router ID 2.2.2.2, Network Type POINT_TO_POINT, Cost: 64<br>    Transmit Delay is 1 sec, State POINT_TO_POINT<br>    Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5<br>        oob-resync timeout 40<br>        Hello due in 00:00:03<br>    Supports Link-local Signaling (LLS)<br>    Index 2&#x2F;2, flood queue length 0<br>    Next 0x0(0)&#x2F;0x0(0)<br>    Last flood scan length is 1, maximum is 1<br>    Last flood scan time is 0 msec, maximum is 0 msec<br>    Neighbor Count is 1, Adjacent neighbor count is 1<br>        Adjacent with neighbor 1.1.1.1<br>    Suppress Hello for 0 neighbor(s)<br>广播类型网络，是指那些原生支持广播和多播流量的网络，最常见例子就是以太网。就如同在非广播网络中一样， OSPF 也会在广播网络上选举一台 DR 及&#x2F;或 BDR 。默认情况下， OSPF 每隔10秒发出Hello数据包，而如在4倍 Hello 间隔中没有收到Hello数据包，就宣告邻居”死亡“。下面的输出演示了在一个FastEthernet接口上show ip ospf interface命令的输出。</p>
<p>R2#show ip ospf interface FastEthernet0&#x2F;0<br>FastEthernet0&#x2F;0 is up, line protocol is up<br>    Internet Address 192.168.1.2&#x2F;24, Area 0<br>    Process ID 2, Router ID 2.2.2.2, Network Type BROADCAST, Cost: 64<br>    Transmit Delay is 1 sec, State BDR, Priority 1<br>    Designated Router (ID) 192.168.1.3, Interface address 192.168.1.3<br>    Backup Designated Router (ID) 2.2.2.2, Interface address 192.168.1.2<br>    Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5<br>        oob-resync timeout 40<br>        Hello due in 00:00:04<br>    Supports Link-local Signaling (LLS)<br>    Index 1&#x2F;1, flood queue length 0<br>    Next 0x0(0)&#x2F;0x0(0)<br>    Last flood scan length is 1, maximum is 1<br>    Last flood scan time is 0 msec, maximum is 0 msec<br>    Neighbor Count is 1, Adjacent neighbor count is 1<br>        Adjacent with neighbor 192.168.1.3 (Designated Router)<br>    Suppress Hello for 0 neighbor(s)<br>点对多点是一种非默认 OSPF 组网类型。也就是说，此种组网类型必须使用接口配置命令ip ospf network point-to-point-multicast [non-broadcast]手动进行配置。默认情况下，该命令默认应用于一个广播型点对多点类型网络的。此默认组网类型允许 OSPF 采用多播数据包来动态地发现其邻居路由器。此外在广播型点对多点网络类型上，不进行DR&#x2F;BDR选举（Point-to-Multipoint is a non-default OSPF network type. In other words, this network type must be configured manually using the ip ospf network point-to-multipoint [non-broadcast] interface configuration command. By default, this command defaults to a Broadcast Point-to-Multipoint network type. This default network type allows OSPF to use Multicast packets to discover its neighbour routers. In addition, there is no DR&#x2F;BDR election held on Broadcast Point-to-Multipoint network types）。</p>
<p>关键字[non-broadcast]将点对多点网络配置为非广播点对多点网络。这样做就要求静态的 OSPF 邻居配置，因为此时 OSPF 不会使用多播来动态地发现其邻居路由器。此外，这种网络类型不要求为指定网段进行 DR 及&#x2F;或 BDR 选举。此种组网的主要用途，即允许分配邻居开销到邻居路由器，而非使用指定给接口的开销，作为那些自所有邻居处收到的路由的开销（The [non-broadcast] keyword configures the Point-to-Multipoint network type as a Non-Broadcast Point-to-Multipoint network. This requires static OSPF neighbour configuration, as OSPF will not use Multicast to discover dynamically its neighbour routers. Additionally, this network type does not require the election of a DR and&#x2F;or a BDR router for the designated segment. The primary use of this network type is to allow neighbor costs to be assigned to neighbors instead of using the interface-assigned cost for routes received from all neighbors）。</p>
<p>点对多点组网类型，典型地用于部分全通辐射状非广播多路访问网络。不过此种组网类型也可指定给诸如广播多路访问网络（比如以太网）等的其它类型网络（The Point-to-Multipoint network type is typically used in partial-mesh hub-and-spoke Non-Broadcast Multi-Access(NBMA) networks. However, this network type can also be specified for other networks, such as Broadcast Multi-Access networks(e.g., Ethernet)）。默认情况下，在点对多点网络上， OSPF 每30秒发出一个Hello数据包。默认死亡间隔是Hello间隔的4倍，也就是120秒。</p>
<p>下面的输出演示了在一个经手动配置为点对多点网络的帧中继串行接口上的show ip ospf interface命令的输出。</p>
<p>R2#show ip ospf interface Serial0&#x2F;0<br>Serial0&#x2F;0 is up, line protocol is up<br>    Internet Address 150.1.1.2&#x2F;24, Area 0<br>    Process ID 2, Router ID 2.2.2.2, Network Type POINT_TO_MULTIPOINT, Cost: 64<br>    Transmit Delay is 1 sec, State POINT_TO_MULTIPOINT<br>    Timer intervals configured, Hello 30, Dead 120, Wait 120, Retransmit 5<br>        oob-resync timeout 120<br>        Hello due in 00:00:04<br>    Supports Link-local Signaling (LLS)<br>    Index 2&#x2F;2, flood queue length 0<br>    Next 0x0(0)&#x2F;0x0(0)<br>    Last flood scan length is 1, maximum is 2<br>    Last flood scan time is 0 msec, maximum is 0 msec<br>    Neighbor Count is 1, Adjacent neighbor count is 1<br>        Adjacent with neighbor 1.1.1.1<br>    Suppress Hello for 0 neighbor(s)<br>OSPF要求链路上两台路由器组网类型一致（一致的意思是两台路由器要么都进行选举要么都不进行选举）的主要原因在于计时器的数值。就像上面各个输出中演示的那样，不同组网类型采用了不同Hello数据包发送及死亡计时器间隔。为成功建立一个 OSPF 邻接关系，在两台路由器上这些数值必须匹配。</p>
<p>思科 IOS 软件允许通过使用接口配置命令ip ospf hello-interval &lt;1-65535&gt;及ip ospf dead-interval [&lt;1-65535&gt;|minimal]，对默认OSPF Hello数据包及死亡计时器进行修改。ip ospf hell0-interval &lt;1-65535&gt;命令用于指定Hello间隔的秒数。在执行该命令后，软件会自动将死亡间隔配置为所配置的Hello包间隔的4倍。比如，假定某台路由器做了如下配置。</p>
<p>R2(config)#interface Serial0&#x2F;0<br>R2(config-if)#ip ospf hello-interval 1<br>R2(config-if)#exit<br>通过在上面的R2上将Hello数据包间隔设置为1, 思科 IOS 软件就会自动的将默认死亡计时器调整为Hello间隔的4倍，就是4秒。下面的输出对此进行了演示。</p>
<p>R2#show ip ospf interface Serial0&#x2F;0<br>Serial0&#x2F;0 is up, line protocol is up<br>    Internet Address 10.0.2.4&#x2F;24, Area 2<br>    Process ID 4, Router ID 4.4.4.4, Network Type POINT_TO_POINT, Cost: 64<br>    Transmit Delay is 1 sec, State POINT_TO_POINT<br>    Timer intervals configured, Hello 1, Dead 4, Wait 4, Retransmit 5<br>        oob-resync timeout 40<br>        Hello due in 00:00:00<br>…<br>[Truncated Output]<br>配置OSPF<br>OSPF Configuration</p>
<p>本节对 OSPF 配置基础进行说明。</p>
<p>在思科 IOS 软件中开启OSPF<br>Enabling OSPF in Cisco IOS Software</p>
<p>在思科 IOS 软件中，通过使用全局配置命令router ospf [process id]开启 OSPF 。关键字[process id]是本地有效的(locally sinificant)，邻接关系的建立无需网络中所有路由器的进程号一致。运用本地有效的进程号，允许在同一台路由器上配置多个 OSPF 实例。</p>
<p>OSPF进程号是一个1与65535之间的整数。每个 OSPF 进程都维护着其独立链路状态数据库（ LSDB ）；但是，所有路由都放进的是同一 IP 路由表。也就是说，对配置在路由器上的各个单独 OSPF 进程，并没有各自唯一的 IP 路由表。</p>
<p>在思科 IOS 软件早期版本中，如路由器上没有至少一个的接口配置了有效 IP 地址且处于up&#x2F;up状态，就无法开启 OSPF 。此限制在当前版本思科 IOS 软件中去除了。假如路由器没有接口配置了有效 IP 地址且处于up&#x2F;up状态，那么思科 IOS 将创建出一个接近数据库（a Proximity Database, PDB）并允许创建出进程。但是，要记住除非选定路由器 ID ，该进程就是非活动的进程，而路由器 ID 的选定，可通过下面两种方式完成。</p>
<p>在某个接口上配置一个有效 IP 地址，并将该接口开启<br>使用命令router-id为该路由器手动配置一个 ID （见下）<br>作为一个例子，看看下面的所有接口都关闭的路由器。</p>
<p>R3#show ip interface brief<br>Interface		IP-Address	OK?	Method	Status					Protocol<br>FastEthernet0&#x2F;0	unassigned	YES	manual	administratively down	down<br>Serial0&#x2F;0		unassigned	YES	NVRAM	administratively down	down<br>Serial0&#x2F;1		unassigned	YES	unset	administratively down	down<br>接着，使用全局配置命令router ospf [process id]在该路由器上开启了 OSPF ， 如下面输出所示。</p>
<p>R3(config)#router ospf 1<br>R3(config-router)#exit<br>基于此配置，思科 IOS 软件分配给该进程一个默认0.0.0.0的路由器 ID ，如下面show ip protocols命令的输出所示。</p>
<p>R3#show ip protocols<br>Routing Protocol is “ospf 1”<br>    Outgoing update filter list for all interfaces is not set<br>    Incoming update filter list for all interfaces is not set<br>    Router ID 0.0.0.0<br>    Number of areas in this router is 0. 0 normal 0 stub 0 nssa<br>    Maximum path: 4<br>    Routing for Networks:<br>Reference bandwidth unit is 100 mbps<br>    Routing Information Sources:<br>      Gateway	Distance	Last Update<br>    Distance: (default is 110)<br>但是，命令show ip ospf [process id]揭示出该进程实际上并不是活动的，且表明需要配置一个路由器 ID ， 其输出如下面所示。</p>
<p>R3#show ip ospf 1<br>%OSPF: Router process 1 is not running, please configure a router-id<br>开启接口或网络的 OSPF 路由<br>Enabling OSPF Routing for Interfaces or Networks</p>
<p>在开启 OSPF 后，就可以执行两个操作，来为路由器上一个或更多的网络或接口开启 OSPF 路由。这两个操作如下。</p>
<p>使用路由器配置命令(router configuration command)[network] [wildcard] area [area id]<br>使用接口配置命令ip ospf [process id] area [area id]<br>与 EIGRP 不同， OSPF 强制使用反掩码且必须配置反掩码; 但与在 EIGRP 中的情况一样，反掩码提供了同样的功能，也就是匹配指定范围中的接口（unlike EIGRP, the wildcard is mandatory in OSPF and must be configured; however, as is the case with EIGRP, it serves the same function in that it matches interfaces within the range specified）。比如，语句network 10.0.0.0 0.255.255.255 area 0，就会对10.0.0.1&#x2F;30、10.5.5.1&#x2F;24, 甚至10.10.10.1&#x2F;25这样的 IP 地址和子网掩码组合的接口，开启 OSPF 路由。基于该 OSPF 网络配置，这些接口都会被分配到 0 号区域。</p>
<p>注意： OSPF反掩码可以与传统子网掩码同样格式敲入，比如network 10.0.0.0 255.0.0.0 area 0。在这种情况下，思科 IOS 软件就会将子网掩码翻转，将得到的反掩码输入到运行配置（the running configuration）。另外要记住OSPF也支持使用全 1s 和全 0s 反掩码，来对某个指定接口开启OSPF。这样的配置在某个特定接口上开启 OSPF ，但路由器通告配置在该接口自身的实际子网掩码（this configuration enables OSPF on a paricular interface but the router advertises the actual subnet mask configured on the interface itself）。</p>
<p>在执行了network [network] [wildcast] area [area id]命令后，路由器就在与指定网络和反掩码组合匹配的那些接口上发出Hello数据包，来尝试发现邻居路由器。接着在 OSPF 数据库交换期间，将连接子网通告给一台或更多的邻居路由器，最终，它们将所有子网信息都被加入到这些 OSPF 路由器的 OSPF 链路状态数据库（OSPF LSDB）中。</p>
<p>在命令network [network] [wildcard] area [area id]之后，路由器又对最具体条目做出匹配，以决定将接口要分配给的区域。作为实例，想想下面这些 OSPF 网络语句。</p>
<p>第一条网络配置语句：network 10.0.0.0 0.255.255.255 area 0<br>第二条：network 10.1.0.0 0.0.255.255 area 1<br>第三条：network 10.1.1.0 0.0.0.255 area 2<br>第四条：network 10.1.1.1 0.0.0.0 area 3<br>第五条：network 0.0.0.0 0.0.0.0 area 4<br>按照路由器上的此种配置，同时路由器上又配置了如下表12.1中展示的这些环回接口。</p>
<p>接口	IP地址&#x2F;掩码<br><code>Loopback 0</code>	<code>10.0.0.1/32</code><br><code>Loopback 1</code>	<code>10.0.1.1/32</code><br><code>Loopback 2</code>	<code>10.1.0.1/32</code><br><code>Loopback 3</code>	<code>10.1.1.1/32</code><br><code>Loopback 4</code>	<code>10.2.0.1/32</code><br>就像前面指出的那样，在执行了network [network] [wildcard] area [area id]命令后，路由器匹配最具体的网络条目（最小的网络），来决定该接口应分配到的区域。对于在路由器上的网络配置语句及已配置的接口，命令show ip ospf interface brief会显示出这些接口都分配给了以下 OSPF 区域。</p>
<p>R1#show ip ospf interface brief<br>Interface	PID	Area	IP Address&#x2F;Mask	Cost	State	Nbrs F&#x2F;C<br>Lo4			1	0		10.2.0.1&#x2F;32		1		LOOP	0&#x2F;0<br>Lo1			1	0		10.0.1.1&#x2F;32		1		LOOP	0&#x2F;0<br>Lo0			1	0 		10.0.0.1&#x2F;32 	1 		LOOP	0&#x2F;0<br>Lo2 		1 	1 		10.1.0.1&#x2F;32 	1 		LOOP	0&#x2F;0<br>Lo3 		1 	3 		10.1.1.1&#x2F;32 	1 		LOOP	0&#x2F;0<br>注意： 在运行配置（the running configuration）中，无需考虑网络语句敲入顺序，路由器的show running-config输出中最具体的网络条目，始终列在前面。</p>
<p>接口配置命令ip ospf [process id] area [area id]令到无需使用路由器配置命令network [network] [wildcard] area [area id]。该命令对某个指定接口开启 OSPF 路由，同时将该接口分配给指定 OSPF 区域。这两个命令完成同样的基本功能，且可互换使用。</p>
<p>此外，比如有两台路由器是背靠背连接（connected back-to-back），一台使用接口配置命令ip ospf [process id] area [area id]进行了配置，而其邻居路由器使用路由器配置命令network [network] [wildcard] area [area id]进行了配置，假设两个区域 IDs 相同，那么两台路由器将成功建立 OSPF 邻接关系。</p>
<p>OSPF区域<br>OSPF Areas</p>
<p>OSPF区域号既可以配置为一个0到4294967295之间的整数，也可使用点分十进制表示法（也就是采用 IP 地址格式）。与 OSPF 进程号不同，为建立邻接关系， OSPF 区域号必须匹配。最常见 OSPF 区域配置类型为使用一个整数来指定 OSPF 区域。确保对支持的两种区域配置方式都要熟悉。</p>
<p>OSPF路由器ID<br>OSPF Router ID</p>
<p>为令到 OSPF 在某个网络上运行起来，所有路由器都必须有个唯一身份编号（a unique identifying number），且在 OSPF 环境下要用到路由器 ID 。</p>
<p>在决定 OSPF 路由器 ID 时，思科 IOS 选用所配置环回接口中最高的 IP 地址。如未曾配置环回接口，软件就会使用所有配置的物理接口中最高的 IP 地址，来作为 0SPF 路由器 ID 。思科 IOS 软件同样允许管理员使用路由器配置命令router-id [address], 来手动指定路由器 ID 。</p>
<p>环回接口极为有用，特别是在测试当中，因为它们无需硬件且是逻辑的，因此绝不会宕掉。</p>
<p>在下面的路由器上，给Loopback0配置了 IP 地址1.1.1.1&#x2F;32, 给F0&#x2F;0配置了2.2.2.2&#x2F;24。接着在路由器上给所有接口配置了 OSPF 。</p>
<p>Router(config-if)#router ospf 1<br>Router(config-router)#net 0.0.0.0 255.255.255.255 area 0<br>Router(config-router)#end<br>Router#<br>%SYS-5-CONFIG_I: Configured from console by console<br>Router#show ip protocols<br>Routing Protocol is “ospf 1”<br>    Outgoing update filter list for all interfaces is not set<br>    Incoming update filter list for all interfaces is not set<br>    Router ID 1.1.1.1<br>    Number of areas in this router is 1. 1 normal 0 stub 0 nssa<br>    Maximum path: 4<br>    Routing for Networks:<br>        0.0.0.0 255.255.255.255 area 0<br>    Routing Information Sources:<br>    Gateway 	Distance	Last Update<br>    1.1.1.1 	     110	00:00:14<br>    Distance: (default is 110)<br>但又想要将路由器 ID 硬编码（hard code）为10.10.10.1。那么可通过再配置一个使用该 IP 地址的环回接口，或简单地将这个 IP 地址加在 OSPF 路由器 ID 处。为令到改变生效，必须重启路由器或在路由器上清除该IP OSPF进程（清除现有数据库）。</p>
<p>Router#conf t<br>Enter configuration commands, one per line.<br>End with CNTL&#x2F;Z.<br>Router(config)#router ospf 1<br>Router(config-router)#router-id 10.10.10.1<br>Router(config-router)#Reload or use “clear ip ospf process” command, for this to take effect<br>Router(config-router)#end<br>Router#<br>%SYS-5-CONFIG_I: Configured from console by console<br>Router#clear ip ospf process<br>Reset ALL OSPF processes? [no]: yes<br>Router#show ip prot<br>Routing Protocol is “ospf 1”<br>    Outgoing update filter list for all interfaces is not set<br>    Incoming update filter list for all interfaces is not set<br>    Router ID 10.10.10.1<br>    Number of areas in this router is 1. 1 normal 0 stub 0 nssa<br>    Maximum path: 4<br>    Routing for Networks:<br>        0.0.0.0 255.255.255.255 area 0<br>    Routing Information Sources:<br>    Gateway 	Distance	Last Update<br>    1.1.1.1 	     110	00:03:15<br>Distance: (default is 110)<br>到第39天，DR和 BDR 选举时，就将看到这个路由器 ID 有着特别的重要性。</p>
<p>OSPF被动接口<br>OSPF Passive Interfaces</p>
<p>被动接口可被描述成在其上没有路由更新发出的接口。在思科 IOS 软件中，通过使用路由器配置命令passive-interface [name], 将某接口配置为被动接口。如路由器上有多个接口需要配置为被动接口，就应使用<strong>passive-interface default这个路由器配置命令</strong>。此命令将路由器上那些位处所配置网络范围内的所有接口，都配置为被动模式。而那些需要允许在其上形成邻接关系或邻居关系的接口，就应使用路由器配置命令no passive-interface [name]对其进行配置。</p>
<p>被动接口配置在 OSPF 和 EIGRP 中的工作方式是一样的，也就是一旦某接口被标记为被动接口，经由该接口形成的所有邻居关系都会被拆除，同时 再也不会通过该接口发送或接收Hello数据包了。不过，根据路由器上所配置的网络配置语句，该接口仍然会继续受通告。</p>
<p>Router(config)#router ospf 10<br>Router(config-router)#passive-interface f0&#x2F;0<br>Router#show ip ospf int f0&#x2F;0<br>FastEthernet0&#x2F;0 is up, line protocol is up<br>    Internet address is 192.168.1.1&#x2F;24, Area 0<br>    Process ID 10,Router ID 172.16.1.1,Network Type BROADCAST, Cost: 1<br>    Transmit Delay is 1 sec, State WAITING, Priority 1<br>    No designated router on this network<br>    No backup designated router on this network<br>    Timer intervals configured,Hello 10, Dead 40, Wait 40,Retransmit 5<br>        No Hellos (Passive interface)<br>第 12 天问题<br>What protocol does OSPF use?<br>How does OSPF determine whether other Link State routers are operating on the interfaces as well?<br>When a _______ routing protocol is enabled for a particular link, information associated with that network is added to the local Link State Database (LSDB).<br>OSPF utilises IP Multicast when sending and receiving updates on Multi-Access networks, such as Ethernet. True or false?<br>OSPF is a hierarchical routing protocol that logically divides the network into subdomains referred to as _______.<br>Name at least 4 OSPF network types.<br>Name the command used to enter OSPF configuration mode.<br>When determining the OSPF router ID, Cisco IOS selects the lowest IP address of the configured Loopback interfaces. True or false?<br>What command can you use to assign an interface to OSPF Area 2 (interface level command)?<br>_______ can be described as interfaces over which no routing updates are sent.<br>##第 12 天答案</p>
<p>IP number 89.<br>By sending Hello packets.<br>Link State.<br>True.<br>Areas.<br>Non-Broadcast, Point-to-Point, Broadcast, Point-to-Multipoint, Point-to-Multipoint Non-Broadcast, and Loopback.<br>The router ospf <id> command.<br>False.<br>The ip ospf <id> area 2<br>Passive.<br>##第 12 天实验</p>
<p>###OSPF基础实验</p>
<p>沿用第10天的实验场景（两台直接连接的路由器，各自其上的环回接口），但取代配置 RIP 及对物理和环回接口进行通告的是，使用OSPF 0号区域实现（but instead of configuring RIP and advertising the physical and Loopback interfaces, do this using OSPF Area 0）。</p>
<p>分配一个 IPv4 地址给直接连接的接口（10.10.10.1&#x2F;24及10.10.10.2&#x2F;24）<br>运用ping操作，测试直接连通性<br>分别在两台路由器上配置一个环回接口，并自两个不同范围为其分配上地址（11.11.11.1&#x2F;32及12.12.12.2&#x2F;32）<br>配置上标准OSPF 1号进程，并在0号区域中通告所有本地网络。同时为两台设备配置一个路由器 ID 。<br>R1:</p>
<p>router ospf 1<br>router-id 1.1.1.1<br>network 10.10.10.0 0.0.0.255 area 0<br>network 11.11.11.1 0.0.0.0 area 0<br>R2:</p>
<p>router ospf 1<br>router-id 2.2.2.2<br>network 10.10.10.0 0.0.0.255 area 0<br>network 12.12.12.2 0.0.0.0 area 0<br>自R1向R2的环回接口执行 ping 操作，以测试连通性<br>执行一条show ip route命令，来验证有通过 OSPF 接收到路由<br>执行一条show ip protocols命令，来验证有配置 OSPF 且在设备上是活动的<br>坚持特定于 OSPF 的接口参数：show ip ospf interface及show ip ospf interface brief<br>在两台路由器上（直接连接接口）修改 OSPF 的 Hello 包和死亡计时器：ip ospf hello及ip ospf dead<br>执行一下show ip ospf 1命令，看看路由进程参数<br>重复该实验，但这次使用ip ospf 1 area 0 interface specific命令，而不是在router OSPF 下的network命令，对各个网络进行通告。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/11/14/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/" rel="next" title="静态路由">
                <i class="fa fa-chevron-left"></i> 静态路由
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/11/18/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%BF%AE%E6%94%B9%E5%99%A8%E5%88%B6%E4%BD%9C/" rel="prev" title="植物大战僵尸修改器制作">
                植物大战僵尸修改器制作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.webp"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">frozenfish</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
